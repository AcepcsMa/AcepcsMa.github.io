<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haoxiang&#39;s Tech Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-10T23:07:58.481Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Haoxiang Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[论文研读]System R by IBM</title>
    <link href="http://yoursite.com/2019/04/10/system_r_ibm_reading/"/>
    <id>http://yoursite.com/2019/04/10/system_r_ibm_reading/</id>
    <published>2019-04-10T23:00:00.000Z</published>
    <updated>2019-04-10T23:07:58.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/04/10。</p></blockquote><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>最近在跟着课件自学Stanford的 <a href="http://web.stanford.edu/class/cs245/" target="_blank" rel="noopener">CS 245</a> 课程，其中有一篇课外阅读是读IBM研究院在70年代出版的paper <a href="http://web.stanford.edu/class/cs245/readings/system-r-history-evaluation.pdf" target="_blank" rel="noopener">A History and Evaluation of System R</a>。</p><p>在开读之前我其实是比较轻视的，觉得这种老掉牙的数据库paper怎么能跟上现代数据库的节奏，但是读完之后惊为天人，这篇paper不亏为现代数据库领域的基石之作之一。paper里提到的很多思想、概念、实验都能在MySQL中找到对应的影子，非常让我震惊。</p><p>本文将以笔记的形式记录我阅读 <a href="http://web.stanford.edu/class/cs245/readings/system-r-history-evaluation.pdf" target="_blank" rel="noopener">A History and Evaluation of System R</a> 所总结概括出来的知识点。</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol><li>数据存储要和程序本身分开，为了“data independence”。</li><li><p>自从Codd提出了关系型数据模型（relational data model）后，大家都很认同，认为这是实现“data independence”的核心：</p><ul><li>在关系型数据库系统里，从用户的角度看，数据库里存的就是数据本身，而不是数据 + 复杂的数据关联关系（指针、links、chains、parents……），<strong>用户不应该看见一堆数据间的连线</strong></li><li>在关系型数据库系统里，当用户要查询数据时，不需要再写复杂无比的查询算法（类似那种在一幅图里怎么遍历，何时结束的算法），只需要写high-level的查询语句（主要就是指<code>SQL</code>）即可</li></ul></li><li><p>在早期，大家都会担心：关系型数据库系统用的high-level query language（主要就是指<code>SQL</code>）到底在性能上会不会比程序员写出来的“查询算法”好。</p></li><li><p>System R项目的目标有：</p><ul><li>实现支持high-level query的API，供用户使用，以实现“data independence”</li><li>支持多种数据库应用，如事务、ad hoc查询、报表生成</li><li>实现可用性高的系统，可以随时增删系统内的数据而不需要停机或重启</li><li>支持并发、且并发安全</li><li>实现出错恢复机制</li><li>灵活地实现多种数据视图，且支持多用户操作</li><li>高性能</li></ul></li></ol><h3 id="Phase-0"><a href="#Phase-0" class="headerlink" title="Phase 0"></a>Phase 0</h3><ol><li>Phase 0<strong>只是为了快速做一个原型出来</strong>，有很多细节没有实现。</li><li>为了支持high-level的关系型查询（<code>SQL</code>），解析器是基于<code>XRM</code>，然后用<code>PL/I</code>语言写的。</li><li>SQL的实现中，Phase 0支持子查询（sub query），但不支持join操作。所以在一条SQL中可能要查N张表，但其实是通过子查询的形式一张一张查过去，然后把上一张表的结果当做过滤条件，<strong>最后的结果只是从单张表中取出。</strong></li><li>Phase 0一个很重要的设计思想是：数据库本身的内容和结构信息，称为<code>Catalog</code>（可以理解为meta data），<strong>也以relation（表）的形式存在数据库当中，而不是存在一个外部文件或者其他程序里。</strong></li><li>在Phase 0里，每一行数据被称为<code>tuple</code>，每一张表被称为<code>relation</code>，<code>relation = N * tuple</code>，每个<code>tuple</code>有自己唯一的32bit长的<code>tuple ID = TID</code>。</li><li><p>在Phase 0基于的<code>XRM</code>的实现里，对于每一个<code>tuple</code>除了要记录<code>tuple ID</code>到<code>domain value</code>的指针，反过来，<strong>还得维护一个<code>domain value</code>到<code>TID</code>的反向记录（inversion）（类似于倒排索引的思想）</strong>，这样能够加速查询过滤。</p><p> <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/system_r_phase_0_storage.png" alt=""></p><p> <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/system_r_phase_0_1.png" alt=""></p></li><li><p>Phase 0在SQL优化器的实现方面带来很多启发：</p><ul><li>优化器不仅要关注怎样能取到最少数量的tuples，还得考虑全过程里的“hidden costs”：怎么最优地构造<code>TID list</code>、怎么最优地取tuples、怎么最优地通过tuples取具体的数据值。</li><li>其实“取最少的tuples”不算是最好的优化指标，相比于读取的tuple数量，<strong>更应该关注实际发生的disk I/O的次数</strong>（在没有SSD的年代，一次随机disk I/O意味着磁盘寻道 + 旋转 + 读取，代价非常昂贵）。</li><li><code>XRM</code>将domain value和tuples分离，通过指针关联，<strong>当大规模读取数据时其实会导致大量的随机disk I/O，性能会有明显下降。</strong></li><li>SQL优化时除了考虑disk I/O，其实也还应该考虑<strong>CPU时间</strong>，在很多情况下执行查询语句其实是CPU密集型任务，所以<code>Cost = a * DISK_IO + b * CPU_TIME</code>比较合理，其中系数<code>a</code>和<code>b</code>应该要根据系统的不同来动态调节。</li><li>join功能非常重要，所以必须实现。</li><li>相比于特别复杂的SQL查询，其实看起来形式简单的SQL查询也得认真优化，不能只关注于特别复杂的查询。</li></ul></li></ol><h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h3><ol><li>跟Phase 0相比，Phase 1实现的功能更加齐全，它弃用了之前的<code>XRM</code>，改用了<code>RSS</code>（Research Storage System，个人认为可以类比于存储引擎） + <code>RDS</code>（Relational Data System，个人理解为一个SQL编译器）的结构。</li><li>Phase 1支持多用户并发操作。</li><li><p>Phase 1实现了几个子系统：</p><ul><li>locking subsystem，加锁防止并发情况下update出错</li><li>view subsystem，为用户提供多种数据库视图</li><li>authorization subsystem，实现用户鉴权，限制无关用户访问</li><li>recovery subsystem，提供崩溃恢复机制</li></ul></li><li><p>开发了一个<strong>完全独立于数据库本身</strong>的访问接口层（<code>UFI</code> = User-Friendly Interface），让用户可以通过其访问数据库。</p></li><li><p><code>RDS</code>实现：</p><ul><li><code>RDS</code>相当于一个SQL编译器。其实就是用PL/I或者Cobol开发了一个编译程序，当作一个preprocesser来用，可以解析一条SQL语句，将其分解成多个机器可执行的段，打包到access module中，当access module执行的时候即调用<code>RSS</code>提供的接口，从数据库里获取数据。</li><li>由于SQL编译器和数据库是<strong>完全独立</strong>的，当数据库的结构发生了变化（例如某表上的index被删除了），会导致通过SQL编译器构造的access module出问题，所以每个access module都要记录它所对应的数据库对象（某表，某index）的依赖信息。如果某access module对应的index被删除了，那么该access module里要记录该信息，然后下次被调用的时候需要重新编译解析。</li></ul></li><li><p><code>RSS</code>实现：</p><ul><li>弃用了Phase 0的<code>XRM</code>，主要是因为tuple和value分离存储，在读数据时会导致大量额外的disk I/O。</li><li>所以在Phase 1的<code>RSS</code>里，就不再分离存储，每条record（tuple）就包含了所有value值。所以支持relation scan。</li><li>弃用了<code>XRM</code>里的<code>inversion</code>（类似于倒排索引），而改用B-Tree实现列索引（很先进的一点是当时不仅考虑到单列索引，还考虑到了多列索引）。所以支持index scan。</li><li>实现了一种叫<code>link</code>的结构，如果两条record之间有关联，record里还会保存一个指针指向另一条record。所以支持link scan。</li><li>实现了内建的sorting功能，支持在relation scan、index scan、link scan之后进行排序。</li></ul></li><li><p>subsystem的实现</p><ul><li><p>SQL优化器</p><p>  基于Phase 0的经验，优化SQL语句时应该主要考虑disk I/O，所以一条SQL语句的代价应该是disk I/O和RSS调用次数的线性加权：<code>Cost = a * DISK_IO + b * RSS_CALL</code>。</p><p>  在SQL优化执行时，还要考虑表上所建的index，考察一下该index是否具有<code>selectivity</code>（distinct value是否足够多），以及<code>clustering</code>属性（排序后的值跟物理磁盘上的存储结构一样）</p><p>  经过研究，大部分的JOIN都能被视作两种基本操作：</p><ul><li>遍历A表，每读取一行A记录，就去遍历一遍B表，取出匹配的记录。（可访问index）</li><li>给A表和B表基于JOIN列排序，然后实现merge。（一般是没有合适的index可用时这么做）</li></ul></li><li><p>View &amp; Authorization subsystem</p><p>  因为视图（View）的定义其实相当于一条SQL语句，所以在某视图上执行某SQL查询时，应该将该查询语句编译出来的语法树<code>T1</code>和视图定义的SQL语句对应的语法树<code>T0</code>合并，得到一颗组合的语法树。</p><p>  至于鉴权（Authorization），则主要通过<code>GRANT</code>和<code>REVOKE</code>关键字实现。</p></li><li><p>Recovery Subsystem</p><p>  总的来说，一个数据库系统里有3种不同的出错类型：</p><ul><li><p>磁盘出错</p><p>  为了在磁盘出错后还能恢复，需要定时生成整个系统的image（系统快照），并且各种对数据库的操作都要记录到log文件里。出错后先用latest image恢复，然后逐条执行日志恢复数据。</p></li><li><p>数据库系统本身出错</p><p>  通过维护两份数据页——“old page”和”new page”，并定期将”new page”刷到磁盘上（所谓的“check point”机制，现在MySQL也仍在采用此机制）。出错后先用”old page”把数据库恢复到某个状态，然后逐条执行日志恢复数据。</p></li><li><p>事务执行出错</p><p>  事务执行过程中出错，系统会根据该事务产生的log，反向执行每条log里的操作，回复到之前的数据库状态。</p></li></ul></li><li><p>Locking subsystem</p><p>  <strong>一开始是想实现“predicate lock”的</strong>，即给查询条件上锁。如果有人查询<code>where name = abc</code>，那就给该条件上锁，不允许别的用户同时执行<code>where name = abc</code>的查询语句。<strong>但是后来发现不可行</strong>，因为有的predicate表面上不一样，但是在语义上却是会产生冲突的，而且检测predicate间的冲突很麻烦很耗时。</p><p>  所以后来实现了层级锁机制（hierarchy of locks，<strong>直至现在的MySQL都仍沿用此思想</strong>），从锁单独某行的行锁到锁全表的表锁都实现了，当某个操作给很多行都单独上了行锁，此时可以“升级”该锁，从行锁升到表锁。</p><p>  除了真正的锁，还实现了一种意向锁（intention locks，<strong>直至现在的MySQL都仍沿用此思想</strong>），用来表示对某种资源上锁的<strong>意向</strong>。假如用户A对某表的第100行上了行锁，A也会拥有对该表的意向锁，用户B对同一张表的第200行上了行锁，B也会拥有对该表的意向锁，当A想锁全表时发现B对该表也有意向要上锁（就是B也很有可能想锁全表），系统就不允许A锁全表了。</p></li></ul></li></ol><h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h3><ol><li><p>在用户试用后，根据用户反馈，实现了对原生SQL的拓展：</p><ul><li>实现了<code>EXISTS</code>关键字，用于检测数据是否存在。</li><li>实现了<code>LIKE</code>关键字，允许用户根据pattern来模糊查询</li><li>实现了<code>PREPARE</code>和<code>EXECUTE</code>，多次执行带有不同值但同一模式的SQL语句时，不用每次都重新让optimizer来优化一遍</li><li>实现了Outer Join</li></ul></li><li><p>对SQL编译器做了一些实验：</p><p> 之前是会把SQL语句解析，编译，得到一堆可以执行的“程序段”，装入access module，再逐个执行调用RSS，取出数据。</p><p> 但是发现要得到可执行的“程序段”，Code Generation过程是要花费一定的CPU时间的。在一些特定场景下（例如只取2条记录），如果把SQL编译成程序代码所需的时间比较长，而直接通过解释器（interpretor）执行SQL耗时更少，那就应该放弃编译过程，直接用解释器执行。</p></li><li><p>Access Path Selection</p><p> 在Phase 2里用了B-Tree来实现index（fan-out大概是200）。</p><p> 除了B-Tree外，还有常见的两种构造index或者维护access path的数据结构——Hashing和Link，<strong>但是Phase 2均未采用。</strong></p><ul><li><p>Hashing</p><p>  为什么不用Hashing，是因为hash完全失去了有序性，在数据库查询场景下，经常需要对结果排序，或者把值连续的数据一次性查出来，如果结构上丧失有序性，意味着查询成本会变很高。</p></li><li><p>Link</p><p>  Link是指记录与记录之间的关联指针，不用Link是因为直接在Link上操作违背了SQL语句的初衷，如果要基于Link写一堆navigational的算法才能把数据查出来，那要SQL语句何用？</p><p>  其次，Link的维护实在太麻烦，如果对记录更新比较频繁，意味着也要频繁更新该记录link的其他记录，消耗太多资源。</p><p><strong>不过也不能否定Hashing和Link在一些特定场景下是非常高效的，取决于系统的使用场景和需求。</strong></p></li></ul></li><li><p>SQL优化器</p><p> 为了达到实验效果，改造了一下原来的优化器。当执行一条SQL时，优化器不再选择查询树里的其中一条路径去执行，而是为每条路径都生成estimated cost（<code>Cost = a * PAGE_FETCH + b * RSS_CALL</code>），然后每条路径都执行一遍。</p><p> 实验结果发现，优化器为所有路径生成的estimated cost的顺序和实际执行时的cost顺序大致吻合。也就是说，预估最耗时的路径在实际执行时也是最耗时的，预估最快的路径在实际执行时也是最快的。（看来这个SQL优化器实现的效果还是不错的）</p><p> 但是，实验发现有个问题，由于SQL优化器对应的指令集还不是很完整，所以有可能SQL优化器会miss掉真正意义上的最优路径。（<strong>也就是说它只能保证给你选的不是最差路径，未必能保证给你选出最好的路径</strong>）</p></li><li><p>View &amp; Authorization</p><p> 根据用户反馈，实现了：</p><ul><li>组（group）级别的权限控制，比user级别的范围更大</li><li>改变表的所有权，把A用户下的B表改到C用户管辖下</li><li>表定义更改后，数据reload</li></ul></li><li><p>Recovery subsystem</p><p> 发现之前的”old page”和”new page”共存机制（shadow page）会降低系统性能：</p><ul><li>“old page”和”new page”写在不同目录，如果新老page共存时，想把相关联的数据读出来会导致磁盘寻道和旋转时间剧增</li><li>系统容量限制，要同时维护”old page”和”new page”</li><li><p>checkpoint（刷脏）机制会产生一定的disk I/O，也会占用一定的CPU时间</p><p>所以，一种可行的解决方案是不要维护新老两套page，而是全靠log来实现recovery，重点就在于把脏页写到磁盘前，要确保更新操作已经被写到log里。（<strong>非常厉害的思想，也就是后来一直沿用的Write-Ahead-Log机制</strong>）</p></li></ul></li><li><p>Locking subsystem</p><p> 实现了3种隔离级别：</p><ul><li>Level 1：read uncommitted，无锁，并发情况下很可能读到脏数据</li><li>Level 2：read committed，有锁，但是锁在更新操作后马上释放</li><li><p>Level 3：repeatable read，有锁，但<strong>锁的生命周期贯穿整个事务，更新操作完不会释放锁</strong></p><p>看起来好像Level 2更“轻便”，Level 3更“安全”，但是实验观察到Level 3的锁其实更轻便，<strong>因为不需要频繁地加锁解锁，锁的状态不跟随操作，而是跟随事务。</strong></p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/04/10。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;he
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-10]Docker部署后端服务</title>
    <link href="http://yoursite.com/2019/03/22/gin-tutorial-10/"/>
    <id>http://yoursite.com/2019/03/22/gin-tutorial-10/</id>
    <published>2019-03-23T00:00:00.000Z</published>
    <updated>2019-03-22T23:52:23.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/03/22，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第十篇（最后一篇）。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><blockquote><p><strong>Note：本教程假定读者已有简单的Docker基础，并在本机开发环境中成功安装、运行了Docker Engine。Docker基础知识可参考<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="noopener">《Docker Gitbook》</a>。</strong></p></blockquote><p>在上一篇教程<a href="https://marcoma.xyz/" target="_blank" rel="noopener">《[Gin教程-9]》</a>里，我们已经在本地成功生成公钥私钥和https证书，也成功地部署了nginx，用nginx作反向代理供外部调用我们的API。</p><p>但是上篇教程里的部署完全是针对本机环境的，假如我们在本地开发完，需要把整套应用移到Production或者Test环境，那岂不是得到新环境重新把<code>MySQL</code>、<code>Redis</code>、<code>Elasticsearch</code>、<code>nginx</code>装一遍，再把项目代码重新编译，手动运行？实在是太麻烦了。</p><p>另外，我们把这么多组件全都运行在一台主机上，如果这台主机发生了异常，岂不是所有服务全都挂了？有没有办法能让多个组件分开来提高隔离性，又易于部署呢？</p><p><strong>所以，针对种种不便的情况，我们可以使用Docker来帮助我们解决问题。</strong></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ol><li><p>Docker是什么？</p><p> 根据<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/what.html" target="_blank" rel="noopener">《Docker Gitbook》</a>，Docker就是一种虚拟化技术。以前我们说虚拟化，往往会说在宿主机上开一台虚拟机，在虚拟机里跑一个操作系统（例如Windows上跑一个Ubuntu的虚拟机等等）。但是虚拟机对资源的占用过重，所以后来基于LXC、libcontainer、runC和containerd就开发了Docker——<strong>一种看起来很像虚拟机，但是比虚拟机轻量很多的虚拟化技术。</strong></p></li><li><p>为什么要用Docker？</p><ul><li><p>多环境部署方便</p><p>  依托于Docker里image和container的概念，只要制作好了image，理论上而言在所有装了Docker Engine的系统里都可以运行该image，然后成功跑起一个很像独立虚拟机的container。一份image，多处运行，部署不同环境只需要加一些环境变量即可，非常方便。</p></li><li><p>隔离性好</p><p>  多个container之间基本相互独立，每个container内部都像是拥有一套独立的系统资源——独立的文件系统、独立的网络栈、独立的块设备、独立的进程表……默认情况下隔离性已经很高了，给人感觉像是运行了多个虚拟机。</p></li><li><p>资源占用相对较低</p><p>  多个container并不需要运行在多个guest OS之上，而是由Docker Engine统一调度和管理。所以即使同时运行几十个container，也不存在几十个guest OS，对系统资源的占用相比虚拟机来说低得多。</p></li></ul></li><li><p>image和container是什么？</p><ul><li>image = 镜像，是一种<strong>静态概念</strong>，可类比成一个个写好的代码文件，里面包含了各种静态数据、bin、lib等。</li><li><p>container = 容器，是一种<strong>动态概念</strong>，可类比成一个正在run的程序。</p><p>通过<code>docker run --name &lt;container_name&gt; &lt;image_name&gt;</code>命令可以基于静态的image构建出一个container，然后让该container运行起来。</p></li></ul></li><li><p>怎么制作image？</p><p> 一般来说，制作image有两种方法：</p><ul><li>基于Dockerfile。自己写Dockerfile，然后<code>docker build ......</code>构建出一个image。类似于自己写一堆Golang代码，然后<code>go build</code>编译出一个可执行程序。Dockerfile的编写规范可参考 <a href="http://guide.daocloud.io/dcs/dockerfile-9153584.html" target="_blank" rel="noopener">DaoCloud的DCS文档</a>。</li><li>基于正在运行的container。例如在某个正在运行的container里新建了几个关键文件，然后<code>docker commit ......</code>，基于该container构建出一个image。</li></ul></li><li><p>container之间怎么交互（通信）？</p><p> 上面提到不同的container之间隔离性很高，即使在一台主机上运行，但看起来就像是多台独立的虚拟机。<strong>可以想象多台机子之间通信，肯定是要通过网络的</strong>，所以常见的通信方式有：</p><ul><li>让多个容器加入同一个namespace，不同容器使用同一套网络设备和协议。（<strong>准确来说是网络相关的namespace，关于namespace的内容请自行查阅Linux内核相关知识，此处不展开</strong>）</li><li>让一台主机上运行的多个容器使用主机的网络namespace，在主机的网络里通信。</li><li>多个容器依旧独立，似乎每个容器都拥有着自己的独立网卡，从软件层面设立一个虚拟的网桥（bridge），让多个容器通过该网桥交互数据。</li></ul></li><li><p>container被关闭之后，数据还在吗？</p><p> container被关闭之后，里面的数据是否持久化，<strong>一般取决于启动时有没有挂载（映射）外部目录。</strong>如果在run container的时候，指定了container里某个目录<code>/xxx/yyy/zzz</code>映射成某个外部目录<code>/aaa/bbb/ccc</code>的话，当container被关闭后，外部目录里会存有所有数据。</p></li><li><p>常用的Docker Client命令</p><ul><li><code>docker pull [&lt;repo_name&gt;]/&lt;image_name&gt;:[&lt;tag_name&gt;]</code>，从远程仓库拉一个image到本地，默认仓库是Docker Hub，国内访问速度可能会比较慢。</li><li><code>docker run [-Options] &lt;image_name&gt;:[&lt;tag_name&gt;]</code>，把一个image运行起来成为container，可选加非常多的参数。</li><li><code>docker images</code>，用来查看Docker Engine中管理着的所有images。</li><li><code>docker ps [-Options]</code>，用来查看Docker Engine中管理着的所有container。</li><li><code>docker kill &lt;container_name/container_id&gt;</code>，用来关闭某个正在运行的container，该container变成stop状态。</li><li><code>docker rm &lt;container_name&gt;</code>，直接删除某个container。</li><li><code>docker rmi &lt;image_name&gt;</code>，直接删除某个image。</li><li><p><code>docker exec [-Options] &lt;container_name&gt; &lt;command&gt;</code>，在某个正在运行的container里执行一条command。</p><p>当然除了上面这些，还有很多Docker Client的命令，这里就不一一展开，毕竟不是专门介绍Docker的教程。详情可参考<a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener">《Docker Client官方文档》</a>。</p></li></ul></li></ol><h2 id="部署MySQL"><a href="#部署MySQL" class="headerlink" title="部署MySQL"></a>部署MySQL</h2><p>数据库是整个web项目的核心，所以我们先来用Docker部署<code>MySQL</code>。</p><p>根据 <a href="https://hub.docker.com/_/mysql?tab=description" target="_blank" rel="noopener">MySQL官方镜像</a> 里给的教程，直接一把梭，只用一条语句就可以把<code>MySQL</code>运行起来了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure><p>对应我们的<code>MySQL</code>版本（5.7），命令应该是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=自定义的root密码 -d mysql:5.7</span><br></pre></td></tr></table></figure><p><strong>Note：本教程在数据库中默认使用root用户。</strong></p><p><strong>然而事情并没有这么简单，除了简单地把<code>MySQL</code>的container运行起来，我们还要实现：</strong></p><ol><li><strong>在container启动时，假如数据库和表都不存在，先初始化创建我们之后要用的数据库和表。</strong></li><li><strong>将container内的<code>MySQL</code>数据目录映射到一个外部目录，以实现数据持久化，确保不管启停多少次数据依然存在。</strong></li></ol><p>第一步，在任意位置新建目录<code>image-mysql</code>，在目录下新建<code>db.sql</code>文件，把create database和create table的命令写到<code>db.sql</code>里：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// db.sql</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">`photo_gallery`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="string">`photo_gallery`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">`auth`</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">user_name <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">unique</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">email <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">created_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updated_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span></span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">`bucket`</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">auth_id <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">state tinyint(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line"><span class="keyword">size</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">description <span class="built_in">text</span>,</span><br><span class="line">created_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updated_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> UC_bucket <span class="keyword">UNIQUE</span>(auth_id, <span class="keyword">name</span>),</span><br><span class="line"><span class="keyword">INDEX</span> idx_aid_name (auth_id, <span class="keyword">name</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">`photo`</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">bucket_id <span class="built_in">int</span>,</span><br><span class="line">auth_id <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">tag <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">url</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">description <span class="built_in">text</span>,</span><br><span class="line">state tinyint(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line">created_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updated_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">constraint</span> UC_photo <span class="keyword">UNIQUE</span>(bucket_id, <span class="keyword">name</span>),</span><br><span class="line"><span class="keyword">INDEX</span> idx_bid_name (bucket_id, <span class="keyword">name</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>第二步，在<code>image-mysql</code>目录下新建<code>Dockerfile</code>，继承自官方的<code>MySQL:5.7</code>镜像，制作自定义镜像。把上面的<code>db.sql</code>放到镜像里的<code>MySQL</code>的初始化目录下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Dockerfile</span><br><span class="line">FROM mysql:5.7</span><br><span class="line"></span><br><span class="line">COPY db.sql /docker-entrypoint-initdb.d/</span><br></pre></td></tr></table></figure><p>第三步，在<code>image-mysql</code>目录下，基于上面的<code>Dockerfile</code>，构建出自定义镜像。镜像名为<code>my-mysql</code>，版本标签为<code>v1.0</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t my-mysql:v1.0 .</span><br></pre></td></tr></table></figure><p><strong>Note：命令最后有个<code>.</code>，表示基于当前目录下的所有文件（<code>Dockerfile</code>、<code>db.sql</code>）。</strong></p><p>第四步，用<code>docker images</code>查看镜像列表，看看是否制作成功。</p><p>第五步，基于<code>my-mysql:v1.0</code>镜像启动container，为container取名为mysql，并指定映射某个外部数据目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --name mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=自定义密码 \</span><br><span class="line">    -d \</span><br><span class="line">    -v 外部数据目录:/var/lib/mysql \</span><br><span class="line">    my-mysql:v1.0</span><br></pre></td></tr></table></figure><blockquote><p>参数说明：</p><p>–name xxx：给container起名叫xxx，可以是任意自定义的名字</p><p>-e xxx=yyy：给container设定环境变量xxx，值为yyy</p><p>-d：后台运行，不要卡死在前台显示</p><p>-v xxx:yyy：把container里的yyy目录映射到本机的xxx目录</p></blockquote><p>第六步，执行<code>docker ps</code>看看container是否成功运行。</p><h2 id="部署Redis"><a href="#部署Redis" class="headerlink" title="部署Redis"></a>部署Redis</h2><p>部署好了<code>MySQL</code>，对于<code>Redis</code>而言其实是非常类似的。由于不需要在<code>Redis</code>里初始化什么数据库和表，所以我们无需自制Dockerfile，直接用官方现成的镜像即可，本教程使用<code>4.0-alpine</code>版本。</p><p>类似地，我们执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name redis -d -v 外部数据目录:/data redis:4.0-alpine</span><br></pre></td></tr></table></figure><p><strong>Note：<code>/data</code>就是该container内部的数据目录。不同的应用，不同的container对应的数据目录就不一样，启动前要先搞清楚。</strong></p><p>另外，使用alpine版本是因为该镜像体积小，去除了很多我们不需要的工具和库，方便使用。读者也可自由选择合适的镜像版本。</p><h2 id="部署Elasticsearch"><a href="#部署Elasticsearch" class="headerlink" title="部署Elasticsearch"></a>部署Elasticsearch</h2><p>接下来可以部署<code>Elasticsearch</code>了，由于写本教程时Elasticsearch 6.6.1还未有alpine版本，所以直接使用普通的<code>6.6.1</code>版本，Elasticsearch的端口使用默认端口：<code>9200</code>。</p><p>直接执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --name es \</span><br><span class="line">    -d \</span><br><span class="line">    -v 外部数据目录:/usr/share/elasticsearch/data \</span><br><span class="line">    elasticsearch:6.6.1</span><br></pre></td></tr></table></figure><p>同理，也是将其数据目录映射到外部目录，以实现持久化。</p><h2 id="部署gin项目"><a href="#部署gin项目" class="headerlink" title="部署gin项目"></a>部署gin项目</h2><p>因为之前一直是在本地开发，所以很多配置项都直接hard code到配置文件里，真正部署的时候不能这么做。所以先把本项目的配置文件<code>gin-photo-storage/conf/server.conf</code>里hard code的配置项改掉，<strong>改成变量的形式</strong>。</p><p>第一步，修改<code>server.conf</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;SERVER_PORT&quot;: &quot;&lt;SERVER_PORT&gt;&quot;,</span><br><span class="line">    ......</span><br><span class="line">    &quot;DB_HOST&quot;: &quot;&lt;DB_HOST&gt;&quot;,</span><br><span class="line">    ......</span><br><span class="line">    &quot;REDIS_HOST&quot;: &quot;&lt;REDIS_HOST&gt;&quot;,</span><br><span class="line">    ......</span><br><span class="line">    &quot;ES_HOST&quot;: &quot;&lt;ES_HOST&gt;&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，回到项目根目录<code>gin-photo-storage/</code>，为项目编写一个启动脚本。在项目根目录下新建文件<code>bootstrap.sh</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 当本脚本被执行时</span><br><span class="line"><span class="meta">#</span> 用sed命令将server.conf里的配置项替换成环境变量的值</span><br><span class="line">sed -i "s/&lt;SERVER_PORT&gt;/$SERVER_PORT/g" conf/server.conf</span><br><span class="line">sed -i "s/&lt;DB_HOST&gt;/$DB_HOST/g" conf/server.conf</span><br><span class="line">sed -i "s/&lt;REDIS_HOST&gt;/$REDIS_HOST/g" conf/server.conf</span><br><span class="line">sed -i "s/&lt;ES_HOST&gt;/$ES_HOST/g" conf/server.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 把传进来的参数当作命令执行，并用它替换掉当前进程</span><br><span class="line">exec "$@"</span><br></pre></td></tr></table></figure><p>第三步，为项目生成依赖管理的文件。由于我的Golang版本是1.11，所以可以使用go module来管理第三方package。在项目根目录<code>gin-photo-storage/</code>下，生成一个<code>go.mod</code>文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go mod init gin-photo-storage</span><br></pre></td></tr></table></figure><p>目录下会自动生成一个<code>go.mod</code>文件。<strong>（建议Golang版本较低的读者也升级到 &gt;= 1.11的版本，使用go module管理第三方package）</strong></p><p>第四步，开始编写项目的Dockerfile，用来制作项目的image。在根目录<code>gin-photo-storage/</code>下新建<code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM golang:latest</span><br><span class="line"></span><br><span class="line">WORKDIR /web/gin-photo-storage  # 设定container内的工作目录</span><br><span class="line"></span><br><span class="line">COPY . .    # 把当前目录下所有文件copy到container内的工作目录</span><br><span class="line"></span><br><span class="line">RUN go build    # 在container内编译，生成go-photo-storage可执行程序</span><br><span class="line"></span><br><span class="line">CMD [&quot;./gin-photo-storage&quot;]     # 把./gin-photo-storage当作参数传入bootstrap.sh</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./bootstrap.sh&quot;]   # 执行bootstrap.sh脚本</span><br></pre></td></tr></table></figure><p>第五步，有了<code>Dockerfile</code>，可以制作自定义的image了，在项目根目录<code>gin-photo-storage/</code>下执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t my-web:v1.0 .</span><br></pre></td></tr></table></figure><p><strong>Note：命令最后有个<code>.</code>，表示基于当前目录下的所有文件（<code>Dockerfile</code>、<code>db.sql</code>）。</strong></p><p>第六步，基于刚刚生成的image，启动container：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run </span><br><span class="line">    --name gin \ </span><br><span class="line">    -d \</span><br><span class="line">    --link mysql \</span><br><span class="line">    --link es \</span><br><span class="line">    --link redis \</span><br><span class="line">    -e DB_HOST=&quot;mysql&quot; \</span><br><span class="line">    -e REDIS_HOST=&quot;redis&quot; \</span><br><span class="line">    -e ES_HOST=&quot;es&quot; \</span><br><span class="line">    -e SERVER_PORT=&quot;9088&quot; \</span><br><span class="line">    my-web:v1.0</span><br></pre></td></tr></table></figure><p><strong>Note：SERVER_PORT也可以不用<code>9088</code>，可使用任意空闲端口。</strong></p><blockquote><p>参数说明：</p><p>–name xxx：给container起名叫xxx，可以是任意自定义的名字</p><p>-e xxx=yyy：给container设定环境变量xxx，值为yyy</p><p>-d：后台运行，不要卡死在前台显示</p><p>–link xxx：把当前container链接到xxx container的网络环境中，也就是说对于当前container而言，xxx container的hostname就是xxx，直接ping xxx可测试连通性。</p></blockquote><h2 id="部署nginx"><a href="#部署nginx" class="headerlink" title="部署nginx"></a>部署nginx</h2><p>当我们成功跑起<code>MySQL</code>、<code>Redis</code>、<code>Elasticsearch</code>、<code>gin项目</code>之后，其实必要的服务已经全部启动了。但是由于上一篇教程提到了<code>nginx</code>，而且<code>nginx</code>在实际项目中还是非常常用的，所以我们最后再部署一个<code>nginx</code>，为项目提供反向代理。</p><p>第一步，在本机上任意目录下，新建目录<code>image-nginx</code>，并把上一篇教程 <a href="https://marcoma.xyz/2019/03/21/gin-tutorial-9/" target="_blank" rel="noopener">《[Gin教程-9]https与nginx部署》</a> 中我们生成的秘钥和证书：<code>server.key</code>和<code>server.crt</code>复制到<code>image-nginx</code>目录下。</p><p>第二步，在<code>image-nginx</code>目录下新建启动脚本<code>bootstrap.sh</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/nginx/conf.d/my.conf &lt;&lt; EOF</span><br><span class="line">events &#123;</span><br><span class="line">     worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  my-web;</span><br><span class="line">    </span><br><span class="line">        ssl_certificate      /server.crt;</span><br><span class="line">        ssl_certificate_key  /server.key;</span><br><span class="line">    </span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line">    </span><br><span class="line">    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">    </span><br><span class="line">        location / &#123;</span><br><span class="line">    proxy_pass https://$&#123;APP_HOST&#125;:$&#123;APP_PORT&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">exec "$@"</span><br></pre></td></tr></table></figure><p>上述脚本就是把一段<code>nginx</code>配置写到container里的<code>/etc/nginx/conf.d/my.conf</code>，然后执行传入的参数（一条启动<code>nginx</code>的命令）。</p><p>第三步，在<code>image-nginx</code>目录下新建<code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.14-alpine  # 使用alpine镜像，节省空间</span><br><span class="line"></span><br><span class="line">COPY server.crt server.key bootstrap.sh /   # 将文件copy到container内的根目录</span><br><span class="line"></span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-c&quot;, &quot;/etc/nginx/conf.d/my.conf&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./bootstrap.sh&quot;]   # 启动时执行bootstrap脚本</span><br></pre></td></tr></table></figure><p>第四步，基于上述<code>Dockerfile</code>，在<code>image-nginx</code>目录下执行命令构建自定义image：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t my-nginx:v1.0</span><br></pre></td></tr></table></figure><p>第五步，基于刚刚构建的image，启动为container：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --name nginx \</span><br><span class="line">    -d \</span><br><span class="line">    --link gin \</span><br><span class="line">    -p 9999:443 \</span><br><span class="line">    -e APP_HOST=&quot;gin&quot; \</span><br><span class="line">    -e APP_PORT=&quot;9088&quot; \</span><br><span class="line">    my-nginx:v1.0</span><br></pre></td></tr></table></figure><p><strong>Note：APP_PORT要和上面启动gin container时的SERVER_PORT一样，才能成功把请求转发到gin服务器上。至于-p 9999:443中的9999，则可以随便选择任意可用端口代替。</strong></p><blockquote><p>参数说明：</p><p>-p xxx:yyy：把container内的yyy端口映射到宿主机的xxx端口，意味着访问宿主机的xxx端口即可访问到container内的yyy端口。</p></blockquote><h2 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h2><p>当我们把上述所有container成功启动后，用<code>docker ps</code>查看正在运行的container：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-docker-ps.png" alt=""></p><p>然后我们用<code>Postman</code>工具测试一下接口。因为上面我们已经把nginx container的443端口映射到宿主机的9999端口，所以访问<code>https://localhost:9999/api/v1/......</code>应该就可以成功调用我们的gin API。</p><p>直接试试用户注册接口<code>AddAuth()</code>：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-docker-test.png" alt=""></p><p>其他API就不在文中一一测试了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Docker container之间看起来非常独立，一个container似乎是一个完全独立的操作系统，不受别人干预。但是多个container确实是运行在同一台主机上的，那这种独立性是怎么实现的呢？它和另外一种方式——虚拟机相比，有什么异同呢？</p><ul><li>关键词：LXC、Linux namespace、Linux cgroups</li></ul></li><li><p>启动container后，我们可以在container里随意新建、删除、修改文件。当把该container关闭之后，用image再重新启动一个container，为什么所有文件和数据都还能保持没被修改过的状态？</p><ul><li>关键词：分层构建、联合挂载</li></ul></li><li><p>本教程中Elasticsearch使用了默认的9200端口，假如我们想改用自定义端口，但是该镜像没有提供启动参数，我们可以怎么改呢？</p><ul><li>关键词：自定义Dockerfile、Entrypoint、entrypoint.sh脚本</li></ul></li><li><p>对于<code>MySQL</code>、<code>gin项目</code>、<code>nginx</code>的镜像，我们都是继承某个base image，然后自定义的。所以制作出来的镜像都存在了本地，别人不能直接pull，有没有办法发布我们自定义的镜像让别人也能使用呢？</p><ul><li>关键词：registry、私有registry、CNCF harbor</li></ul></li><li><p>本教程里启动了5个container：<code>MySQL</code>、<code>Redis</code>、<code>Elasticsearch</code>、<code>gin项目</code>、<code>nginx</code>。对于每一个container，我们都是手动启停的。当container数量剧增，这样手动操作还是很麻烦。有没有办法写好一个启停的脚本或者流程，让系统自动启停？</p><ul><li>关键词：容器编排、docker compose、kubernetes</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/03/22，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-9]https与nginx部署</title>
    <link href="http://yoursite.com/2019/03/21/gin-tutorial-9/"/>
    <id>http://yoursite.com/2019/03/21/gin-tutorial-9/</id>
    <published>2019-03-22T05:00:00.000Z</published>
    <updated>2019-03-22T05:35:01.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/03/21，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第九篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>截至上一篇教程 <a href="https://marcoma.xyz/2019/03/19/gin-tutorial-8/" target="_blank" rel="noopener">《[Gin教程-8]接入swagger》</a>，从代码的层面而言，整个项目已经完成了。但是写完了代码，写完了测试用例，通过了测试，即使连文档也全部完成了也不代表整个项目的结束。</p><p><strong>完成了设计、编码、文档编写后，接下来自然就是项目的部署。</strong></p><p>在整个开发过程中，服务端通信我们默认是走http协议。但随着https的流行，且https本身在安全性上有优势，新项目应优先使用https协议。另外，在前面的教程中，我们写完API代码，都是直接运行服务端程序，用<code>Postman</code>等工具直接访问服务端程序进行测试。这样“裸连”API，在单机部署或者访问量较小的情况下没什么问题，但当访问量剧增，单机部署撑不住而必须要多机部署时，“裸连”API就不太合适了。</p><p>所以，本篇以及接下来的最后一篇教程将带大家思考和讨论部署方面的问题。</p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>上面提到，当访问量很大从而需要多机部署时，客户端是不知道应该连哪一台后端服务器的（不可能提前把所有服务器地址hard code到客户端中）。所以“裸连”API是不可行的，如下图：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-nginx.png" alt=""></p><p>所以，我们要在后端服务器和客户端之间多加一层组件，当后端服务器多于1台时，该组件可以把用户请求分发到多台后端服务器中的一台。甚至该组件还可以监测每一台后端服务器的访问压力，每次尽可能把请求分发到压力最小的服务器上（所谓的负载均衡）。如下图：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-nginx-2.png" alt=""></p><p>只要中间的分发组件的地址是固定的，客户端只需要知道分发组件的地址，把请求发给该组件，该组件会自动地把请求分发给某台后端服务器，调用API，继而原路返回给客户端。</p><p><strong>这也就是为什么我们要使用nginx。</strong>（关于nginx的入门可参考 <a href="http://nginx.org/en/docs/beginners_guide.html" target="_blank" rel="noopener">《NGINX Beginner’s Guide》</a>）</p><p><strong>Note：本教程不涉及nginx的安装，请自行查阅安装教程，并确保nginx在开发主机上成功安装。</strong></p><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>接下来看看如何把服务端协议从http改成https。</p><p>https主打安全，核心是加密（其实是非对称加密）。既然要实现非对称加密，那肯定得引入<strong>公钥、私钥、证书</strong>等概念。所以先来看看怎么生成我们所需的秘钥和证书。</p><p>（关于https的相关知识，本人推荐一个通俗易懂的漫画讲解：<a href="https://juejin.im/post/5c889918e51d45346459994d" target="_blank" rel="noopener">《漫画：什么是 HTTPS 协议？》</a>）</p><p><strong>Note：执行以下命令前，请先确保成功安装了<code>openssl</code>。</strong></p><hr><p>第一步，任意位置新建目录<code>https</code>，在该目录下创建root key：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl genrsa -des3 -out rootCA.key 2048</span><br></pre></td></tr></table></figure><p><strong>Note：请记住生成root key时输入的密码，下面几步需要输入！</strong></p><p>第二步，基于root key生成根SSL证书，有效期设为一年（365天）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 365 -out rootCA.pem</span><br></pre></td></tr></table></figure><p>过程中会提示输入以下信息（可根据自己的实际信息填写）：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-https-ssl.png" alt=""></p><p>第三步，在<code>https</code>目录下新建一个<code>v3.ext</code>文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage=digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName=@alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = localhost</span><br></pre></td></tr></table></figure><p>第四步，在<code>https</code>目录下创建密钥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key</span><br></pre></td></tr></table></figure><p>过程中会提示输入以下信息（可根据自己的实际信息填写）：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-https-ssl-2.png" alt=""></p><p>第五步，在<code>https</code>目录下生成证书文件，有效期设为一年（365天）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 365 -sha256 -extfile v3.ext</span><br></pre></td></tr></table></figure><p>发现在<code>https</code>目录下已成功生成<code>server.key</code>和<code>server.crt</code>。</p><h2 id="整合测试"><a href="#整合测试" class="headerlink" title="整合测试"></a>整合测试</h2><p><strong>Note：请先确保<code>MySQL</code>、<code>Redis</code>、<code>Elasticsearch</code>等组件已正常运行中。</strong></p><hr><p>第一步，把之前生成的<code>server.key</code>和<code>server.crt</code>复制到<code>gin-photo-storage/conf</code>目录下，然后修改服务端程序<code>main.go</code>的代码：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// 注释掉server.ListenAndServe()</span></span><br><span class="line">server.ListenAndServeTLS(<span class="string">"conf/server.crt"</span>, <span class="string">"conf/server.key"</span>)</span><br></pre></td></tr></table></figure><p>第二步，启动服务端程序。</p><p>第三步，停止nginx服务，修改nginx配置文件。先看看当前使用的是哪个配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p>该命令会打印出nginx所使用的配置文件路径。</p><p>第四步，修改该nginx配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # ...... 保留原默认配置即可</span><br><span class="line">    </span><br><span class="line">    # 配置upstream以实现负载均衡</span><br><span class="line">    # 当部署了多台后端服务器时，这里可填写多个地址，实现负载均衡</span><br><span class="line">    upstream api_service &#123;</span><br><span class="line">        server localhost:9088; # 服务端监听了9088端口，所以这里用9088</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 配置server</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;   # nginx监听443端口</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      /....../server.crt; # 填写server.crt的绝对路径</span><br><span class="line">        ssl_certificate_key  /....../server.key; # 填写server.key的绝对路径</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">proxy_pass https://api_service/; # 转发到api_service处，也就是上面定义的upstream</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：我的配置文件<code>server.conf</code>里用的是<code>9088</code>端口，读者可根据自己的设置修改。</strong></p><p><strong>Note：如果我们的后端服务器只有一台，自然就不存在什么“负载均衡”了，这种情况下可以不配置upstream，而是直接把后端服务的地址填到<code>proxy_pass</code>中：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # ......</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        </span><br><span class="line">        # ......</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass https://localhost:9088/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步，保存配置文件后，启动nginx。</p><p>第六步，用<code>Postman</code>工具测试：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-nginx-test.png" alt=""></p><p>可以看到，我们访问的是443端口的<code>/api/v1/auth/check</code>，而不再是服务端监听的9088端口，成功得到API调用后的返回结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>nginx除了用作反向代理（把客户端请求反向转发给服务端），还能用来做什么？</p><ul><li>关键词：静态服务器、拦截器、缓存、Lua</li></ul></li><li><p>当我们在nginx配置里的upstream里设置了多个后端服务的地址，相当于让nginx实现负载均衡，让它把用户请求尽量均衡地分发给各台服务器。那么nginx的负载均衡有哪些模式呢？</p><ul><li>关键词：nginx负载均衡模式、负载均衡算法</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/03/21，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-8]接入swagger</title>
    <link href="http://yoursite.com/2019/03/19/gin-tutorial-8/"/>
    <id>http://yoursite.com/2019/03/19/gin-tutorial-8/</id>
    <published>2019-03-20T04:00:00.000Z</published>
    <updated>2019-03-20T04:20:22.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/03/19，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第八篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在上一篇教程 <a href="https://marcoma.xyz/2019/03/17/gin-tutorial-7/" target="_blank" rel="noopener">《[Gin教程-7]用zap替代自带日志库》</a>中我们用<code>Uber</code>开源的<code>zap</code>日志库替代了Golang自带的默认日志库。至此，“编码”工作真正基本完成。</p><p>可是新的问题又来了，在整个编码过程中我们都是自己一个人开发，自己一个人测试，所有的接口参数、调用方式都是自定义的。但假如在一个团队中参与开发，有时候你要依赖于上游的接口，有时候下游要依赖于你写的接口，难道参数和调用方式都要“口口相传”吗？</p><p>很明显，我们在编码完成之后，需要用文档的方式记录下所有的API规范，方便他人查阅和使用。但是开发需求很多，编码工作都做不完，哪里有时间写详细的使用文档呢？</p><p>基于这个问题，我们迫切需要一个能够帮我们快速生成文档，且其文档易读性较高的工具——<code>Swagger</code>。</p><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p><a href="https://swagger.io/" target="_blank" rel="noopener">Swagger</a> 的口号是The Best APIs Built with Swagger Tools。它完美地支持<code>OpenAPI</code>的语法，利用<code>OpenAPI</code>的语法，我们可以编写JSON或者YAML文件，在文件中注明各API的调用方式、参数、返回值、状态码等，最后使用<code>Swagger</code>生成可读性高的API文档。</p><p>一般来说，有两种使用<code>Swagger</code>的套路：</p><ol><li>前期API设计就使用<code>Swagger</code>，先把接口名、Resource、参数、返回值等全部按照<code>Swagger</code>支持的语法写好，然后利用<code>Swagger Hub</code>生成测试接口，团队review后才进行真正的编码开发。</li><li>前期API设计“随心所欲”，全靠开发者和下游调用团队协商，没有正式规范和文档。等到编码完成&amp;简单的测试完成，才用<code>Swagger</code>生成API文档。</li></ol><p>可以看出，套路1比较规范，先设计，再按照文档里的约定开发，不太容易出问题，沟通应该也会很顺畅，但是开发周期估计比较长，不适用于赶工上线。套路2比较“野路子”，全靠“口口相传”，先编码保证了能够快速完成需求，但是在联调或者测试过程中可能会出很多bug。</p><p>但是由于本教程一开始没有先进行总体的API设计，所以只能采用套路2，等到编码完成了再来生成API文档。<strong>建议大家在实际生产中，不是特别紧急的需求，尽可能地先用<code>Swagger</code>设计好API，记录成文档，再进行编码。</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p>Golang &lt;= 1.10且项目位于<code>$GOPATH/src/</code>下的，可直接</p><ul><li><code>go get -u github.com/swaggo/swag/cmd/swag</code></li><li><code>go get -u github.com/swaggo/gin-swagger</code></li><li><code>go get -u github.com/swaggo/gin-swagger/swaggerFiles</code></li></ul></li><li>否则可用go mod来安装</li></ul><p>安装完后可执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swag -version</span><br></pre></td></tr></table></figure><p>如果安装成功的话会显示该工具的版本号。</p><p>然后我们以<code>AddAuth()</code>和<code>GetBucketByID()</code>作为示例说明如何生成<code>Swagger</code>文档：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary Add a new auth.</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @Accept mpfd</span></span><br><span class="line"><span class="comment">// @Param user_name formData string true "User Name" minlength(6) maxlength(16)</span></span><br><span class="line"><span class="comment">// @Param password formData string true "Password" minlength(6) maxlength(16)</span></span><br><span class="line"><span class="comment">// @Param email formData string true "Email" maxlength(128)</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;string&#125; json "&#123;"code":"","data":&#123;&#125;,"msg":"ok"&#125;"</span></span><br><span class="line"><span class="comment">// @Router /api/v1/auth/add [post]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAuth</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">userName := context.PostForm(<span class="string">"user_name"</span>)</span><br><span class="line">password := context.PostForm(<span class="string">"password"</span>)</span><br><span class="line">email := context.PostForm(<span class="string">"email"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up param validation</span></span><br><span class="line">validCheck := validation.Validation&#123;&#125;</span><br><span class="line">validCheck.Required(userName, <span class="string">"user_name"</span>).Message(<span class="string">"Must have user name"</span>)</span><br><span class="line">validCheck.MaxSize(userName, <span class="number">16</span>, <span class="string">"user_name"</span>).Message(<span class="string">"User name length can not exceed 16"</span>)</span><br><span class="line">validCheck.MinSize(userName, <span class="number">6</span>, <span class="string">"user_name"</span>).Message(<span class="string">"User name length is at least 6"</span>)</span><br><span class="line">validCheck.Required(password, <span class="string">"password"</span>).Message(<span class="string">"Must have password"</span>)</span><br><span class="line">validCheck.MaxSize(password, <span class="number">16</span>, <span class="string">"password"</span>).Message(<span class="string">"Password length can not exceed 16"</span>)</span><br><span class="line">validCheck.MinSize(password, <span class="number">6</span>, <span class="string">"password"</span>).Message(<span class="string">"Password length is at least 6"</span>)</span><br><span class="line">validCheck.Required(email, <span class="string">"email"</span>).Message(<span class="string">"Must have email"</span>)</span><br><span class="line">validCheck.MaxSize(email, <span class="number">128</span>, <span class="string">"email"</span>).Message(<span class="string">"Email can not exceed 128 chars"</span>)</span><br><span class="line"></span><br><span class="line">responseCode := constant.INVALID_PARAMS</span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line"><span class="keyword">if</span> err := models.AddAuth(userName, password, email); err == <span class="literal">nil</span> &#123;</span><br><span class="line">responseCode = constant.USER_ADD_SUCCESS</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.USER_ALREADY_EXIST</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line"><span class="comment">//log.Println(err)</span></span><br><span class="line">utils.AppLogger.Info(err.Message, zap.String(<span class="string">"service"</span>, <span class="string">"AddAuth()"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: userName,</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，在<code>AddAuth()</code>方法的上方添加注释，非常类似<code>Java Doc</code>的写法。</p><blockquote><p>参数说明</p><p>@Summary：说明该方法的作用</p><p>@version：方法版本号</p><p>@Accept：<code>mpfd</code>意味着该方法接受的请求参数是以<code>multipart/form data</code>形式传过来的，对应我们代码里的<code>context.PostForm(&quot;......&quot;)</code>从form data里拿请求参数。除了<code>mpfd</code>还有其他取值。</p><p>@Param：定义了具体的请求参数，格式是<code>param_name param_type data_type is_required description</code></p><p>@Success：定义了请求成功执行后的返回值</p><p>@Router：定义了该方法的调用路径，以及调用类型[get、post、put、delete……]</p></blockquote><p>再来看看<code>GetBucketByID()</code>方法：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Summary Get bucket by bucket id.</span></span><br><span class="line"><span class="comment">// @version 1.0</span></span><br><span class="line"><span class="comment">// @Param bucket_id query string true "Bucket ID"</span></span><br><span class="line"><span class="comment">// @Success 200 &#123;string&#125; json "&#123;"code":"","data":&#123;&#125;,"msg":"ok"&#125;"</span></span><br><span class="line"><span class="comment">// @Router /api/v1/bucket/get_by_id [get]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBucketByID</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">responseCode := constant.INVALID_PARAMS</span><br><span class="line">bucketID, bucketErr := strconv.Atoi(context.Query(<span class="string">"bucket_id"</span>))</span><br><span class="line"><span class="keyword">if</span> bucketErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//log.Println(bucketErr)</span></span><br><span class="line">utils.AppLogger.Info(bucketErr.Error(), zap.String(<span class="string">"service"</span>, <span class="string">"GetBucketByID()"</span>))</span><br><span class="line">context.AbortWithStatusJSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validCheck := validation.Validation&#123;&#125;</span><br><span class="line">validCheck.Required(bucketID, <span class="string">"bucket_id"</span>).Message(<span class="string">"Must have bucket id"</span>)</span><br><span class="line">validCheck.Min(bucketID, <span class="number">1</span>, <span class="string">"bucket_id"</span>).Message(<span class="string">"Bucket id should be positive"</span>)</span><br><span class="line"></span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line"><span class="keyword">if</span> bucket, err := models.GetBucketByID(<span class="keyword">uint</span>(bucketID)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == models.NoSuchBucketError &#123;</span><br><span class="line">responseCode = constant.BUCKET_NOT_EXIST</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.INTERNAL_SERVER_ERROR</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.BUCKET_GET_SUCCESS</span><br><span class="line">data[<span class="string">"bucket"</span>] = bucket</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line"><span class="comment">//log.Println(err.Message)</span></span><br><span class="line">utils.AppLogger.Info(err.Message, zap.String(<span class="string">"service"</span>, <span class="string">"GetBucketByID()"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: data,</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，注释都是差不多的，差别只在于这个API需要用<code>get</code>调用。</p><p>参照上述的示例，读者可自行为其他API对应的方法添加<code>Swagger</code>注释。</p><p>接下来，在代码里添加了注释，要怎么根据注释生成文档呢？于是，我们就得在项目根目录<code>gin-photo-storage</code>下执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swag init</span><br></pre></td></tr></table></figure><p>通过上述命令初始化<code>Swagger</code>文档，初始化成功的话可在<code>gin-photo-storage</code>目录下看到一个新的目录：<code>docs</code>，里面包含了工具自动生成的文档数据和Golang代码。</p><p>为了让用户能够通过一个url来访问<code>Swagger</code>文档，我们要为其添加一个Router。修改<code>gin-photo-storage/routers/router.go</code>：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Init router, adding paths to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">Router = gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">Router.GET(<span class="string">"/swagger/*any"</span>, ginSwagger.WrapHandler(swaggerFiles.Handler))</span><br><span class="line"></span><br><span class="line"><span class="comment">// api group for v1</span></span><br><span class="line">v1Group := Router.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过访问上述添加的路径，在浏览器里即可访问<code>Swagger</code>下的所有文档。</p><p><strong>Note：</strong></p><ul><li><strong>如果想改<code>Swagger</code>文档内容，在改动方法上面的注释后，还要重新<code>swag init</code>一下，以基于新的注释生成新的文档。</strong></li><li><strong>除了上述注释里的参数，<code>Swagger</code>还支持很多参数，具体请查阅：<a href="https://swaggo.github.io/swaggo.io/declarative_comments_format/general_api_info.html" target="_blank" rel="noopener">swaggo gitbook</a>。</strong></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行服务端程序，然后通过浏览器访问<code>localhost:{监听的端口号}/swagger/index.html</code>，即可看到<code>Swagger</code>文档界面：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-swagger-test-1.png" alt=""></p><p>接下来我们测试一下<code>AddAuth()</code>接口，点击<strong>Try it out</strong>：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-swagger-test-2.png" alt=""></p><p>填入参数，点击<strong>Execute</strong>：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-swagger-test-3.png" alt=""></p><p>得到执行结果：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-swagger-test-4.png" alt=""></p><p>从上述截图中可以看到，<code>Swagger</code>文档界面里不仅有API的描述和参数说明，还能够让使用者对接口进行简单测试，一举多得。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>在系列教程里，我们是先写代码，再根据代码生成<code>Swagger</code>文档，所以才需要用<code>gin-swagger</code>这个工具库。如果想在编码前先设计好API文档，那应该怎么做呢，有固定的语法和文件格式吗？</p><ul><li>关键词：Swagger Hub、OpenAPI</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/03/19，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-7]用zap替代自带日志库</title>
    <link href="http://yoursite.com/2019/03/17/gin-tutorial-7/"/>
    <id>http://yoursite.com/2019/03/17/gin-tutorial-7/</id>
    <published>2019-03-18T06:00:00.000Z</published>
    <updated>2019-03-18T06:28:31.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/03/17，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第七篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在上一篇教程 <a href="https://marcoma.xyz/2019/03/10/gin-tutorial-6/" target="_blank" rel="noopener">《[Gin教程-6]elasticsearch实现搜索需求》</a>中我们已经把最后一个“业务逻辑”实现完了。按理说从代码的角度没有什么好写了，但是有一个细节可能部分读者会注意到，那就是日志模块——<code>log</code>的实现。</p><p>在之前的代码里，我们在很多地方写过日志：在操作<code>MySQL</code>、<code>Redis</code>、<code>Elasticsearch</code>的时候要打日志，在API里面处理请求参数出错要打日志，在中间件执行时要打日志……</p><p>回看代码，我们用的日志模块都是Golang自带的<code>log</code>。通过<code>log</code>模块输出的日志都是“raw log”，即一个简单的字符串，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-03-18 02:12:03,822 INFO xx/yy/zz.go hello world</span><br></pre></td></tr></table></figure><p>这样的日志是最“朴素”的，有不少缺点。首先它对人而言可读性不高，全靠空格分隔，当msg里有大量空格分隔的单词时很难阅读。另外，日志里只有“值”，并没有字段名，假如一条日志里有50个字段，那读着读着就不知道自己读到哪个字段了。再者，如果要对这种“raw log”进行数据分析，写解析程序的时候也比较麻烦，相当于要手动操作字符串：切分、trim、用index取字段……</p><p>既然“raw log”有这么多不便之处，我们应该使用更友好、更高效的日志格式，最广泛使用的就是<code>JSON</code>。我们可以把上面的那条“raw log”改成成JSON格式，类似于：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;time&quot;: &quot;2019-03-18 02:12:03,822&quot;,</span><br><span class="line">    &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">    &quot;caller&quot;: &quot;xx/yy/zz.go&quot;,</span><br><span class="line">    &quot;msg&quot;: &quot;hello world&quot;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每一条日志都能输出为这样的<code>JSON</code>串，那既提高了可读性，又方便后续的日志分析（读取字段时直接按字段名来读，不用手动操作字符串）。</p><p>所以，在本篇教程中我们要引入<code>zap</code>这个第三方日志库，来实现日志的<code>JSON</code>格式化输出。</p><h2 id="zap"><a href="#zap" class="headerlink" title="zap"></a>zap</h2><p><a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">zap</a> 是<code>Uber</code>开源的一个日志库，选择<code>zap</code>的原因有3个：</p><ul><li><code>zap</code>原生支持JSON格式的日志输出</li><li><code>zap</code>的性能在多个第三方日志库中名列前茅（根据其README里声明的benchmark）</li><li><code>zap</code>的API设计比较清晰，对用户友好</li></ul><p>另外，在Github上比较著名的Golang日志库还有：<code>zerolog</code>、<code>logrus</code>等，有兴趣的读者可查阅相关资料，自行对比多个日志库。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先我们需要把对应的package导入到本地</p><ul><li>Golang &lt;= 1.10且项目位于<code>$GOPATH/src/</code>下的，可直接<code>go get -u go.uber.org/zap</code></li><li>Golang &lt;= 1.10且项目位于<code>$GOPATH/src/</code>下的，可直接<code>go get -u gopkg.in/natefinch/lumberjack.v2</code></li><li>否则可用go mod来安装</li></ul><p>首先在<code>utils</code>目录下新建<code>logging.go</code>代码文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— logging.go</span><br><span class="line">|—— middleware</span><br><span class="line">|—— ......</span><br><span class="line">|—— apis</span><br><span class="line">    |—— ......</span><br><span class="line">|—— routers</span><br><span class="line">    |—— ......</span><br><span class="line">|—— main.go</span><br></pre></td></tr></table></figure><p>然后在<code>logging.go</code>里自定义一个zap logger：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"go.uber.org/zap"</span></span><br><span class="line"><span class="string">"go.uber.org/zap/zapcore"</span></span><br><span class="line"><span class="string">"gopkg.in/natefinch/lumberjack.v2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AppLogger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">writer := zapcore.AddSync(&amp;lumberjack.Logger&#123;</span><br><span class="line">Filename:   <span class="string">"logs/app.log"</span>,</span><br><span class="line">MaxSize:    <span class="number">100</span>,</span><br><span class="line">MaxBackups: <span class="number">3</span>,</span><br><span class="line">MaxAge:     <span class="number">1</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">encoderConfig := zapcore.EncoderConfig&#123;</span><br><span class="line">TimeKey:        <span class="string">"time"</span>,</span><br><span class="line">LevelKey:       <span class="string">"level"</span>,</span><br><span class="line">NameKey:        <span class="string">"logger"</span>,</span><br><span class="line">CallerKey:      <span class="string">"caller"</span>,</span><br><span class="line">MessageKey:     <span class="string">"msg"</span>,</span><br><span class="line">StacktraceKey:  <span class="string">"stacktrace"</span>,</span><br><span class="line">LineEnding:     zapcore.DefaultLineEnding,</span><br><span class="line">EncodeLevel:    zapcore.LowercaseLevelEncoder,</span><br><span class="line">EncodeTime:     zapcore.ISO8601TimeEncoder,</span><br><span class="line">EncodeDuration: zapcore.SecondsDurationEncoder,</span><br><span class="line">EncodeCaller:   zapcore.ShortCallerEncoder,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">core := zapcore.NewCore(</span><br><span class="line">zapcore.NewJSONEncoder(encoderConfig),</span><br><span class="line">writer,</span><br><span class="line">zap.InfoLevel,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">caller := zap.AddCaller()</span><br><span class="line">AppLogger = zap.New(core, caller)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong></p><ul><li><strong>为了支持滚动日志（Log Rotation），此处用lumberjack里的logger作为我们的底层logger，因为zap本身不支持滚动日志的特性。</strong></li><li><strong>使用<code>JSONEncoder</code>来输出JSON格式的日志，而非“raw log string”。</strong></li><li><strong>在<code>editorConfig</code>里我们对logger进行设置，设定了一些字段名，还有字段的格式，例如日志level用小写，时间格式用<code>ISO8601</code>等。这些配置项均可自由设置，不是一定要用上述代码的设置。</strong></li></ul><p>实现了自定义的logger后，我们就要把之前代码里的<code>log.Println()</code>全都改成使用自定义logger来打log。例如在<code>AddAuth()</code>中：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAuth</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line">utils.AppLogger.Info(err.Message, zap.String(<span class="string">"service"</span>, <span class="string">"AddAuth()"</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，除了默认的字段外，我们还加了一个<code>service</code>字段，表示这个日志是由哪个API打印出来的。如果读者还有更多需要记录到日志里的字段，也可自行添加。</p><h2 id="Log格式"><a href="#Log格式" class="headerlink" title="Log格式"></a>Log格式</h2><p>当我们把所有需要打日志的地方都用自定义的logger输出后，可以来测试一下日志输出。我们使用<code>Postman</code>调用<code>AddAuth()</code>，故意输入非法的参数，看看日志是否输出JSON格式的错误提醒。</p><p>故意设置<code>user_name</code>参数小于6位，调用<code>AddAuth()</code>：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-zap-test.png" alt=""></p><p>然后在项目根目录下的<code>logs</code>目录里打开<code>app.log</code>，看到因非法调用而打印出来的日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2019-03-17T23:18:11.809-0700&quot;,&quot;caller&quot;:&quot;v1/auth.go:42&quot;,&quot;msg&quot;:&quot;User name length is at least 6&quot;,&quot;service&quot;:&quot;AddAuth()&quot;&#125;</span><br></pre></td></tr></table></figure><p>可复制上述日志到 <a href="https://www.json.cn/" target="_blank" rel="noopener">Json.cn</a> 进行验证：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-zap-json-test.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>程序产生的大量日志可以用于作数据分析，那么流行的日志分析工具有哪些呢？</p><ul><li>关键词：Elasticsearch、Logstash、Kibana</li></ul></li><li><p>如果我们的程序并发度很高，意味着写日志的操作并发度也很高，日志最终是要写到磁盘上的日志文件里的，要怎么设计一个写入性能很高的日志库呢？</p><ul><li>关键词：buffer、异步、fsync</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/03/17，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-6]elasticsearch实现搜索需求</title>
    <link href="http://yoursite.com/2019/03/10/gin-tutorial-6/"/>
    <id>http://yoursite.com/2019/03/10/gin-tutorial-6/</id>
    <published>2019-03-10T23:00:00.000Z</published>
    <updated>2019-03-16T00:56:57.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/03/10，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第六篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在上一篇教程<a href="https://marcoma.xyz/2019/03/07/gin-tutorial-5/" target="_blank" rel="noopener">《[Gin教程-5]中间件与API开发-2》</a>里我们已经开发完基本的API，并实现了Router和Server，成功把服务端程序跑起来了。这时候我们就要审视一下，是否必要的API真的都全部实现了呢？</p><p>其实不然，还记得我们的Photo Model里有<code>Tag</code>和<code>Description</code>两个文本类型的字段。对于文本数据我们肯定会有搜索（模糊搜索）的需求，例如我们可能会给一张旅游的照片加上某年某月某日在某处做了什么的Description文本，当存储的图片越来越多，我们就要通过搜索Description来找出想要的图片。</p><p>面对搜索的需求，其中一种解决方案是利用MySQL作文本搜索，例如<code>select ... from photo where description like &#39;%xxx%&#39;;</code>，但是这样的查询效率确实不高，而且不能实现模糊搜索。<strong>所谓的不能模糊搜索，就是只能精准匹配，不存在分词、理解、transform的过程。</strong></p><p>例如某张照片的Description是“2019年3月10日，我们团队一起在黄山的空地上玩扑克”，过了很久之后用户忘了该图片的具体Description是怎么写的，只模糊地记得“打扑克”，当他搜索“打扑克”，对应的查询语句就是<code>select ...from photo where description like &#39;%打扑克%&#39;;</code>，结果什么都没查出来。</p><p>基于这样的需求和问题，我们不能用MySQL实现搜索功能，应转而使用Elasticsearch。</p><p><strong>Note：本教程不包含Elasticsearch安装和运行的步骤，请自行安装并确保正常运行。</strong></p><h2 id="什么是Elasticsearch"><a href="#什么是Elasticsearch" class="headerlink" title="什么是Elasticsearch"></a>什么是Elasticsearch</h2><p>根据<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">Elastic官方</a>的定义：</p><blockquote><p>Elasticsearch is a distributed, RESTful search and analytics engine capable of solving a growing number of use cases. As the heart of the Elastic Stack, it centrally stores your data so you can discover the expected and uncover the unexpected.</p></blockquote><p>简而言之，Elasticsearch就是一个可以存储数据，并提供搜索和分析接口的搜索引擎（组件）。</p><p>既然Elasticsearch里也可以存储数据，我们就来看看它和MySQL在概念上的相似之处：</p><ul><li>index ≈ table</li><li>document ≈ record</li><li>field ≈ column</li></ul><p>在概念上，MySQL里的一张表类似于Elasticsearch里的一个index，MySQL表里的一行记录类似于Elasticsearch里的一个document，MySQL record里的一个字段类似于Elasticsearch document里的一个字段。</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-es-structure.png" alt=""></p><p>如上图所示，基于存储好的数据，我们可以对它们进行搜索。不同于MySQL的“匹配”，Elasticsearch支持的是真正意义上的“搜索”。它会对你的query进行分词、组合、transform，再去匹配数据里的对应字段的值，不是简单的匹配。</p><p>接下来的教程里将使用<code>Elasticsearch 6.6.1</code>来实现搜索功能。</p><h2 id="实现ES-Utils"><a href="#实现ES-Utils" class="headerlink" title="实现ES Utils"></a>实现ES Utils</h2><ul><li>Golang &lt;= 1.10且项目位于<code>$GOPATH/src/</code>下的，可直接<code>go get -u github.com/elastic/go-elasticsearch</code></li><li>否则可用go mod来安装 </li></ul><p>首先在<code>gin-photo-storage/conf/server.conf</code>里加上ES的配置项，<code>ES_HOST</code>和<code>ES_PORT</code>填入你自己的ES的host和port：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    &quot;ES_HOST&quot;: &quot;......&quot;,</span><br><span class="line">    &quot;ES_PORT&quot;: &quot;......&quot;,</span><br><span class="line">    &quot;ES_PHOTO_INDEX&quot;: &quot;photo&quot;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>gin-photo-storage/constant/constant.go</code>和<code>gin-photo-storage/constant/resp_code.go</code>里加上对应的常量和返回码：</p><p>常量定义：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在constant.go里补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Elasticsearch constants</span></span><br><span class="line">ES_HOST = <span class="string">"ES_HOST"</span></span><br><span class="line">ES_PORT = <span class="string">"ES_PORT"</span></span><br><span class="line">ES_PHOTO_INDEX = <span class="string">"ES_PHOTO_INDEX"</span></span><br><span class="line">SEARCH_BY_TAG= <span class="string">"tags"</span></span><br><span class="line">SEARCH_BY_DESC= <span class="string">"description"</span></span><br></pre></td></tr></table></figure><p>返回码：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在resp_code.go里补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">PHOTO_SEARCH_BY_TAG_SUCCESS = <span class="number">4009</span></span><br><span class="line">PHOTO_SEARCH_BY_DESC_SUCCESS= <span class="number">4010</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    Message[PHOTO_SEARCH_BY_TAG_SUCCESS] = <span class="string">"Photo search by tag success."</span></span><br><span class="line">Message[PHOTO_SEARCH_BY_DESC_SUCCESS] = <span class="string">"Photo search by description success."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在<code>gin-photo-storage/models/</code>下新建<code>es.go</code>代码文件：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/elastic/go-elasticsearch"</span></span><br><span class="line"><span class="string">"github.com/elastic/go-elasticsearch/esapi"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ESClient *elasticsearch.Client</span><br><span class="line"><span class="keyword">var</span> PhotoIndexingError = errors.New(<span class="string">"photo indexing error"</span>)</span><br><span class="line"><span class="keyword">var</span> PhotoSearchError = errors.New(<span class="string">"photo search error"</span>)</span><br><span class="line"><span class="keyword">var</span> PhotoUpdateError = errors.New(<span class="string">"photo update error"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// search request body</span></span><br><span class="line"><span class="keyword">var</span> SearchRequest = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"query": &#123;</span></span><br><span class="line"><span class="string">"bool": &#123;</span></span><br><span class="line"><span class="string">"must": [</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"match": &#123;</span></span><br><span class="line"><span class="string">"%s": "%s"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">"term": &#123;</span></span><br><span class="line"><span class="string">"auth_id": %d</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// update request body</span></span><br><span class="line"><span class="keyword">var</span> AddPhotoUrlRequest = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">"doc": &#123;</span></span><br><span class="line"><span class="string">"url": "%s"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// search type which indicates if we are searching by tag or by description</span></span><br><span class="line"><span class="keyword">type</span> SearchType <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Photo struct used in elasticsearch.</span></span><br><span class="line"><span class="keyword">type</span> PhotoToIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">AuthID<span class="keyword">uint</span><span class="string">`json:"auth_id"`</span></span><br><span class="line">BucketID<span class="keyword">uint</span><span class="string">`json:"bucket_id"`</span></span><br><span class="line">ID <span class="keyword">uint</span><span class="string">`json:"id"`</span></span><br><span class="line">Name <span class="keyword">string</span><span class="string">`json:"name"`</span></span><br><span class="line">Tags []<span class="keyword">string</span><span class="string">`json:"tags"`</span></span><br><span class="line">Url<span class="keyword">string</span><span class="string">`json:"url"`</span></span><br><span class="line">Description <span class="keyword">string</span><span class="string">`json:"description"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init elasticsearch client.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">host := conf.ServerCfg.Get(constant.ES_HOST)</span><br><span class="line">port := conf.ServerCfg.Get(constant.ES_PORT)</span><br><span class="line">esCfg := elasticsearch.Config&#123;</span><br><span class="line">Addresses: []<span class="keyword">string</span>&#123;</span><br><span class="line">fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">ESClient, err = elasticsearch.NewClient(esCfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Index a photo in elasticsearch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexPhoto</span><span class="params">(photo *Photo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the document we want to index</span></span><br><span class="line">photoToIndex := PhotoToIndex&#123;</span><br><span class="line">AuthID: photo.AuthID,</span><br><span class="line">BucketID: photo.BucketID,</span><br><span class="line">ID: photo.ID,</span><br><span class="line">Name: photo.Name,</span><br><span class="line">Tags: strings.Split(photo.Tag, <span class="string">";"</span>),</span><br><span class="line">Url: photo.Url,</span><br><span class="line">Description: photo.Description,</span><br><span class="line">&#125;</span><br><span class="line">body, _ := json.Marshal(&amp;photoToIndex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up index request</span></span><br><span class="line">request := esapi.IndexRequest&#123;</span><br><span class="line">Index: conf.ServerCfg.Get(constant.ES_PHOTO_INDEX),</span><br><span class="line">DocumentID: fmt.Sprintf(<span class="string">"%d"</span>, photoToIndex.ID),</span><br><span class="line">Body: bytes.NewReader(body),</span><br><span class="line">Refresh: <span class="string">"true"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res, err := request.Do(context.Background(), ESClient); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"><span class="keyword">if</span> res.IsError() &#123;</span><br><span class="line">log.Println(<span class="string">"Photo indexing error"</span>)</span><br><span class="line"><span class="keyword">return</span> PhotoIndexingError</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> PhotoIndexingError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the photo url in elasticsearch.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddPhotoUrl</span><span class="params">(photoID <span class="keyword">uint</span>, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">queryBody := fmt.Sprintf(AddPhotoUrlRequest, url)</span><br><span class="line"></span><br><span class="line">res, err := ESClient.Update(</span><br><span class="line">conf.ServerCfg.Get(constant.ES_PHOTO_INDEX),</span><br><span class="line">fmt.Sprintf(<span class="string">"%d"</span>, photoID),</span><br><span class="line">strings.NewReader(queryBody),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> PhotoUpdateError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.IsError() &#123;</span><br><span class="line">log.Println(PhotoUpdateError)</span><br><span class="line"><span class="keyword">return</span> PhotoUpdateError</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">resMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;resMap); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> PhotoUpdateError</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> fmt.Sprintf(<span class="string">"%d"</span>, resMap[<span class="string">"updated"</span>]) != <span class="string">"0"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span><span class="comment">// update success</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> PhotoUpdateError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search photo(s) by the given field</span></span><br><span class="line"><span class="comment">// 1. searchType = SEARCH_BY_TAG, the field is a tag</span></span><br><span class="line"><span class="comment">// 2. searchType = SEARCH_BY_DESC, the field is a description</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchPhoto</span><span class="params">(field <span class="keyword">string</span>, authID <span class="keyword">uint</span>, offset <span class="keyword">int</span>, searchType SearchType)</span> <span class="params">([]PhotoToIndex, error)</span></span> &#123;</span><br><span class="line">queryBody := fmt.Sprintf(SearchRequest, searchType, field, authID)</span><br><span class="line">photos := <span class="built_in">make</span>([]PhotoToIndex, <span class="number">0</span>, constant.PAGE_SIZE)</span><br><span class="line"></span><br><span class="line">res, err := ESClient.Search(</span><br><span class="line">ESClient.Search.WithContext(context.Background()),</span><br><span class="line">ESClient.Search.WithIndex(conf.ServerCfg.Get(constant.ES_PHOTO_INDEX)),</span><br><span class="line">ESClient.Search.WithBody(strings.NewReader(queryBody)),</span><br><span class="line">ESClient.Search.WithFrom(offset),</span><br><span class="line">ESClient.Search.WithSize(constant.PAGE_SIZE),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> photos, PhotoSearchError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.IsError() &#123;</span><br><span class="line">log.Println(PhotoSearchError)</span><br><span class="line"><span class="keyword">return</span> photos, PhotoSearchError</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">resMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(res.Body).Decode(&amp;resMap); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> photos, PhotoSearchError</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// for each hit in the response, we marshal the source into the photo object</span></span><br><span class="line"><span class="keyword">for</span> _, hit := <span class="keyword">range</span> resMap[<span class="string">"hits"</span>].(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">"hits"</span>].([]<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">source, _ := json.Marshal(hit.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)[<span class="string">"_source"</span>])</span><br><span class="line">photo := PhotoToIndex&#123;&#125;</span><br><span class="line">json.Unmarshal(source, &amp;photo)</span><br><span class="line">photos = <span class="built_in">append</span>(photos, photo)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> photos, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>es.go</code>里，主要实现了以下几个逻辑：</p><ul><li>读取配置项，新建ES client</li><li>index图片</li><li>更新图片url</li><li>通过tag或者description来搜索图片（定义了SearchType，取值要么是tag要么是desc）</li></ul><p>其中涉及到一些go client的API使用（index、search）还有对ES返回结果JSON的解析，对ES go client或者API使用感兴趣的可参考它们的项目地址：<a href="https://github.com/elastic/go-elasticsearch" target="_blank" rel="noopener">elastic/go-elasticsearch</a>。</p><h2 id="整合实现搜索功能"><a href="#整合实现搜索功能" class="headerlink" title="整合实现搜索功能"></a>整合实现搜索功能</h2><p>实现了ES Utils后，可以把ES Utils和之前的代码整合到一起来实现搜索功能。</p><p>首先在<code>AddPhoto()</code>里加上index图片的代码：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 补充models/photo.go</span></span><br><span class="line"><span class="comment">// Add a new photo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddPhoto</span><span class="params">(photoToAdd *Photo, photoFileHeader *multipart.FileHeader)</span> <span class="params">(*Photo, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index a photo in elasticsearch</span></span><br><span class="line"><span class="keyword">if</span> err = IndexPhoto(&amp;photo); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>UpdatePhoto()</code>里加上更新ES的代码：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 补充models/photo.go</span></span><br><span class="line"><span class="comment">// Update a photo.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdatePhoto</span><span class="params">(photoToUpdate *Photo)</span> <span class="params">(*Photo, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// update elasticsearch</span></span><br><span class="line">updated := Photo&#123;&#125;</span><br><span class="line">trx.Where(<span class="string">"id = ?"</span>, photoToUpdate.ID).First(&amp;updated)</span><br><span class="line"><span class="keyword">if</span> err := IndexPhoto(&amp;updated); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;photo, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;updated, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后实现一个图片搜索的API：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 补充apis/v1/photo.go</span></span><br><span class="line"><span class="comment">// Search a photo (by tag / description)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchPhoto</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">responseCode := constant.INVALID_PARAMS</span><br><span class="line">authID, err := strconv.Atoi(context.Query(<span class="string">"auth_id"</span>))</span><br><span class="line">tag, tagExisted := context.GetQuery(<span class="string">"tag"</span>)</span><br><span class="line">desc, descExisted := context.GetQuery(<span class="string">"desc"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || (tagExisted &amp;&amp; descExisted) || (!tagExisted &amp;&amp; !descExisted) &#123;</span><br><span class="line">context.AbortWithStatusJSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchType models.SearchType</span><br><span class="line"><span class="keyword">var</span> field <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> tagExisted &#123;</span><br><span class="line">searchType = constant.SEARCH_BY_TAG</span><br><span class="line">field = tag</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">searchType = constant.SEARCH_BY_DESC</span><br><span class="line">field = desc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validCheck := validation.Validation&#123;&#125;</span><br><span class="line">validCheck.Min(authID, <span class="number">1</span>, <span class="string">"auth_id"</span>).Message(<span class="string">"Auth id must be positive"</span>)</span><br><span class="line">validCheck.MinSize(field, <span class="number">1</span>, <span class="string">"search_field"</span>).Message(<span class="string">"Search field can't be empty"</span>)</span><br><span class="line"></span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line">offset := context.GetInt(<span class="string">"offset"</span>)</span><br><span class="line"><span class="keyword">if</span> photos, err := models.SearchPhoto(field, <span class="keyword">uint</span>(authID), offset, searchType); err == <span class="literal">nil</span> &#123;</span><br><span class="line">data[<span class="string">"photos"</span>] = photos</span><br><span class="line">responseCode = constant.PHOTO_SEARCH_BY_TAG_SUCCESS</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.INTERNAL_SERVER_ERROR</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: data,</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：一个搜索API可分别支持两种类型的搜索，但不支持同时按tag和description搜索。</strong></p><p>把上述搜索API添加到Router规则中：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 补充routers/router.go</span></span><br><span class="line"><span class="comment">// Init router, adding paths to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// api group for v1</span></span><br><span class="line">v1Group := Router.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// api group for photo</span></span><br><span class="line">photoGroup := v1Group.Group(<span class="string">"/photo"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">photoGroup.GET(<span class="string">"/search"</span>, checkAuthMdw, refreshMdw, paginationMdw, v1.SearchPhoto)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同之前的API，在执行<code>SearchPhoto()</code>之前，要先执行auth、refresh、pagination中间件。启动Server，用Postman访问该API进行搜索测试即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Elasticsearch和MySQL都可以存数据，都可以支持复杂查询，它们的核心差别有哪些？</p><ul><li>关键词：搜索引擎、数据结构、事务、Lucene</li></ul></li><li><p>在教程里，我们提到要么手写DSL查询ES，要么利用各编程语言的ES client来查询ES，那可不可以用SQL或者类SQL语句来查询ES呢？如果要你自己实现，可以怎么实现？</p><ul><li>关键词：Elasticsearch SQL support、SQL parser</li></ul></li><li><p>MySQL InnoDB里支持全文索引，使用全文索引可不可以支持我们的搜索需求？</p><ul><li>关键词：全文索引、InnoDB</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/03/10，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-5]中间件与API开发-2</title>
    <link href="http://yoursite.com/2019/03/07/gin-tutorial-5/"/>
    <id>http://yoursite.com/2019/03/07/gin-tutorial-5/</id>
    <published>2019-03-07T23:30:00.000Z</published>
    <updated>2019-03-07T23:28:35.086Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/03/07，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第五篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在上一篇教程<a href="https://marcoma.xyz/2019/03/04/gin-tutorial-4/" target="_blank" rel="noopener">《[Gin教程-4]中间件与API开发-1》</a>里我们实现了Auth API，可是还没有说怎么可以让它“运行起来”，还不知道怎么可以让用户调用。在本篇教程里，我们要定义后端的Router和Server，还有实现Bucket和Photo的部分API，让我们的服务真正地跑起来，可供外部调用。</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-router.png" alt=""></p><p>如图所示，所谓的Router，就是路由器，负责把外部请求转发给对应的执行方法。例如用户调用的是<code>www.xxx.com/add_auth</code>，服务器接到请求后，Router就把该请求转发给我们上一篇实现的<code>AddAuth()</code>方法，执行里面的添加新用户的逻辑。</p><p>而Server的实现，通俗来说其实就是要写一些代码，让你的进程一直运行，正常情况下不要自行退出，并且能够监听一个端口，从该端口处能接收用户请求和用户数据。</p><h2 id="Router-amp-Main"><a href="#Router-amp-Main" class="headerlink" title="Router &amp; Main"></a>Router &amp; Main</h2><p>因为上一篇教程里我们已经实现了Auth API，所以可以先简单地实现Router和Server，试试我们的API能不能正常工作。</p><p>在项目的根目录下新建<code>routers</code>文件夹，然后在文件夹内新建<code>router.go</code>代码文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— ......</span><br><span class="line">|—— apis</span><br><span class="line">    |—— ......</span><br><span class="line">|—— routers</span><br><span class="line">    |—— router.go</span><br></pre></td></tr></table></figure><p>Router的逻辑无非就是新建一个Router对象，然后往该Router对象里添加各种路径 -&gt; 方法的映射关系。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/apis/v1"</span></span><br><span class="line"><span class="string">"gin-photo-storage/middleware"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a global router</span></span><br><span class="line"><span class="keyword">var</span> Router *gin.Engine</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init router, adding paths to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">Router = gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// api group for v1</span></span><br><span class="line">v1Group := Router.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// api group for authentication</span></span><br><span class="line">authGroup := v1Group.Group(<span class="string">"/auth"</span>)</span><br><span class="line">&#123;</span><br><span class="line">authGroup.POST(<span class="string">"/add"</span>, v1.AddAuth)</span><br><span class="line">authGroup.POST(<span class="string">"/check"</span>, v1.CheckAuth)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong></p><ul><li><strong>用Group来划分API，可以让组织结构更加清晰。例如第一版的API，我们全部把它们归到<code>/api/v1</code>这个group下面，当项目迭代要开发第二版时，可以另外开一个group叫<code>/api/v2</code>，避免冲突。当调用该group下的API时，路径都要带上该group的前缀，如<code>www.xxx.com/api/v1/......</code>。</strong></li><li><strong>Group是可以嵌套的，在v1的group内部，基于v1还可以按照业务或者Model来划分不同的group，可以有<code>authGroup</code>、<code>bucketGroup</code>、<code>photoGroup</code>……同理，调用的时候也要加上该group的路径前缀。</strong></li></ul><p>接下来在项目的根目录下直接新建<code>main.go</code>代码文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— ......</span><br><span class="line">|—— apis</span><br><span class="line">    |—— ......</span><br><span class="line">|—— routers</span><br><span class="line">    |—— ......</span><br><span class="line">|—— main.go</span><br></pre></td></tr></table></figure><p>在Main里面，主要的逻辑就是起一个http server，然后配置一下该http server的handler，让它把请求转交给我们的Router去处理。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/routers"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// get the global router from router.go</span></span><br><span class="line">router := routers.Router</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up a http server</span></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: fmt.Sprintf(<span class="string">":%s"</span>, conf.ServerCfg.Get(constant.SERVER_PORT)),</span><br><span class="line">Handler: router,</span><br><span class="line">MaxHeaderBytes: <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the server</span></span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，<strong>保证你的<code>MySQL</code>和<code>Redis</code>在正常运行</strong>，然后在项目根目录下执行<code>go run main.go</code>，http server就能正常跑起来，保持监听我们在<code>server.conf</code>里设定的那个端口。</p><p>既然已经跑起来了，我们可以试试调用<code>AddAuth()</code>，看看是不是能够成功写入数据库。<strong>此处强烈建议使用<code>Postman</code>工具来测试API调用。（可以在电脑上装Postman软件，也可以用它的chrome插件）</strong></p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-postman.png" alt=""></p><p>用<code>Postman</code>调用<code>add_auth</code>API。（我设的监听端口是9088，测试时请更换为你们自己的端口）</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-db-addauth.png" alt=""></p><p>可以看到在数据库的<code>auth</code>表里出现了一条新增的用户记录。</p><h2 id="Bucket-API"><a href="#Bucket-API" class="headerlink" title="Bucket API"></a>Bucket API</h2><p>在<code>gin-photo-storage/apis/v1/</code>下新建<code>bucket.go</code>代码文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— ......</span><br><span class="line">|—— apis</span><br><span class="line">    |—— v1</span><br><span class="line">        |—— auth.go</span><br><span class="line">        |—— bucket.go</span><br><span class="line">|—— routers</span><br><span class="line">    |—— ......</span><br><span class="line">|—— main.go</span><br></pre></td></tr></table></figure><p>然后为Bucket实现增删改查的API，<strong>因为篇幅和排版的原因，教程里只给出<code>AddBucket()</code>的源码。</strong>其他API的代码逻辑基本类似，没有太大区别，全部Bucket API的源码可参考github repo里的<a href="https://github.com/AcepcsMa/gin-photo-gallery-example/blob/master/apis/v1/bucket.go" target="_blank" rel="noopener">bucket.go</a></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/models"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego/validation"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin/binding"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddBucket</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">responseCode := constant.INVALID_PARAMS</span><br><span class="line">bucketToAdd := models.Bucket&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := context.ShouldBindWith(&amp;bucketToAdd, binding.Form); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">context.AbortWithStatusJSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validCheck := validation.Validation&#123;&#125;</span><br><span class="line">validCheck.Required(bucketToAdd.AuthID, <span class="string">"auth_id"</span>).Message(<span class="string">"Must have auth id"</span>)</span><br><span class="line">validCheck.Required(bucketToAdd.Name, <span class="string">"bucket_name"</span>).Message(<span class="string">"Must have bucket name"</span>)</span><br><span class="line">validCheck.MaxSize(bucketToAdd.Name, <span class="number">64</span>, <span class="string">"bucket_name"</span>).Message(<span class="string">"Bucket name length can not exceed 64"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line"><span class="keyword">if</span> err := models.AddBucket(&amp;bucketToAdd); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == models.BucketExistsError &#123;</span><br><span class="line">responseCode = constant.BUCKET_ALREADY_EXIST</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.INTERNAL_SERVER_ERROR</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.BUCKET_ADD_SUCCESS</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line">log.Println(err.Message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">data[<span class="string">"bucket_name"</span>] = bucketToAdd.Name</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: data,</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete an existed bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteBucket</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update an existed bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateBucket</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a bucket by bucket id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBucketByID</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get buckets by auth id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBucketByAuthID</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong></p><ul><li><strong>这里没有用<code>context.Form()</code>或者<code>context.Query()</code>来获取请求里的参数，而是直接把请求参数bind到一个Bucket对象上（<code>context.ShouldBindWith()</code>）。为什么可以这么做呢？原因就是我们在Bucket Model里为每个字段设定了<code>form</code>标签，所以只要请求参数里的参数名能严格对应字段的<code>form</code>标签，就能成功把参数绑定到Bucket Model对象上。</strong></li></ul><h2 id="Photo-API"><a href="#Photo-API" class="headerlink" title="Photo API"></a>Photo API</h2><p>在<code>gin-photo-storage/apis/v1/</code>下新建<code>photo.go</code>代码文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— ......</span><br><span class="line">|—— apis</span><br><span class="line">    |—— v1</span><br><span class="line">        |—— auth.go</span><br><span class="line">        |—— bucket.go</span><br><span class="line">        |—— photo.go</span><br><span class="line">|—— routers</span><br><span class="line">    |—— ......</span><br><span class="line">|—— main.go</span><br></pre></td></tr></table></figure><p>然后为Photo实现增删改查的API，<strong>因为篇幅和排版的原因，教程里只给出<code>AddPhoto()</code>的源码。</strong>其他API的代码逻辑基本类似，没有太大区别，全部Photo API的源码可参考github repo里的<a href="https://github.com/AcepcsMa/gin-photo-gallery-example/blob/master/apis/v1/photo.go" target="_blank" rel="noopener">photo.go</a></p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/models"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego/validation"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin/binding"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new photo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddPhoto</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">responseCode := constant.INVALID_PARAMS</span><br><span class="line"></span><br><span class="line">photoFile, fileErr := context.FormFile(<span class="string">"photo"</span>)</span><br><span class="line"><span class="keyword">if</span> fileErr != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(fileErr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">photo := models.Photo&#123;&#125;</span><br><span class="line">paramErr := context.ShouldBindWith(&amp;photo, binding.Form)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fileErr != <span class="literal">nil</span> || paramErr != <span class="literal">nil</span> &#123;</span><br><span class="line">context.AbortWithStatusJSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validCheck := validation.Validation&#123;&#125;</span><br><span class="line">validCheck.Required(photo.AuthID, <span class="string">"auth_id"</span>).Message(<span class="string">"Must have auth id"</span>)</span><br><span class="line">validCheck.Required(photo.BucketID, <span class="string">"bucket_id"</span>).Message(<span class="string">"Must have bucket id"</span>)</span><br><span class="line">validCheck.Required(photo.Name, <span class="string">"photo_name"</span>).Message(<span class="string">"Must have photo name"</span>)</span><br><span class="line">validCheck.MaxSize(photo.Name, <span class="number">255</span>, <span class="string">"photo_name"</span>).Message(<span class="string">"Photo name len must not exceed 255"</span>)</span><br><span class="line"></span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">photoToAdd := &amp;models.Photo&#123;BucketID: photo.BucketID, AuthID: photo.AuthID,</span><br><span class="line">Name: photo.Name, Description: photo.Description,</span><br><span class="line">Tag:strings.Join(photo.Tags, <span class="string">";"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line"><span class="keyword">if</span> photoToAdd, uploadID, err := models.AddPhoto(photoToAdd, photoFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == models.PhotoExistsError &#123;</span><br><span class="line">responseCode = constant.PHOTO_ALREADY_EXIST</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.INTERNAL_SERVER_ERROR</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.PHOTO_ADD_IN_PROCESS</span><br><span class="line">data[<span class="string">"photo"</span>] = *photoToAdd</span><br><span class="line">data[<span class="string">"photo_upload_id"</span>] = uploadID</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line">log.Println(err.Message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: data,</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete an existed photo.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeletePhoto</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update an existed photo.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdatePhoto</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a photo by photo id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPhotoByID</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get photos by bucket id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPhotoByBucketID</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the upload status of a photo by upload id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPhotoUploadStatus</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，除了用<code>context.ShouldBindWith()</code>来绑定参数之外，我们还用<code>context.FormFile()</code>来获取用户通过API上传的图片文件。</p><h2 id="设置Router转发规则"><a href="#设置Router转发规则" class="headerlink" title="设置Router转发规则"></a>设置Router转发规则</h2><p>到这里，我们已经实现了：</p><ul><li>中间件<ul><li>pagination中间件</li><li>auth中间件</li><li>refresh中间件</li></ul></li><li>API<ul><li>Auth API</li><li>Bucket API</li><li>Photo API</li></ul></li></ul><p>此时应该把所有API的routing规则都设置到Router里，让请求真正都能被转发到对应的执行方法处。以下为最终的<code>router.go</code>：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/apis/v1"</span></span><br><span class="line"><span class="string">"gin-photo-storage/middleware"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// a global router</span></span><br><span class="line"><span class="keyword">var</span> Router *gin.Engine</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init router, adding paths to it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">Router = gin.Default()</span><br><span class="line">checkAuthMdw := middleware.GetAuthMiddleware()<span class="comment">// middleware for authentication</span></span><br><span class="line">refreshMdw := middleware.GetRefreshMiddleware()<span class="comment">// middleware for refresh auth token</span></span><br><span class="line">paginationMdw := middleware.GetPaginationMiddleware()<span class="comment">// middleware for pagination</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// api group for v1</span></span><br><span class="line">v1Group := Router.Group(<span class="string">"/api/v1"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// api group for authentication</span></span><br><span class="line">authGroup := v1Group.Group(<span class="string">"/auth"</span>)</span><br><span class="line">&#123;</span><br><span class="line">authGroup.POST(<span class="string">"/add"</span>, v1.AddAuth)</span><br><span class="line">authGroup.POST(<span class="string">"/check"</span>, v1.CheckAuth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// api group for bucket</span></span><br><span class="line">bucketGroup := v1Group.Group(<span class="string">"/bucket"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// must check auth &amp; refresh auth token before any operation</span></span><br><span class="line">bucketGroup.POST(<span class="string">"/add"</span>, checkAuthMdw, refreshMdw, v1.AddBucket)</span><br><span class="line">bucketGroup.DELETE(<span class="string">"/delete"</span>, checkAuthMdw, refreshMdw, v1.DeleteBucket)</span><br><span class="line">bucketGroup.PUT(<span class="string">"/update"</span>, checkAuthMdw, refreshMdw, v1.UpdateBucket)</span><br><span class="line">bucketGroup.GET(<span class="string">"/get_by_id"</span>, checkAuthMdw, refreshMdw, v1.GetBucketByID)</span><br><span class="line">bucketGroup.GET(<span class="string">"/get_by_auth_id"</span>, checkAuthMdw, refreshMdw, paginationMdw, v1.GetBucketByAuthID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// api group for photo</span></span><br><span class="line">photoGroup := v1Group.Group(<span class="string">"/photo"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// must check auth &amp; refresh auth token before any operation</span></span><br><span class="line">photoGroup.POST(<span class="string">"/add"</span>, checkAuthMdw, refreshMdw, v1.AddPhoto)</span><br><span class="line">photoGroup.GET(<span class="string">"/upload_status"</span>, checkAuthMdw, refreshMdw, v1.GetPhotoUploadStatus)</span><br><span class="line">photoGroup.DELETE(<span class="string">"/delete"</span>, checkAuthMdw, refreshMdw, v1.DeletePhoto)</span><br><span class="line">photoGroup.PUT(<span class="string">"/update"</span>, checkAuthMdw, refreshMdw, v1.UpdatePhoto)</span><br><span class="line">photoGroup.GET(<span class="string">"/get_by_id"</span>, checkAuthMdw, refreshMdw, v1.GetPhotoByID)</span><br><span class="line">photoGroup.GET(<span class="string">"/get_by_bucket_id"</span>, checkAuthMdw, refreshMdw, paginationMdw, v1.GetPhotoByBucketID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在bucket group和photo group里我们为每个API都设定了调用路径，并且为其配置了auth中间件、pagination中间件和refresh中间件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Router定义里，不同的方法会对应<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>多个不同的动词，它们有什么区别？除了这4个还有什么动词可以直接拿来用？</p><ul><li>关键词：http verb</li></ul></li><li><p>在教程里，Server、Router、APIs、Models全都是一个进程里的，在单台服务器上把程序run起来就可以工作了。但如果程序里某一个地方出bug导致崩溃了，意味着从Server到Models都不能工作了，有更好的架构解决类似的问题吗？</p><ul><li>关键词：微服务、容灾</li></ul></li><li><p>我们在main里面起了一个http server，什么是http？可以用http server来做即时聊天工具的服务器吗？</p><ul><li>关键词：http协议、tcp协议、网络协议栈</li></ul></li><li><p>在<code>AddAuth()</code>的逻辑里，我们会先把用户密码用md5加一层壳再写MySQL，但是在调API的时候是直接明文传输的，这样是不是很不安全？有什么解决手段吗？</p><ul><li>关键词：SSL/TLS、https</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/03/07，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-4]中间件与API开发-1</title>
    <link href="http://yoursite.com/2019/03/04/gin-tutorial-4/"/>
    <id>http://yoursite.com/2019/03/04/gin-tutorial-4/</id>
    <published>2019-03-05T00:00:00.000Z</published>
    <updated>2019-03-07T23:18:51.724Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/03/04，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第四篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在上一篇教程<a href="https://marcoma.xyz/2019/02/28/gin-tutorial-3/" target="_blank" rel="noopener">《[Gin教程-3]引入Redis》</a>里，我们引入了<code>Redis</code>，实现了<code>Redis utils</code>且结合腾讯云<code>COS</code>开发了图片上传的功能。</p><p>在本篇教程中，我们要开始开发API层，接收客户端的请求，解析请求里的参数，然后对各个Model执行增/删/改/查操作。</p><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><p>API层包含了很多API，每个API的职责就是：</p><ol><li>解析用户请求的参数（表单、url参数……）</li><li>验证参数有效性</li><li>调用对应Model的增/删/改/查方法，得到执行结果</li><li>对执行结果进行封装，返回给用户</li></ol><p>但是在真正调用API前，很多时候我们需要做一些额外的工作。拿新增图片这个操作为例，我们不能允许用户在未登录状态下新增图片，所以调用<code>AddPhoto()</code>前我们还得额外地“鉴权”，去查查该用户是不是已经登录了，所以我们需要写一个“鉴权的方法”；再例如查询一个bucket下的所有图片时，我们需要对数据分页，总不能一次请求返回几万张图片数据吧？所以我们需要写一个“分页的方法”。</p><p>所以，实际上API层是由中间件 + API组成的，<strong>每一个中间件其实可以看成一个特殊的API，它也要解析参数，也要执行相应的逻辑，也要返回结果给下一级，称其为中间件是因为它不是执行链的最后一个，而是在执行链的中间位置。</strong></p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-mdw.png" alt=""></p><p>如上图所示，在请求到达最终执行业务逻辑的API前，很可能要先经过一系列的中间件，就像是一条执行链。</p><h2 id="分页中间件"><a href="#分页中间件" class="headerlink" title="分页中间件"></a>分页中间件</h2><p>首先来看看分页中间件，凡是返回多项数据的API，都必须先经过分页。例如<code>GetPhotoByBucketID()</code>、<code>GetBucketByAuthID()</code>，我们要把请求中的<code>page</code>参数先转化为<code>offset = page * PAGE_SIZE</code>，然后才能从数据库中直接利用offset得到我们想要的数据。</p><p>在项目根目录下新建<code>middleware</code>文件夹，然后新建<code>pagination.go</code>代码文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— pagination.go</span><br></pre></td></tr></table></figure><p>接着可以实现分页中间件：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> InvalidPageNoError = errors.New(<span class="string">"page no can not be negative"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper function which returns the pagination middleware.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPaginationMiddleware</span><span class="params">()</span> <span class="title">func</span><span class="params">(*gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">responseCode := constant.PAGINATION_SUCCESS</span><br><span class="line">pageNo := context.Query(<span class="string">"page"</span>)</span><br><span class="line"><span class="keyword">if</span> pageNo == <span class="string">""</span> &#123;</span><br><span class="line">responseCode = constant.INVALID_PARAMS</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pageOffset, err := GetPagination(pageNo)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">responseCode = constant.INVALID_PARAMS</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">context.Set(<span class="string">"offset"</span>, pageOffset)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> responseCode == constant.INVALID_PARAMS &#123;</span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">data[<span class="string">"page"</span>] = pageNo</span><br><span class="line">context.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: constant.INVALID_PARAMS,</span><br><span class="line"><span class="string">"data"</span>: data,</span><br><span class="line"><span class="string">"msg"</span>:  constant.GetMessage(constant.INVALID_PARAMS),</span><br><span class="line">&#125;)</span><br><span class="line">context.Abort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pagination function which calculates the offset given the page number.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPagination</span><span class="params">(pageNo <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">pageNoInt, err := strconv.Atoi(pageNo)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pageNoInt &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, InvalidPageNoError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pageNoInt * constant.PAGE_SIZE, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：为什么我们要绕一圈，定义一个wrapper方法？</strong>用wrapper方法返回一个<code>func(context *gin.Context)</code>，而不是直接把分页中间件定义成一个<code>func(context *gin.Context)</code>？因为用wrapper方法的话，我们可以在return真正的中间件方法前做一些其他操作，例如：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetXXXMiddleware</span><span class="params">()</span> <span class="title">func</span><span class="params">(*gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// 可以在这连接数据库</span></span><br><span class="line"><span class="comment">// 可以在这读某个磁盘文件</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// 真正的中间件逻辑</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一些耗时的操作，或者那些只需要在最开始做一次的操作放在return中间件的前面，就不需要把它们写在中间件的内部，“污染”中间件真正的逻辑。</p><h2 id="Auth中间件"><a href="#Auth中间件" class="headerlink" title="Auth中间件"></a>Auth中间件</h2><p>至于Auth中间件，我们要实现的逻辑是：</p><ol><li>尝试从请求的cookie里获取<code>JWT</code>字符串，如果不存在<code>JWT</code>串说明该用户从未登录，或者N久前登录导致cookie都消失了。</li><li>调用<code>utils</code>里的解析方法，解析该<code>JWT</code>串，得到<code>UserClaim</code>。</li><li>从<code>UserClaim</code>里获取用户名，检查<code>Redis</code>里存不存在该用户名，如果不存在说明该用户登录状态已过期。</li><li>若前几步都验证成功，可以把用户名加到本次请求的<code>context</code>里，完成本中间件的所有任务，去做下一步。</li></ol><p>我们在<code>gin-photo-storage/middleware/</code>下新建<code>auth.go</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— pagination.go</span><br><span class="line">|—— auth.go</span><br></pre></td></tr></table></figure><p>然后可以实现<code>auth.go</code>：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"gin-photo-storage/utils"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper function which returns the auth middleware.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAuthMiddleware</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">jwtString, err := context.Cookie(constant.JWT)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">context.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: constant.JWT_MISSING_ERROR,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(constant.JWT_MISSING_ERROR),</span><br><span class="line">&#125;)</span><br><span class="line">context.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">claim, err := utils.ParseJWT(jwtString)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">context.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: constant.JWT_PARSE_ERROR,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(constant.JWT_PARSE_ERROR),</span><br><span class="line">&#125;)</span><br><span class="line">context.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> utils.IsAuthInRedis(claim.UserName) &#123;</span><br><span class="line">context.Set(<span class="string">"user_name"</span>, claim.UserName)</span><br><span class="line">context.Next()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">context.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: constant.USER_AUTH_TIMEOUT,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(constant.USER_AUTH_TIMEOUT),</span><br><span class="line">&#125;)</span><br><span class="line">context.Abort()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong></p><ul><li><strong>context就是本次请求的上下文数据，它的生命周期就是整个请求的生命周期。只要请求没完成/没结束，context都会存在。所以我们才能把用户名set到context里，传给下一步。</strong></li><li><strong>注意在验证异常时，除了调用<code>context.Abort()</code>来终止执行链之外，还要及时return，避免执行该中间件下面的逻辑。</strong></li></ul><h2 id="Refresh中间件"><a href="#Refresh中间件" class="headerlink" title="Refresh中间件"></a>Refresh中间件</h2><p><strong>所谓的Refresh中间件，所要refresh的就是用户的登录token。</strong>试想一下这样的场景：用户在12:00登录了系统，根据我们设定的<code>JWT_EXP_MINUTE = 30</code>，说明他的登录状态在12:31就在<code>Redis</code>里过期了，必须得重新登录。虽然过期时间设短一点相对会安全些，但是这样是非常影响用户体验的。</p><p>所以，我们就要设计refresh机制。<strong>如果用户在登录之后有各种频繁的操作，那我们就不断地给他刷新他的token有效期。</strong>例如用户在12:00登录了，token有效期到12:30，但是他在12:18新建了bucket，那我们就把他的token有效期刷新，刷成12:48，之后他又在12:35添加了20张图片，那就再把他的token有效期刷到13:05，依此类推。</p><p>先在<code>gin-photo-gallery/middleware/</code>下新建<code>refresh.go</code>代码文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— pagination.go</span><br><span class="line">|—— auth.go</span><br><span class="line">|—— refresh.go</span><br></pre></td></tr></table></figure><p>然后可以实现<code>refresh.go</code>：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"gin-photo-storage/utils"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A wrapper function which returns the refresh middleware.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRefreshMiddleware</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> userName, ok := context.Get(<span class="string">"user_name"</span>); ok &#123;</span><br><span class="line"><span class="comment">// generate a new valid JWT for the user</span></span><br><span class="line">jwtString, err := utils.GenerateJWT(userName.(<span class="keyword">string</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">data[<span class="string">"user_name"</span>] = userName.(<span class="keyword">string</span>)</span><br><span class="line">context.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: constant.JWT_GENERATION_ERROR,</span><br><span class="line"><span class="string">"data"</span>: data,</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(constant.JWT_GENERATION_ERROR),</span><br><span class="line">&#125;)</span><br><span class="line">context.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save the new JWT in user's cookie</span></span><br><span class="line">context.SetCookie(constant.JWT, jwtString,</span><br><span class="line">constant.COOKIE_MAX_AGE, <span class="string">"/"</span>,</span><br><span class="line">conf.ServerCfg.Get(constant.SERVER_DOMAIN), <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// refresh user in the redis</span></span><br><span class="line">err = utils.AddAuthToRedis(userName.(<span class="keyword">string</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">context.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: constant.INTERNAL_SERVER_ERROR,</span><br><span class="line"><span class="string">"data"</span>: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(constant.INTERNAL_SERVER_ERROR),</span><br><span class="line">&#125;)</span><br><span class="line">context.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">context.Next()</span><br><span class="line">&#125;</span><br><span class="line">context.Abort()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：我们不仅要为用户颁发一个新的<code>JWT</code>，还要在<code>Redis</code>里给用户刷新一下，避免过期。</strong></p><h2 id="Auth-API"><a href="#Auth-API" class="headerlink" title="Auth API"></a>Auth API</h2><p>把几个必要的中间件实现完，可以开始实现我们的业务逻辑了，首先来看看Auth API。</p><p>先在项目根目录下新建<code>apis</code>文件夹，再在<code>apis</code>下新建<code>v1</code>文件夹，代表现在开发的API版本是v1。最后在<code>apis/v1/</code>下新建<code>auth.go</code>代码文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">|—— ......</span><br><span class="line">|—— middleware</span><br><span class="line">|—— ......</span><br><span class="line">|—— apis</span><br><span class="line">    |—— v1</span><br><span class="line">        |—— auth.go</span><br></pre></td></tr></table></figure><p>因为在API的逻辑里要对请求里的参数作合法性验证，所以我们就采用了第三方的<code>beego validation</code>来实现参数验证。（不使用第三方库，纯手写验证逻辑也不是不可以，只不过用库会方便优雅一点）</p><ul><li>Golang &lt;= 1.10且项目位于<code>$GOPATH/src/</code>下的，可直接<code>go get -u github.com/astaxie/beego/validation</code></li><li>否则可用go mod来安装 </li></ul><p>在<code>auth.go</code>里，我们要实现2个API：用户注册（AddAuth）和用户登录验证（CheckAuth）：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> v1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/models"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"gin-photo-storage/utils"</span></span><br><span class="line"><span class="string">"github.com/astaxie/beego/validation"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new auth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAuth</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">userName := context.PostForm(<span class="string">"user_name"</span>)</span><br><span class="line">password := context.PostForm(<span class="string">"password"</span>)</span><br><span class="line">email := context.PostForm(<span class="string">"email"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up param validation</span></span><br><span class="line">validCheck := validation.Validation&#123;&#125;</span><br><span class="line">validCheck.Required(userName, <span class="string">"user_name"</span>).Message(<span class="string">"Must have user name"</span>)</span><br><span class="line">validCheck.MaxSize(userName, <span class="number">16</span>, <span class="string">"user_name"</span>).Message(<span class="string">"User name length can not exceed 16"</span>)</span><br><span class="line">validCheck.MinSize(userName, <span class="number">6</span>, <span class="string">"user_name"</span>).Message(<span class="string">"User name length is at least 6"</span>)</span><br><span class="line">validCheck.Required(password, <span class="string">"password"</span>).Message(<span class="string">"Must have password"</span>)</span><br><span class="line">validCheck.MaxSize(password, <span class="number">16</span>, <span class="string">"password"</span>).Message(<span class="string">"Password length can not exceed 16"</span>)</span><br><span class="line">validCheck.MinSize(password, <span class="number">6</span>, <span class="string">"password"</span>).Message(<span class="string">"Password length is at least 6"</span>)</span><br><span class="line">validCheck.Required(email, <span class="string">"email"</span>).Message(<span class="string">"Must have email"</span>)</span><br><span class="line">validCheck.MaxSize(email, <span class="number">128</span>, <span class="string">"email"</span>).Message(<span class="string">"Email can not exceed 128 chars"</span>)</span><br><span class="line"></span><br><span class="line">responseCode := constant.INVALID_PARAMS</span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line"><span class="keyword">if</span> err := models.AddAuth(userName, password, email); err == <span class="literal">nil</span> &#123;</span><br><span class="line">responseCode = constant.USER_ADD_SUCCESS</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.USER_ALREADY_EXIST</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: userName,</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if an auth is valid.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckAuth</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">userName := context.PostForm(<span class="string">"user_name"</span>)</span><br><span class="line">password := context.PostForm(<span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up param validation</span></span><br><span class="line">validCheck := validation.Validation&#123;&#125;</span><br><span class="line">validCheck.Required(userName, <span class="string">"user_name"</span>).Message(<span class="string">"Must have user name"</span>)</span><br><span class="line">validCheck.MaxSize(userName, <span class="number">16</span>, <span class="string">"user_name"</span>).Message(<span class="string">"User name length can not exceed 16"</span>)</span><br><span class="line">validCheck.MinSize(userName, <span class="number">6</span>, <span class="string">"user_name"</span>).Message(<span class="string">"User name length is at least 6"</span>)</span><br><span class="line">validCheck.Required(password, <span class="string">"password"</span>).Message(<span class="string">"Must have password"</span>)</span><br><span class="line">validCheck.MaxSize(password, <span class="number">16</span>, <span class="string">"password"</span>).Message(<span class="string">"Password length can not exceed 16"</span>)</span><br><span class="line">validCheck.MinSize(password, <span class="number">6</span>, <span class="string">"password"</span>).Message(<span class="string">"Password length is at least 6"</span>)</span><br><span class="line"></span><br><span class="line">responseCode := constant.INVALID_PARAMS</span><br><span class="line"><span class="keyword">if</span> !validCheck.HasErrors() &#123;</span><br><span class="line"><span class="keyword">if</span> models.CheckAuth(userName, password) &#123;</span><br><span class="line"><span class="keyword">if</span> jwtString, err := utils.GenerateJWT(userName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">responseCode = constant.JWT_GENERATION_ERROR</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// pass auth validation</span></span><br><span class="line"><span class="comment">// 1. set JWT to user's cookie</span></span><br><span class="line"><span class="comment">// 2. add user to the Redis</span></span><br><span class="line">context.SetCookie(constant.JWT, jwtString,</span><br><span class="line">constant.COOKIE_MAX_AGE, conf.ServerCfg.Get(constant.SERVER_PATH),</span><br><span class="line">conf.ServerCfg.Get(constant.SERVER_DOMAIN), <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err = utils.AddAuthToRedis(userName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">responseCode = constant.INTERNAL_SERVER_ERROR</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.USER_AUTH_SUCCESS</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">responseCode = constant.USER_AUTH_ERROR</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> validCheck.Errors &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">"code"</span>: responseCode,</span><br><span class="line"><span class="string">"data"</span>: userName,</span><br><span class="line"><span class="string">"msg"</span>: constant.GetMessage(responseCode),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Auth API里的核心点在于业务逻辑，在<code>CheckAuth()</code>里如果一个用户验证通过，不仅要为他“颁发”一个<code>JWT</code>串，还要把该用户写入到<code>Redis</code>里，用<code>Redis</code>来记录这个用户是否在有效登录期内。如果一个用户请求的cookie里带有<code>JWT</code>，但是<code>Redis</code>里没有该用户的数据，要么是他伪造了<code>JWT</code>，要么是<code>JWT</code>和<code>Redis</code>里的数据过期时间不同步。</p><p><strong>Note：</strong></p><ul><li><strong>代码里用的是<code>context.PostForm(xxx)</code>来获取请求参数，这个前提是用户会用POST表单来传参，如果用户用url参数来传参，我们应该用<code>context.Query(xxx)</code>来获取参数。</strong></li><li><strong>API调用完成后我们返回的是JSON数据，根据不同的需求，我们也可以返回一个渲染好的html页面，或者就返回裸字符串。</strong></li><li><strong>通过<code>context.JSON()</code>返回给调用者的是JSON格式的数据，字段就是gin.H{}里的那些字段，gin.H其实只是一个简写，本质上gin.H就是一个`map[string]interface{}。</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>在gin框架里，中间件指的是在API调用的执行链处于中间位置的组件。那撇开gin框架，从宏观的角度来看，中间件又指什么呢？有哪些著名的中间件？</p><ul><li>关键词：中间件、业务逻辑、插件</li></ul></li><li><p>用户成功登录后，我们把<code>JWT</code>串写到了他的cookie里，对于浏览器应用来说写cookie是不错的做法（虽然可能有安全问题）。那如果调用我们API的不是浏览器应用，而是ios/android app，我们应该把<code>JWT</code>串写到哪里呢，应该怎么返回呢？</p></li><li><p>在返回的JSON数据里，我们有自定义的<code>code</code>字段，可是本身http协议就有代表不同状态的状态码，为什么我们还要加上自定义的<code>code</code>？</p></li><li><p>在实现中间件时，<code>GetXXXMiddleware()</code>返回的是一个<code>func(*gin.Context)</code>，为什么一个函数的返回值可以是另一个函数？在Golang里函数也是一种类型吗？在Java里可不可以实现类似的功能？</p><ul><li>关键词：函数指针、函数作为类型</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/03/04，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-3]引入Redis</title>
    <link href="http://yoursite.com/2019/02/28/gin-tutorial-3/"/>
    <id>http://yoursite.com/2019/02/28/gin-tutorial-3/</id>
    <published>2019-03-01T00:30:00.000Z</published>
    <updated>2019-03-04T23:16:19.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/02/28，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第三篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>上一篇<a href="https://marcoma.xyz/2019/02/25/gin-tutorial-2/" target="_blank" rel="noopener">《[Gin教程-2]数据库与Models实现》</a>里设计了MySQL表以及对应的Model，并且为每个Model都实现了一些必要的增/删/改/查接口。利用MySQL，我们可以把很多数据都持久化下来。但是在本项目中也有一些数据是MySQL不擅长处理的，或者说有别的存储组件比MySQL更适合用来实现我们的需求，如：</p><ol><li><p>记录用户登录状态</p><p> 用户成功登录后系统要记录Ta已登录；登录的有效期为X秒，X秒内如果没有任何操作，X秒后登录状态要过期，要求用户重新登录；用户可主动退出登录，系统要及时更新Ta的登录状态。<strong>更新操作非常频繁，不是那种一次写多次读的数据。</strong></p></li><li><p>当做伪消息队列，在多个模块间传递消息</p><p> 当一个操作不是原子操作，而是由多个小步骤组合而成，那么多个小步骤的执行顺序很可能需要通过消息来驱动。例如本项目的添加图片功能，第一步就是早MySQL表里插入新record，第二步就是将图片上传至腾讯云的对象存储，第三步就是将腾讯云的图片url更新到MySQL表中。第二和第三步之间就要通过消息来驱动，只有图片上传成功后，才能通知把图片url更新到表里。</p></li><li><p>存储图片数据</p><p> 图片实际上就是一连串的字符数据，如果我们想把图片存下来，可以把这一串字符串存到MySQL里的一个text字段，又或者把图片存到本地的文件系统里，然后MySQL里记录该图片的文件路径。但是其实有更好的办法，就是用一些公有云提供的对象存储服务来存图片、视频、音频等非结构化的数据。</p></li></ol><p>针对1、2的需求，我们可以用<code>Redis</code>来实现。<strong>本教程不涉及安装<code>Redis</code>的步骤，请自行查阅并安装。</strong></p><p>针对3的需求，我们可以用<code>七牛云</code>/<code>阿里云oss</code>/<code>aws S3</code>/<code>腾讯云cos</code>来实现。<strong>由于<code>腾讯云cos</code>有50G的免费额度，基于这个原因本教程就选用了<code>腾讯云cos</code></strong>，实际上各家的对象存储服务在简单存储上都没有太明显的差异，可根据自己的喜好选择。</p><h2 id="实现Redis-Utils"><a href="#实现Redis-Utils" class="headerlink" title="实现Redis Utils"></a>实现Redis Utils</h2><p>首先在<code>utils</code>下新建<code>redis.go</code>代码文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">    |—— jwt.go</span><br><span class="line">|—— redis.go</span><br></pre></td></tr></table></figure><p>本教程使用的redis client是<code>go-redis</code>，当然github上还有很多不错的redis client，也可以根据个人喜好更换。</p><ul><li>Golang &lt;= 1.10且项目位于<code>$GOPATH/src/</code>下的，可直接<code>go get -u github.com/go-redis/redis</code></li><li>否则可用go mod来安装</li></ul><p>根据上面提到的需求，我们要用<code>Redis</code>实现以下接口：</p><ol><li>用户登录后，把用户信息添加到<code>Redis</code>里，并设置过期时间</li><li>查询用户信息是否在<code>Redis</code>里（是否登录成功）</li><li>用户退出登录后，把用户信息从<code>Redis</code>里删除</li><li>图片开始上传时，把图片信息添加到<code>Redis</code>里</li><li>查询图片上传状态</li><li>消息通知，把消息发布到某个<code>Redis channel</code></li></ol><p>先在<code>gin-photo-storage/constant/constant.go</code>里加入几个常量：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Redis constants</span></span><br><span class="line">REDIS_HOST = <span class="string">"REDIS_HOST"</span></span><br><span class="line">REDIS_PORT = <span class="string">"REDIS_PORT"</span></span><br></pre></td></tr></table></figure><p>然后记得在<code>gin-photo-storage/conf/server.conf</code>里写上<code>Redis</code>的相关配置项。没有自行修改的话，默认地址是本机地址<code>127.0.0.1</code>，默认端口是<code>6379</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&quot;REDIS_HOST&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">&quot;REDIS_PORT&quot;: &quot;6379&quot;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来开始实现<code>redis.go</code>。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为redis.go的内容</span></span><br><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/go-redis/redis"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RedisClient *redis.Client</span><br><span class="line"><span class="keyword">var</span> InitComplete = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init redis client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">host := conf.ServerCfg.Get(constant.REDIS_HOST)</span><br><span class="line">port := conf.ServerCfg.Get(constant.REDIS_PORT)</span><br><span class="line">RedisClient = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr: fmt.Sprintf(<span class="string">"%s:%s"</span>, host, port),</span><br><span class="line">Password: <span class="string">""</span>,</span><br><span class="line">DB: <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line">InitComplete &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add an auth to redis, meaning that he/she has logged in.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAuthToRedis</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"%s%s"</span>, constant.LOGIN_USER, username)</span><br><span class="line">err := RedisClient.Set(key, username, constant.LOGIN_MAX_AGE * time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if an auth is in redis.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsAuthInRedis</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"%s%s"</span>, constant.LOGIN_USER, username)</span><br><span class="line">err := RedisClient.Get(key).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an auth from redis, meaning he/she is logging out.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAuthFromRedis</span><span class="params">(username <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">key := fmt.Sprintf(<span class="string">"%s%s"</span>, constant.LOGIN_USER, username)</span><br><span class="line">err := RedisClient.Del(key).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the upload status for a photo.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetUploadStatus</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">err := RedisClient.Set(key, value, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the upload status of a photo.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUploadStatus</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">val := RedisClient.Get(key).Val()</span><br><span class="line"><span class="keyword">if</span> val == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span><span class="comment">// means no such key</span></span><br><span class="line">&#125;</span><br><span class="line">status, _ := strconv.Atoi(val)</span><br><span class="line"><span class="keyword">return</span> status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send a message to the given channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendToChannel</span><span class="params">(channel <span class="keyword">string</span>, message <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">err := RedisClient.Publish(channel, message).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几点核心点需要注意：</p><ol><li>在<code>init()</code>里，初始化连接后，往<code>InitComplete</code>这个channel发了一条空数据，主要是有别的模块一直监听这个channel，阻塞在那，等待Redis连接初始化的完成。通过这条空数据可以告诉别的模块“我已经把Redis连接初始化好了，你们可以开始使用该连接了”。</li><li>用户登录后往Redis里写信息，key是<code>LOGIN_ + 用户名</code>，value是用户名，且设了一个过期时间<code>constant.LOGIN_MAX_AGE</code>，查询和删除用户信息也是用的相同的key。</li><li>发消息不是真正意义上的点对点发消息，而是用了Redis本身的订阅发布（pub-sub）机制：<code>Publish(channel, message)</code>。</li></ol><h2 id="实现COS-Utils"><a href="#实现COS-Utils" class="headerlink" title="实现COS Utils"></a>实现COS Utils</h2><p><strong>Note：首先注册腾讯云账号（应该用微信账号即可），确保开通了腾讯云COS，并且为本项目新建了一个bucket，bucket名称任意。</strong></p><p>首先在<code>utils</code>下新建<code>cos.go</code>代码文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— ......</span><br><span class="line">|—— constant</span><br><span class="line">|—— ......</span><br><span class="line">|—— models</span><br><span class="line">|—— ......</span><br><span class="line">|—— utils</span><br><span class="line">    |—— jwt.go</span><br><span class="line">|—— redis.go</span><br><span class="line">|—— cos.go</span><br></pre></td></tr></table></figure><ul><li>Golang &lt;= 1.10且项目位于<code>$GOPATH/src/</code>下的，可直接<code>go get -u github.com/tencentyun/cos-go-sdk-v5</code></li><li>否则可用go mod来安装</li></ul><p>先在<code>gin-photo-storage/constant/constant.go</code>里加入几个常量：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// COS constants</span></span><br><span class="line">COS_BUCKET_NAME = <span class="string">"COS_BUCKET_NAME"</span></span><br><span class="line">COS_APP_ID = <span class="string">"COS_APP_ID"</span></span><br><span class="line">COS_REGION = <span class="string">"COS_REGION"</span></span><br><span class="line">COS_SECRET_ID = <span class="string">"COS_SECRET_ID"</span></span><br><span class="line">COS_SECRET_KEY = <span class="string">"COS_SECRET_KEY"</span></span><br></pre></td></tr></table></figure><p>然后记得在<code>gin-photo-storage/conf/server.conf</code>里写上<code>COS</code>的相关配置项。以下的配置项均可在腾讯云的控制面板里获取。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&quot;COS_SECRET_ID&quot;: &quot;......&quot;,</span><br><span class="line">&quot;COS_SECRET_KEY&quot;: &quot;......&quot;,</span><br><span class="line">&quot;COS_BUCKET_NAME&quot;: &quot;......&quot;,</span><br><span class="line">&quot;COS_APP_ID&quot;: &quot;......&quot;,</span><br><span class="line">&quot;COS_REGION&quot;: &quot;......&quot;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来开始实现<code>cos.go</code>。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为cos.go的内容</span></span><br><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/tencentyun/cos-go-sdk-v5"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">CosClient    *cos.Client</span><br><span class="line">CosUrlFormat = <span class="string">"http://%s-%s.cos.%s.myqcloud.com"</span></span><br><span class="line">BucketName   = <span class="string">""</span></span><br><span class="line">AppID        = <span class="string">""</span></span><br><span class="line">Region       = <span class="string">""</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// init COS client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">BucketName = conf.ServerCfg.Get(constant.COS_BUCKET_NAME)</span><br><span class="line">AppID = conf.ServerCfg.Get(constant.COS_APP_ID)</span><br><span class="line">Region = conf.ServerCfg.Get(constant.COS_REGION)</span><br><span class="line">u, _ := url.Parse(fmt.Sprintf(CosUrlFormat, BucketName, AppID, Region))</span><br><span class="line">b := &amp;cos.BaseURL&#123;BucketURL: u&#125;</span><br><span class="line">CosClient = cos.NewClient(b, &amp;http.Client&#123;</span><br><span class="line">Transport: &amp;cos.AuthorizationTransport&#123;</span><br><span class="line">SecretID:  conf.ServerCfg.Get(constant.COS_SECRET_ID),</span><br><span class="line">SecretKey: conf.ServerCfg.Get(constant.COS_SECRET_KEY),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">log.Printf(<span class="string">"COS client %s init"</span>, CosClient.BaseURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结合Redis和COS实现异步图片上传"><a href="#结合Redis和COS实现异步图片上传" class="headerlink" title="结合Redis和COS实现异步图片上传"></a>结合Redis和COS实现异步图片上传</h2><p>到了这一步，已经把<code>Redis utils</code>和<code>COS utils</code>实现后，<strong>可以把它们结合起来实现上一篇教程遗留的一个需求——图片上传。</strong></p><p>我们有两种方式可以实现图片上传：</p><ul><li>同步（sync）上传。调用AddPhoto后，先插入一条数据库record，再上传图片至COS，等待图片上传完成，更新MySQL record的url字段，最后才返回给调用者。</li><li>异步（async）上传。调用AddPhoto后，先插入一条数据库record，马上返回给调用者，状态为“上传中”。同时启动一个goroutine在后台执行上传操作，上传完成后再执行回调（callback）函数来更新MySQL record的url字段。</li></ul><p>这两种方式的优劣非常明显。同步上传很容易实现且出错了很容易处理（要么立刻重试，要么放弃），但是需要调用者在调用AddPhoto后长时间等待（取决于网速/COS的速度/COS的稳定性）；异步上传则比较复杂，涉及组件间的通信（回调），但是API返回速度快，调用者无需等待图片上传。</p><p>再结合业务层面想一想哪种方式比较好。当一个用户点击新增图片后，是让用户在当前页面等3~5秒钟，当前页面不断转圈圈等待返回？还是让用户马上返回，在页面的某处显示一个进度框提示上传状态比较好？</p><p>显然，异步上传比同步上传更加“人性化”，所以我们就来借助<code>Redis</code>和goroutine实现异步上传。</p><p>具体的设计如下图所示：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-async-upload.png" alt=""></p><p><strong>Note: 在第4步启动后台goroutine后，并不需要等待4.1和4.2完成才执行第5步。而是启动了后台goroutine后马上就能返回给用户（5 &amp; 6），goroutine会在后台完成4.1和4.2步，不存在阻塞等待的过程。</strong></p><p>基于以上的设计，在代码层面我们要实现：</p><ol><li>callback监听模块（时刻监听着<code>Redis</code>里的某个channel，监听到新消息后立即更新MySQL）</li><li>往COS上传图片的方法</li><li>新建goroutine，调用上传图片的方法</li></ol><p>首先实现callback监听模块。在<code>gin-photo-storage/constant/constant.go</code>里先加上几个常量。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Callback constants</span></span><br><span class="line">URL_UPDATE_CHANNEL = <span class="string">"PHOTO_URL_UPDATE"</span></span><br><span class="line">PHOTO_UPDATE_ID_FORMAT = <span class="string">"photo-%d"</span></span><br><span class="line">PHOTO_DELETE_CHANNEL = <span class="string">"PHOTO_DELETE"</span></span><br></pre></td></tr></table></figure><p>因为callback主要是针对MySQL做更新操作，所以把逻辑写在<code>db.go</code>里。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在db.go里补充以下代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Init the database connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">go</span> ListenRedisCallback()<span class="comment">// launch a background goroutine to listen to callbacks from redis</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen to callback messages from redis channels.</span></span><br><span class="line"><span class="comment">// 1. When a photo is uploaded successfully, the callback asks to update the photo url in the db.</span></span><br><span class="line"><span class="comment">// 2. When it fails to upload a photo, the callback asks to delete the photo record in the db.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenRedisCallback</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait until utils package is initialized</span></span><br><span class="line">&lt;- utils.InitComplete</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe redis channels</span></span><br><span class="line">updateChan := utils.RedisClient.Subscribe(constant.URL_UPDATE_CHANNEL).Channel()</span><br><span class="line">deleteChan := utils.RedisClient.Subscribe(constant.PHOTO_DELETE_CHANNEL).Channel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// loop and listen</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-updateChan:</span><br><span class="line">photoID, _ := strconv.Atoi(msg.Payload[:strings.Index(msg.Payload, <span class="string">"-"</span>)])</span><br><span class="line">photoUrl := msg.Payload[strings.Index(msg.Payload, <span class="string">"-"</span>) + <span class="number">1</span>:]</span><br><span class="line"><span class="keyword">if</span> err := UpdatePhotoUrl(<span class="keyword">uint</span>(photoID), photoUrl); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">utils.SetUploadStatus(fmt.Sprintf(constant.PHOTO_UPDATE_ID_FORMAT, photoID), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;- deleteChan:</span><br><span class="line">photoID, _ := strconv.Atoi(msg.Payload)</span><br><span class="line"><span class="keyword">if</span> err := DeletePhotoByID(<span class="keyword">uint</span>(photoID)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">utils.SetUploadStatus(fmt.Sprintf(constant.PHOTO_UPDATE_ID_FORMAT, photoID), <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的核心在于，当<code>db.go</code>所属的package（<code>models</code>）被加载时，在<code>Init()</code>方法的最后会启动一个后台goroutine，该goroutine实际上就是一个无限的for循环，订阅了<code>Redis</code>里的更新图片url的channel、删除图片的channel，即一直保持监听。在channel里接收到新消息后，就去执行“更新MySQL里的图片url”或者“删除图片”。</p><p>接着利用<code>COS utils</code>实现上传图片，即在<code>cos.go</code>里实现<code>Upload()</code>和<code>AsyncUpload()</code>。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码在cos.go里实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// upload a photo to the tencent cloud COS</span></span><br><span class="line"><span class="comment">// @photoID: 图片id</span></span><br><span class="line"><span class="comment">// @fileName: 图片名</span></span><br><span class="line"><span class="comment">// @file: 图片句柄</span></span><br><span class="line"><span class="comment">// @fileSize: 图片大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(photoID <span class="keyword">uint</span>, fileName <span class="keyword">string</span>, file io.Reader, fileSize <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">uploadID := fmt.Sprintf(constant.PHOTO_UPDATE_ID_FORMAT, photoID)</span><br><span class="line"><span class="keyword">go</span> AsyncUpload(uploadID, photoID, fileName, file, fileSize)<span class="comment">// upload in the ASYNC way</span></span><br><span class="line"><span class="keyword">return</span> uploadID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upload a photo to the tencent cloud COS in the ASYNC way</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsyncUpload</span><span class="params">(uploadID <span class="keyword">string</span>, photoID <span class="keyword">uint</span>, fileName <span class="keyword">string</span>, file io.Reader, fileSize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// set upload status in redis</span></span><br><span class="line"><span class="keyword">if</span> !SetUploadStatus(uploadID, <span class="number">1</span>) &#123;</span><br><span class="line">log.Println(<span class="string">"Fail to set upload status before upload."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upload the photo using COS SDK</span></span><br><span class="line">putOption := cos.ObjectPutOptions&#123;&#125;</span><br><span class="line">putOption.ObjectPutHeaderOptions = &amp;cos.ObjectPutHeaderOptions&#123;ContentLength: fileSize&#125;</span><br><span class="line">_, err := CosClient.Object.Put(context.Background(), fileName, file, &amp;putOption)</span><br><span class="line"></span><br><span class="line"><span class="comment">// upload fails, send callback asking for photo deletion</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">if</span> !SendToChannel(constant.PHOTO_DELETE_CHANNEL, fmt.Sprintf(<span class="string">"%d"</span>, photoID)) &#123;</span><br><span class="line">log.Println(<span class="string">"Fail to send delete-photo message to channel"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// upload success, send callback asking for updating the photo url</span></span><br><span class="line">fileUrl := fmt.Sprintf(CosUrlFormat, BucketName, AppID, Region) + <span class="string">"/"</span> + fileName</span><br><span class="line">updateUrlMessage := fmt.Sprintf(<span class="string">"%d-%s"</span>, photoID, fileUrl)</span><br><span class="line"><span class="keyword">if</span> !SendToChannel(constant.URL_UPDATE_CHANNEL, updateUrlMessage) &#123;</span><br><span class="line">log.Println(<span class="string">"Fail to send update-photo-url message to channel"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>在<code>Upload()</code>里直接另起了一个goroutine来执行<code>AsyncUpload()</code>，然后不需要等上传完成就马上返回了，所以才能达到“异步”的效果。</strong>当<code>AsyncUpload()</code>里完成了图片上传，上传成功就往<code>Redis</code>里面的<code>URL_UPDATE_CHANNEL</code>里发消息，失败就往<code>PHOTO_DELETE_CHANNEL</code>里发消息，该消息会被我们上面实现的callback模块监听到，由callback来执行后面的更新或删除逻辑。</p><p>最后，因为上一篇教程里在<code>AddPhoto()</code>里没有上传图片的代码，所以别忘了在<code>AddPhoto()</code>里加上调用图片上传的代码。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码在photo.go里实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new photo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddPhoto</span><span class="params">(photoToAdd *Photo, photoFileHeader *multipart.FileHeader)</span> <span class="params">(*Photo, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// upload to the tencent cloud COS</span></span><br><span class="line"><span class="keyword">if</span> photoFile, err := photoFileHeader.Open(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">uploadID := utils.Upload(photo.ID, photo.Name, bufio.NewReader(photoFile), <span class="keyword">int</span>(photoFileHeader.Size))</span><br><span class="line"><span class="keyword">return</span> &amp;photo, uploadID, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span>, PhotoFileBrokenError</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>本篇教程到这里，<code>Redis utils</code>、<code>COS utils</code>和图片异步上传已经全部实现了。可能有的读者会觉得怪怪的，如果我们用异步的方式上传图片，调用者确实不需要等待，马上能得到一个“上传中”的response，但它要怎么知道上传到底有没有完成，还有是什么时候完成的呢？</p><p>注意看<code>AsyncUpload()</code>和<code>ListenRedisCallback()</code>里，都有执行<code>SetUploadStatus()</code>。上传之前，都先把图片的upload status设成1。如果成功上传，在<code>ListenRedisCallback()</code>里会将其设为0；如果上传失败，<code>ListenRedisCallback()</code>里会将其设为-1。</p><p>再留意<code>redis.go</code>，我们还实现了一个<code>GetUploadStatus()</code>，通过这个接口，就可以查询某张图片的上传状态。从前端实现的角度而言，想要知道图片上传成功与否，每隔N秒调用一下这个接口，询问上传状态即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>这里把<code>Redis</code>当做伪消息队列来用，利用的是它的pub-sub机制，那么pub-sub的底层是怎么实现的？</p><ul><li>关键词：<code>Redis</code>源码、订阅发布</li></ul></li><li><p>用真正的消息队列组件来实现通知，如RocketMQ、Kafka等，高并发下可能会有什么问题？</p><ul><li>关键词：消息队列、exactly once、幂等操作</li></ul></li><li><p>在<code>redis.go</code>里，<code>InitComplete = make(chan struct{}, 1)</code>，为什么要加一个size参数1？不加size参数会生成什么样的channel？他们有什么异同？</p><ul><li>关键词：Golang缓冲通道、阻塞</li></ul></li><li><p>异步加载看起来很“先进”，不需要阻塞等待，但是潜在的风险也不少。如果一个接口不止对应一个异步操作（例如不只是上传，可能包括了10个独立的异步操作），那假如其中一个操作失败了，怎么处理这个失败？是应该不断重试？还是应该全部步骤都回滚？假如说3号步骤失败了，怎么通知1、2、4~10号步骤都回滚？</p><ul><li>关键词：失败补偿、异步操作</li></ul></li><li><p>异步上传的核心，除了通过<code>Redis</code>做消息传递实现回调外，更重要的是goroutine不会让当前线程阻塞，自己在后台就能执行逻辑。goroutine看着很像Java、Python、C++里的Thread，那goroutine和其他语言里的线程有什么异同，和内核态的线程又是什么关系？</p><ul><li>关键词：goroutine、协程、线程</li></ul></li><li><p>我们实现的上传逻辑，是让调用者先把一张图片的数据全部post到服务端，然后再从服务器上传到腾讯云COS的。这样无疑很浪费服务器的带宽，假如一张图片5MB，要从客户端接收5MB，再往COS发送5MB，高并发下绝对带宽不足，有什么方法可以改进吗？</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/02/28，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-2]数据库与Models实现</title>
    <link href="http://yoursite.com/2019/02/25/gin-tutorial-2/"/>
    <id>http://yoursite.com/2019/02/25/gin-tutorial-2/</id>
    <published>2019-02-25T23:45:00.000Z</published>
    <updated>2019-03-10T05:07:37.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/02/25，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第二篇，更多后续请继续关注。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在上一篇教程<a href="https://marcoma.xyz/2019/02/23/gin-tutorial-1/" target="_blank" rel="noopener">《[Gin教程-1]photo gallery项目》</a>里，我们已经完成了：</p><ul><li>配置文件 &amp; 配置解析</li><li>常量定义</li><li><code>JWT</code>的实现</li></ul><p>本篇将要开始真正的“业务开发”，讲讲数据库表的定义和对应model的实现。</p><h2 id="组件-amp-技术"><a href="#组件-amp-技术" class="headerlink" title="组件&amp;技术"></a>组件&amp;技术</h2><p>数据库我们用的是<code>MySQL 5.7</code>，ORM框架用的是<code>gorm</code>。</p><p>为什么我们用<code>MySQL</code>呢？其实真正要用的是“关系型数据库”，因为我们的业务非常适合用关系型数据库来实现。粗略想一想，我们做的是图片存储库，大概要存这么些东西：</p><ul><li>用户信息</li><li>图片所属的bucket数据</li><li>图片本身的数据</li><li>……</li></ul><p>不难想到，在业务逻辑层面，<strong>一个用户可以创建多个bucket，一个bucket里可以存多张图片，这就形成了“关系”，所以用关系型数据库是没错的。</strong>不过，本项目用的是<code>MySQL</code>，用别的关系型数据库如<code>MariaDB</code>、<code>PostgreSQL</code>、<code>Microsoft Sql Server</code>也并无太大差别。（它们本身的差别还是不小的，但是在本项目的业务层面没什么差别）</p><p>至于为什么要用<code>gorm</code>呢？其实Golang的ORM框架还是有不少的，具体ORM框架之间的对比文章也有很多，本项目选择<code>gorm</code>一是因为<code>EDDYCJY</code>的教程中是用的<code>gorm</code>，二是自己一路用下来确实觉得还不错，所以就继续沿用<code>gorm</code>了。如果读者有别的用习惯了的ORM框架，例如<code>beego orm</code>或者<code>xorm</code>，也可以自行替换，应该不会出什么问题。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><p>E-R图定义</p><p> E-R图，就是实体关系图。为什么要在定义数据库表之前先画好E-R图呢？一是为了帮自己理清楚各个实体之间的关系，二是为了规范开发流程，以后有据可循。如果是团队合作，定义数据库表之前不画好E-R图，之后在开发过程中很可能出一大堆幺蛾子。</p><p> 基于我们对“图片存储库”的业务描述，系统里的实体目前就是3个：</p><ul><li>用户，一个用户可以有多个bucket</li><li>bucket，一个bucket可以存多张图片</li><li><p>图片，一张图片只能属于一个用户</p><p>对应的E-R图如下：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/gin-tutorial-er-diagram.png" alt=""></p></li></ul></li><li><p>数据库表定义</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> photo_gallery;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> photo_gallery;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> auth;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> auth</span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">user_name <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">unique</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">email <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">created_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updated_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># bucket表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> bucket;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bucket</span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">auth_id <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">state tinyint(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line"><span class="keyword">size</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">description <span class="built_in">text</span>,</span><br><span class="line">created_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updated_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> UC_bucket <span class="keyword">UNIQUE</span>(auth_id, <span class="keyword">name</span>),</span><br><span class="line"><span class="keyword">INDEX</span> idx_aid_name (auth_id, <span class="keyword">name</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> photo;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> photo</span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">bucket_id <span class="built_in">int</span>,</span><br><span class="line">auth_id <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">tag <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">url</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">description <span class="built_in">text</span>,</span><br><span class="line">state tinyint(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line">created_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">updated_at <span class="built_in">timestamp</span> <span class="keyword">default</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">constraint</span> UC_photo <span class="keyword">UNIQUE</span>(bucket_id, <span class="keyword">name</span>),</span><br><span class="line"><span class="keyword">INDEX</span> idx_bid_name (bucket_id, <span class="keyword">name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> 除了E-R图里标注的属性外，每个实体对应的表里都有共同的属性：<code>created_at</code>和<code>updated_at</code>，这是为了debug的时候更加方便地看到数据修改时间，一般都建议带上这两个字段。</p></li><li><p>实现数据库连接</p><p> 定义完了数据库表，我们可以用Golang实现一个数据库连接，开始和数据库进行交互。先在项目路径下新建<code>models</code>文件夹，然后在<code>models</code>下新建<code>db.go</code>文件。</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— server.conf</span><br><span class="line"> |—— cfg.go</span><br><span class="line">|—— constant</span><br><span class="line">|—— constant.go</span><br><span class="line">|—— resp_code.go</span><br><span class="line">|—— utils</span><br><span class="line">|—— jwt.go</span><br><span class="line">|—— models</span><br><span class="line">|—— db.go</span><br></pre></td></tr></table></figure><p> 在<code>db.go</code>里，我们要</p><ul><li>读取数据库配置，如<code>Host</code>、<code>User</code>、<code>Password</code>等……</li><li><p>根据配置建立起一个全局的连接，可供其他模块使用</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"gin-photo-storage/utils"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span><span class="comment">// remember to import mysql driver</span></span><br><span class="line"><span class="string">"github.com/jinzhu/gorm"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init the database connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">dbType := conf.ServerCfg.Get(constant.DB_TYPE)</span><br><span class="line">dbHost := conf.ServerCfg.Get(constant.DB_HOST)</span><br><span class="line">dbPort := conf.ServerCfg.Get(constant.DB_PORT)</span><br><span class="line">dbUser := conf.ServerCfg.Get(constant.DB_USER)</span><br><span class="line">dbPwd := conf.ServerCfg.Get(constant.DB_PWD)</span><br><span class="line">dbName := conf.ServerCfg.Get(constant.DB_NAME)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">db, err = gorm.Open(dbType, fmt.Sprintf(constant.DB_CONNECT, dbUser, dbPwd, dbHost, dbPort, dbName))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">"Fail to connect database!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> !db.HasTable(&amp;Auth&#123;&#125;) &#123;</span><br><span class="line">db.CreateTable(&amp;Auth&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !db.HasTable(&amp;Bucket&#123;&#125;) &#123;</span><br><span class="line">db.CreateTable(&amp;Bucket&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !db.HasTable(&amp;Photo&#123;&#125;) &#123;</span><br><span class="line">db.CreateTable(&amp;Photo&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️Note：记得要先安装mysql的Golang驱动：<code>github.com/go-sql-driver/mysql</code></strong>。</p></li></ul></li></ol><h2 id="Model定义"><a href="#Model定义" class="headerlink" title="Model定义"></a>Model定义</h2><p>有了数据库表之后，每张表可以对应来实现一个Model，即<code>Auth</code>、<code>Bucket</code>、<code>Photo</code>。由于多个Model都有一些共同的属性可以抽象出来，如<code>id</code>、<code>created_at</code>、<code>updated_at</code>这种大家都有的，就没必要重复在每个结构体内都定义一遍。所以我们要定义一个包含共同属性的Model：<code>BaseModel</code>。</p><p>先在<code>models</code>下新建<code>auth.go</code>、<code>bucket.go</code>、<code>photo.go</code>三个代码文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— server.conf</span><br><span class="line"> |—— cfg.go</span><br><span class="line">|—— constant</span><br><span class="line">|—— constant.go</span><br><span class="line">|—— resp_code.go</span><br><span class="line">|—— utils</span><br><span class="line">|—— jwt.go</span><br><span class="line">|—— models</span><br><span class="line">|—— auth.go</span><br><span class="line">|—— bucket.go</span><br><span class="line">|—— db.go </span><br><span class="line">|—— photo.go</span><br></pre></td></tr></table></figure><p>然后先在<code>db.go</code>里实现上面提到的<code>BaseModel</code>，之后再逐个实现<code>Auth</code>、<code>Bucket</code>、<code>Photo</code>。</p><ol><li><p>BaseModel</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在db.go里实现</span></span><br><span class="line"><span class="comment">// The base model of all models, including ID &amp; CreatedAt &amp; UpdatedAt.</span></span><br><span class="line"><span class="keyword">type</span> BaseModel <span class="keyword">struct</span> &#123;</span><br><span class="line">ID <span class="keyword">uint</span> <span class="string">`json:"id" gorm:"primary_key;AUTO_INCREMENT" form:"id"`</span></span><br><span class="line">CreatedAt time.Time <span class="string">`json:"created_at" gorm:"default: CURRENT_TIMESTAMP" form:"created_at"`</span></span><br><span class="line">UpdatedAt time.Time <span class="string">`json:"updated_at" gorm:"default: CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP" form:"updated_at"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其实，<code>gorm</code>的开发者也想到了这种抽象出共同属性的Model，所以框架里早已定义好了<code>gorm.Model</code>结构体，包含了<code>ID</code>、<code>CreatedAt</code>、<code>UpdatedAt</code>、<code>DeletedAt</code>。但是在这里我们不需要<code>DeletedAt</code>字段，所以就没有直接用它提供的Model，而是自行定义。</p></li><li><p>Auth</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在auth.go里实现</span></span><br><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/md5"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Auth <span class="keyword">struct</span> &#123;</span><br><span class="line">BaseModel</span><br><span class="line">UserName <span class="keyword">string</span> <span class="string">`json:"user_name" gorm:"type:varchar(16)"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`json:"password" gorm:"type:varchar(16)"`</span></span><br><span class="line">Email <span class="keyword">string</span> <span class="string">`json:"email" gorm:"type:varchar(128)"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AuthExistsError = errors.New(<span class="string">"auth already exists"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new auth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddAuth</span><span class="params">(username, password, email <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">auth := Auth&#123;&#125;</span><br><span class="line">trx.Set(<span class="string">"gorm:query_option"</span>, <span class="string">"FOR UPDATE"</span>).</span><br><span class="line">Where(<span class="string">"user_name = ?"</span>, username).</span><br><span class="line">First(&amp;auth)</span><br><span class="line"><span class="keyword">if</span> auth.ID &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> AuthExistsError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hash := md5.New()</span><br><span class="line">io.WriteString(hash, password)<span class="comment">// for safety, don't just save the plain text</span></span><br><span class="line">auth.UserName = username</span><br><span class="line">auth.Password = fmt.Sprintf(<span class="string">"%x"</span>, hash.Sum(<span class="literal">nil</span>))</span><br><span class="line">auth.Email = email</span><br><span class="line">err := trx.Create(&amp;auth).Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if the auth is valid.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckAuth</span><span class="params">(username, password <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">hash := md5.New()</span><br><span class="line">io.WriteString(hash, password)</span><br><span class="line">password = fmt.Sprintf(<span class="string">"%x"</span>, hash.Sum(<span class="literal">nil</span>))<span class="comment">//for safety, don't just save the plain text</span></span><br><span class="line">auth := Auth&#123;&#125;</span><br><span class="line">trx.Set(<span class="string">"gorm:query_option"</span>, <span class="string">"FOR UPDATE"</span>).</span><br><span class="line">Where(<span class="string">"user_name = ? AND password = ?"</span>, username, password).</span><br><span class="line">First(&amp;auth)</span><br><span class="line"><span class="keyword">if</span> auth.ID &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Auth里需要注意的是，注册时<strong>不能存明文密码</strong>，登陆校验时也不能直接用明文校验，需要用<code>md5</code>加一层壳，这在一定程度上能防止后端数据库被一锅端导致的密码泄露。</p></li><li><p>Bucket</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在bucket.go里实现</span></span><br><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The bucket model.</span></span><br><span class="line"><span class="keyword">type</span> Bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">BaseModel</span><br><span class="line">AuthID <span class="keyword">uint</span><span class="string">`json:"auth_id" gorm:"type:int" form:"auth_id"`</span></span><br><span class="line">Name <span class="keyword">string</span><span class="string">`json:"bucket_name" gorm:"type:varchar(64)" form:"bucket_name"`</span></span><br><span class="line">State <span class="keyword">int</span><span class="string">`json:"state" gorm:"type:tinyint(1)" form:"state"`</span></span><br><span class="line">Size <span class="keyword">int</span><span class="string">`json:"size" gorm:"type:int" form:"bucket_size"`</span></span><br><span class="line">Description <span class="keyword">string</span><span class="string">`json:"description" gorm:"type:text" form:"description"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BucketExistsError = errors.New(<span class="string">"bucket already exists"</span>)</span><br><span class="line"><span class="keyword">var</span> NoSuchBucketError = errors.New(<span class="string">"no such bucket"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddBucket</span><span class="params">(bucketToAdd *Bucket)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the bucket exists, select with a WRITE LOCK.</span></span><br><span class="line">bucket := Bucket&#123;&#125;</span><br><span class="line">trx.Set(<span class="string">"gorm:query_option"</span>, <span class="string">"FOR UPDATE"</span>).</span><br><span class="line">Where(<span class="string">"auth_id = ? AND name = ? AND state = ?"</span>, bucketToAdd.AuthID, bucketToAdd.Name, <span class="number">1</span>).</span><br><span class="line">First(&amp;bucket)</span><br><span class="line"><span class="keyword">if</span> bucket.ID &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BucketExistsError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bucket.AuthID = bucketToAdd.AuthID</span><br><span class="line">bucket.Name = bucketToAdd.Name</span><br><span class="line">bucket.State = <span class="number">1</span></span><br><span class="line">bucket.Size = <span class="number">0</span></span><br><span class="line">bucket.Description = bucketToAdd.Description</span><br><span class="line"><span class="keyword">if</span> err := trx.Create(&amp;bucket).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete an existed bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteBucket</span><span class="params">(bucketID <span class="keyword">uint</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">result := trx.Where(<span class="string">"id = ? and state = ?"</span>, bucketID, <span class="number">1</span>).Delete(Bucket&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := result.Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> affected := result.RowsAffected; affected == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> NoSuchBucketError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update an existed bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateBucket</span><span class="params">(bucketToUpdate *Bucket)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">bucket := Bucket&#123;&#125;</span><br><span class="line">bucket.ID = bucketToUpdate.ID</span><br><span class="line">result := trx.Model(&amp;bucket).Updates(*bucketToUpdate)</span><br><span class="line"><span class="keyword">if</span> err := result.Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> affected := result.RowsAffected; affected == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> NoSuchBucketError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a bucket by bucket id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBucketByID</span><span class="params">(bucketID <span class="keyword">uint</span>)</span> <span class="params">(Bucket, error)</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">bucket := Bucket&#123;&#125;</span><br><span class="line">found := NoSuchBucketError</span><br><span class="line">trx.Where(<span class="string">"id = ?"</span>, bucketID).First(&amp;bucket)</span><br><span class="line"><span class="keyword">if</span> bucket.ID &gt; <span class="number">0</span> &#123;</span><br><span class="line">found = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bucket, found</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all buckets of the given user.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBucketByAuthID</span><span class="params">(authID <span class="keyword">uint</span>, offset <span class="keyword">int</span>)</span> <span class="params">([]Bucket, error)</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">buckets := <span class="built_in">make</span>([]Bucket, <span class="number">0</span>, constant.PAGE_SIZE)</span><br><span class="line">err := trx.Where(<span class="string">"auth_id = ?"</span>, authID).</span><br><span class="line">Offset(offset).</span><br><span class="line">Limit(constant.PAGE_SIZE).</span><br><span class="line">Find(&amp;buckets).Error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> buckets, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buckets, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 同样地，定义了Bucket结构体外，还定义了对它增/删/改/查的接口。</p></li><li><p>Photo</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在photo.go里实现</span></span><br><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"gin-photo-storage/utils"</span></span><br><span class="line"><span class="string">"github.com/jinzhu/gorm"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"mime/multipart"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NoSuchPhotoError = errors.New(<span class="string">"no such photo"</span>)</span><br><span class="line"><span class="keyword">var</span> PhotoExistsError = errors.New(<span class="string">"photo already exists"</span>)</span><br><span class="line"><span class="keyword">var</span> PhotoFileBrokenError = errors.New(<span class="string">"photo file is broken"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The photo model.</span></span><br><span class="line"><span class="keyword">type</span> Photo <span class="keyword">struct</span> &#123;</span><br><span class="line">BaseModel</span><br><span class="line">AuthID <span class="keyword">uint</span><span class="string">`json:"auth_id" gorm:"type:int" form:"auth_id"`</span></span><br><span class="line">BucketID <span class="keyword">uint</span><span class="string">`json:"bucket_id" gorm:"type:int" form:"bucket_id"`</span></span><br><span class="line">Name <span class="keyword">string</span><span class="string">`json:"name" gorm:"type:varchar(255)" form:"name"`</span></span><br><span class="line">Tag <span class="keyword">string</span><span class="string">`json:"tag" gorm:"type:varchar(255)" form:"tag"`</span></span><br><span class="line">Tags []<span class="keyword">string</span><span class="string">`json:"tags" gorm:"-" form:"tags"`</span></span><br><span class="line">Url <span class="keyword">string</span><span class="string">`json:"url" gorm:"type:varchar(255)" form:"url"`</span></span><br><span class="line">Description <span class="keyword">string</span><span class="string">`json:"description" gorm:"type:text" form:"description"`</span></span><br><span class="line">State <span class="keyword">int</span> <span class="string">`json:"state" gorm:"type:tinyint(1)" form:"state"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a new photo</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddPhoto</span><span class="params">(photoToAdd *Photo, photoFileHeader *multipart.FileHeader)</span> <span class="params">(*Photo, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if the photo exists, select with a WRITE LOCK</span></span><br><span class="line">photo := Photo&#123;&#125;</span><br><span class="line">trx.Set(<span class="string">"gorm:query_option"</span>, <span class="string">"FOR UPDATE"</span>).</span><br><span class="line">Where(<span class="string">"bucket_id = ? AND name = ?"</span>, photoToAdd.BucketID, photoToAdd.Name).</span><br><span class="line">First(&amp;photo)</span><br><span class="line"><span class="keyword">if</span> photo.ID &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span>, PhotoExistsError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">photo.AuthID = photoToAdd.AuthID</span><br><span class="line">photo.BucketID = photoToAdd.BucketID</span><br><span class="line">photo.Name = photoToAdd.Name</span><br><span class="line">photo.Tag = photoToAdd.Tag</span><br><span class="line">photo.Description = photoToAdd.Description</span><br><span class="line">photo.State = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">err := trx.Create(&amp;photo).Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = trx.Model(&amp;Bucket&#123;&#125;).Where(<span class="string">"id = ?"</span>, photoToAdd.BucketID).</span><br><span class="line">Update(<span class="string">"size"</span>, gorm.Expr(<span class="string">"size + ?"</span>, <span class="number">1</span>)).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">trx.Rollback()</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> upload to the tencent cloud COS</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete a photo by photo id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeletePhotoByID</span><span class="params">(photoID <span class="keyword">uint</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">result := trx.Where(<span class="string">"id = ? AND state = ?"</span>, photoID, <span class="number">1</span>).Delete(Photo&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := result.Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> affected := result.RowsAffected; affected == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> NoSuchPhotoError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete a photo by its bucket id &amp; its name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeletePhotoByBucketAndName</span><span class="params">(bucketID <span class="keyword">uint</span>, name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">result := trx.Where(<span class="string">"bucket_id = ? AND name = ?"</span>, bucketID, name).Delete(Photo&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err := result.Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> affected := result.RowsAffected; affected == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> NoSuchPhotoError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update a photo.</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">UpdatePhoto</span><span class="params">(photoToUpdate *Photo)</span> <span class="params">(*Photo, error)</span></span> &#123;</span><br><span class="line">   trx := db.Begin()</span><br><span class="line">   <span class="keyword">defer</span> trx.Commit()</span><br><span class="line">   </span><br><span class="line">   photo := Photo&#123;&#125;</span><br><span class="line">   photo.ID = photoToUpdate.ID</span><br><span class="line">   </span><br><span class="line">   result := trx.Model(&amp;photo).Updates(*photoToUpdate)</span><br><span class="line">   <span class="keyword">if</span> err := result.Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">   log.Println(err)</span><br><span class="line">   <span class="keyword">return</span> &amp;photo, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> affected := result.RowsAffected; affected == <span class="number">0</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;photo, NoSuchPhotoError</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &amp;photo, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the url for a photo.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdatePhotoUrl</span><span class="params">(photoID <span class="keyword">uint</span>, url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">photo := Photo&#123;&#125;</span><br><span class="line">       photo.ID = photoID</span><br><span class="line">err := trx.Model(&amp;photo).Update(<span class="string">"url"</span>, url).Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a photo by its photo id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPhotoByID</span><span class="params">(photoID <span class="keyword">uint</span>)</span> <span class="params">(*Photo, error)</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">photo := Photo&#123;&#125;</span><br><span class="line">err := trx.Where(<span class="string">"id = ?"</span>, photoID).First(&amp;photo).Error</span><br><span class="line">found := NoSuchPhotoError</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> || photo.ID == <span class="number">0</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">found = err</span><br><span class="line">&#125;</span><br><span class="line">found = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> &amp;photo, found</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get photos by bucket id.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPhotoByBucketID</span><span class="params">(bucketID <span class="keyword">uint</span>, offset <span class="keyword">int</span>)</span> <span class="params">([]Photo, error)</span></span> &#123;</span><br><span class="line">trx := db.Begin()</span><br><span class="line"><span class="keyword">defer</span> trx.Commit()</span><br><span class="line"></span><br><span class="line">photos := <span class="built_in">make</span>([]Photo, <span class="number">0</span>, constant.PAGE_SIZE)</span><br><span class="line">err := trx.Where(<span class="string">"bucket_id = ?"</span>, bucketID).</span><br><span class="line">Offset(offset).</span><br><span class="line">Limit(constant.PAGE_SIZE).</span><br><span class="line">Find(&amp;photos).</span><br><span class="line">Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> photos, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> photos, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里要提出三个问题：</p><ol><li><strong>⚠️<code>AddPhoto</code>里的逻辑并未完善，现在只是往数据库加了一行图片记录，但是还未把图片真正地存下来（上传至云存储）。在下一篇会重点实现这个需求。</strong></li><li>读者们应该也能发现，在每个Model结构体的每个字段后面，都会跟着一串“标签”（struct tag），标签里面有<code>json</code>，有<code>gorm</code>，有<code>form</code>。简单来说，标签就是用来标注字段的“别名”或者标注字段属性的。<code>json</code>标签就是在JSON序列化/反序列化过程中用的，<code>gorm</code>标签就是<code>gorm</code>框架使用的，<code>form</code>标签也是<code>gorm</code>框架在绑定请求参数的时候用的。通常，字段的标签会在反射中大量被用到。</li><li>在大项目的开发中，增/删/改/查的接口远远不止这么点，根据业务需求还可以有很多针对特定条件的增/删/改/查接口。具体的接口实现要和你的业务上下游做好对接，例如搞清楚前端需要什么样的数据，或者搞清楚在整个pipeline中你的业务下游需要什么样的数据。</li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思考点：</p><ul><li><p>在多个Add和Update的接口中，入参都是指针类型，而不是常见的值类型，为什么？</p><ul><li>关键词：Golang指针、值复制、节省内存</li></ul></li><li><p>Golang的结构体标签（struct tag）怎么用？</p><ul><li>关键词：struct tag、反射</li></ul></li><li><p>在<code>bucket</code>表里定义了size属性，意味着每次添加图片都要更新bucket size字段。假如把场景扩大，不局限于bucket size，而是一个什么size，在高并发下频繁更新MySQL表里的size字段，性能好吗？如果用缓存存一下，然后再异步落盘到MySQL可以吗？异步落盘可能带来什么问题？</p><ul><li>关键词：缓存、高并发、缓存一致性</li></ul></li><li><p>用ORM框架有什么好处？ORM框架可能带来什么问题？</p></li><li><p>数据库表为什么要加索引？索引的原理是什么？</p><ul><li>关键词：InnoDB索引、B+树</li></ul></li><li><p>关系型数据库是不是万能？在什么场景下不好用？</p><ul><li>关键词：全文检索、模糊搜索、OLAP</li></ul></li><li><p>为什么把数据库表对应的结构体叫作<code>Model</code>？</p><ul><li>关键词：MVC模式</li></ul></li><li><p>为什么在一些sql查询里要加上<code>FOR UPDATE</code>？</p><ul><li>关键词：InnoDB锁机制、并发安全、读写锁</li></ul></li><li><p>为什么在所有的查询里，都启动一个事务（<code>trx := db.Begin()</code>）来执行操作？不用事务，直接查询有什么问题吗？</p><ul><li>关键词：数据库事务，ACID</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/02/25，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Gin教程-1]photo gallery项目</title>
    <link href="http://yoursite.com/2019/02/23/gin-tutorial-1/"/>
    <id>http://yoursite.com/2019/02/23/gin-tutorial-1/</id>
    <published>2019-02-23T23:45:00.000Z</published>
    <updated>2019-03-04T07:06:17.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/02/23，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p><p>本文为[Gin-教程]连载系列的第一篇，更多后续请继续关注。</p></blockquote><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>作为一个Golang新手，受Github上<code>EDDYCJY</code>的<code>gin</code>教程（<a href="https://github.com/EDDYCJY/blog" target="_blank" rel="noopener">EDDYCJY/blog</a>）影响，一路跟着用<code>gin</code>做了一个练手小项目。本着得益之后回馈初学者的精神，决定模仿<code>EDDYCJY</code>的教程，也写写基于<code>gin</code>的后端项目教程，有的地方类似，但也有很多不相同的地方。</p><p>本项目没有选取“博客”、“商城”、“音乐播放器”等热门的练手题材，而是要做一个“photo gallery”，也就是在线的图片存储库。<strong>由于本人前端知识的极度匮乏（几乎没写过），所以本项目和对应的教程里将不会涉及任何前端的开发。</strong>但是有前端基础的读者，可以结合本系列教程的后端代码，适当改造一下，再实现前端页面，最终也能做出一个完整的可展示的系统。</p><p><strong>同时，必须强调，本系列教程的目标受众是Golang初学者/gin初学者/后端开发初学者，有一些在特大系统里要特别注意的问题无法在教程里详细实现。例如“失败补偿”，“熔断/限流”，“高可用”，“分布式”，“弹性扩容”等，在本系列教程里基本不予考虑，但是会以思考题的形式提出，引导读者思考。</strong></p><p>本项目用到的技能/工具大致如下</p><ul><li><p>Golang</p><ul><li><code>gin</code></li><li><code>zap</code></li></ul></li><li>MySQL &amp; <code>gorm</code></li><li>Redis &amp; <code>go-redis</code></li><li>Elasticsearch</li><li>Nginx</li><li>Docker</li><li>腾讯云对象存储</li></ul><p>本系列教程大致分为10篇</p><ol><li><em>配置文件 + 常量定义 + JWT实现</em></li><li><em>Models定义与数据库</em></li><li><em>API开发-1</em></li><li><em>API开发-2与中间件使用</em></li><li><em>API开发-3</em></li><li><em>增加Elasticsearch支持全文检索</em></li><li><em>用zap替代默认日志库</em></li><li><em>协同开发之引入swagger文档</em></li><li><em>本地https证书搭建 + Nginx部署</em></li><li><em>使用docker隔离服务</em></li></ol><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul><li><p>新建项目</p><ul><li>Golang版本 &lt;= 1.10，建议直接把项目根目录创在<code>$GOPATH/src</code>下</li><li>Golang版本 &gt;= 1.11，可以放在本地任意位置，<strong>用go mod来管理第三方package</strong></li></ul></li><li><p>目录结构</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Golang version &lt;= 1.10</span><br><span class="line">$GOPATH</span><br><span class="line">|—— src</span><br><span class="line">|—— gin-photo-storage</span><br><span class="line">|—— ...</span><br><span class="line">|—— ...</span><br><span class="line">|—— ...</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Golang version &gt;= 1.11</span><br><span class="line">Anywhere you like</span><br><span class="line">|—— gin-photo-storage</span><br><span class="line">|—— ...</span><br><span class="line">|—— ...</span><br><span class="line">|—— ...</span><br></pre></td></tr></table></figure><p>  对go mod感兴趣的可以去搜索Golang从低版本到高版本一路走来各种package管理的方式。</p></li></ul><h2 id="如何加载配置文件"><a href="#如何加载配置文件" class="headerlink" title="如何加载配置文件"></a>如何加载配置文件</h2><p>首先来看这么几个问题</p><ul><li><p>一个项目里是不是很多地方要用到配置项？</p><p>  通常来说，是的。一般项目越大，里面涉及的组件越多（关系型数据库、内存数据库、消息队列……），需要的配置项就越多。你要连数据库总得提供数据库地址&amp;用户名&amp;密码……你要从消息队列收发消息总得提供地址&amp;topic……这些全都是“配置项”。</p></li><li><p>配置项全部写在代码文件里好不好？</p><p>  既然项目里无处不存在“配置项”，那干脆在写业务代码的时候随手一写就好了。但是这样麻烦就大了，假如开发前期用的是开发环境的数据库，地址是<code>aaa.bbb.ccc.ddd</code>，到后期上测试了要换成测试环境的数据库，地址是<code>xxx.yyy.zzz.kkk</code>，那就要大幅修改N个代码文件，然后提交重新code review。类似的情况远远不止数据库，可以是各种存在多版本问题的配置项。</p></li><li><p>如果不写在代码文件里，应该写到哪里？</p><p>  很明显，如果不写在代码里（所谓的“hard code”），那就只能写在额外的“非代码”文件里，然后你的代码逻辑里有读配置文件的操作。每次要改配置项的值时，改配置文件即可，不需要再改一大堆代码文件。甚至可以为测试环境定义一个<code>config-test-env</code>文件，为开发环境定义一个<code>config-dev-env</code>文件，为任意环境定义它专属的配置文件，在程序启动时通过命令行参数指定用哪套环境，方便快捷，无痛切换。</p></li></ul><p>所以，整个项目的第一步，我们要新建配置目录<code>conf</code>、配置文件：<code>server.conf</code>、解析配置文件的代码<code>cfg.go</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— server.conf</span><br><span class="line"> |—— cfg.go</span><br></pre></td></tr></table></figure><p>在本项目里，直接把配置项写成JSON格式，易读易修改。当然也可以像<code>EDDYCJY</code>在<a href="https://github.com/EDDYCJY/blog/blob/master/golang/gin/2018-02-16-Gin%E5%AE%9E%E8%B7%B5-%E8%BF%9E%E8%BD%BD%E4%BA%8C-%E6%90%AD%E5%BB%BABlogAPIs-01.md" target="_blank" rel="noopener">（Gin搭建Blog API’s （一））</a>里那样，用<code>ini</code>作配置文件的格式，用<code>ini</code>对应的package来解析，这个倒是没有太大的讲究。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 以下为server.conf的内容</span><br><span class="line">&#123;</span><br><span class="line">    &quot;JWT_SECRET&quot;: &quot;ufqw923dh1nlo9sa&quot;,</span><br><span class="line">    &quot;DB_TYPE&quot;: &quot;mysql&quot;,</span><br><span class="line">    &quot;DB_HOST&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;DB_PORT&quot;: &quot;3306&quot;,</span><br><span class="line">    &quot;DB_USER&quot;: &quot;......&quot;,</span><br><span class="line">    &quot;DB_PWD&quot;: &quot;......&quot;,</span><br><span class="line">    &quot;DB_NAME&quot;: &quot;photo&quot;,</span><br><span class="line">    &quot;SERVER_PORT&quot;: &quot;9088&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好配置文件后，可以开始写解析配置文件的代码了。因为这里用的JSON格式，所以不需要引用任何第三方package，Golang原生自带JSON序列化&amp;反序列化的库。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为cfg.go的代码</span></span><br><span class="line"><span class="keyword">package</span> conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cfg <span class="keyword">struct</span> &#123;</span><br><span class="line">ConfigMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServerCfg Cfg</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init config from the local config file.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">confFile, err := os.Open(<span class="string">"conf/server.conf"</span>)</span><br><span class="line"><span class="keyword">defer</span> confFile.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerCfg.ConfigMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">err = json.NewDecoder(confFile).Decode(&amp;ServerCfg.ConfigMap)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the corresponding config value of the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cfg *Cfg)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> val, ok := cfg.ConfigMap[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line">log.Fatalf(<span class="string">"No such config term: %s!\n"</span>, key)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码里的<code>init()</code>就是用来读取同个文件夹下的<code>server.conf</code>，然后用原生的JSON解析包对其内容进行解析。另外，为了在其他代码模块中方便读取配置值，我们实现了一个<code>Get(key string)</code>方法。</p><h2 id="常量定义——避免magic-number"><a href="#常量定义——避免magic-number" class="headerlink" title="常量定义——避免magic number"></a>常量定义——避免magic number</h2><p>除了配置项，任何项目里不可缺少的还有各种常量。相比配置项的“动态”而言，常量一般是指跟代码逻辑紧密结合的值，绝大多数情况下基本不会因外部开发环境的变化而变化。不会说切到测试环境就用测试环境的一套，切到开发环境就用开发环境的一套。</p><p>例如，针对客户端的请求所回复的数值型状态码（<code>SUCCESS</code>、<code>FAIL</code>、<code>PENDING</code>之类的），或者是代码里的一些常用字符串。这样的值最好还是定义成常量，集中写到一个具体的常量代码文件里。否则直接在N个代码文件里大量使用magic number的话，万一到时要改就比较麻烦。</p><p>首先在项目路径下新建<code>constant</code>目录，然后在<code>constant</code>路径下新建<code>constant.go</code>和<code>resp_code.go</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— server.conf</span><br><span class="line"> |—— cfg.go</span><br><span class="line">|—— constant</span><br><span class="line">|—— constant.go</span><br><span class="line">|—— resp_code.go</span><br></pre></td></tr></table></figure><p>在<code>constant.go</code>里，我们要定义一些代码里经常使用的字符串/整形常量。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为constant.go的内容</span></span><br><span class="line"><span class="keyword">package</span> constant</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// JWT constants</span></span><br><span class="line">JWT_SECRET = <span class="string">"JWT_SECRET"</span></span><br><span class="line">JWT = <span class="string">"jwt"</span></span><br><span class="line">JWT_EXP_MINUTE = <span class="number">30</span></span><br><span class="line">PHOTO_STORAGE_ADMIN = <span class="string">"admin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Server constants</span></span><br><span class="line">SERVER_PORT = <span class="string">"SERVER_PORT"</span></span><br><span class="line">PAGE_SIZE = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DB constants</span></span><br><span class="line">DB_CONNECT = <span class="string">"%s:%s@tcp(%s:%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local"</span></span><br><span class="line">DB_TYPE = <span class="string">"DB_TYPE"</span></span><br><span class="line">DB_HOST = <span class="string">"DB_HOST"</span></span><br><span class="line">DB_PORT = <span class="string">"DB_PORT"</span></span><br><span class="line">DB_USER = <span class="string">"DB_USER"</span></span><br><span class="line">DB_PWD = <span class="string">"DB_PWD"</span></span><br><span class="line">DB_NAME = <span class="string">"DB_NAME"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Auth constants</span></span><br><span class="line">COOKIE_MAX_AGE = <span class="number">1800</span></span><br><span class="line">LOGIN_MAX_AGE = <span class="number">1800</span></span><br><span class="line">LOGIN_USER = <span class="string">"LOGIN_"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>而在<code>resp_code.go</code>里，我们要定义所有API的返回码，毕竟客户端收到回复后基本都要从返回码来判断服务端的执行情况。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为resp_code.go的内容</span></span><br><span class="line"><span class="keyword">package</span> constant</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// User related responses</span></span><br><span class="line">USER_ALREADY_EXIST = <span class="number">1001</span></span><br><span class="line">USER_ADD_SUCCESS = <span class="number">1002</span></span><br><span class="line">USER_AUTH_SUCCESS = <span class="number">1003</span></span><br><span class="line">USER_AUTH_ERROR = <span class="number">1004</span></span><br><span class="line">USER_AUTH_TIMEOUT = <span class="number">1005</span></span><br><span class="line">USER_SIGNOUT_SUCCESS = <span class="number">1006</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JWT related responses</span></span><br><span class="line">JWT_GENERATION_ERROR = <span class="number">2001</span></span><br><span class="line">JWT_MISSING_ERROR = <span class="number">2002</span></span><br><span class="line">JWT_PARSE_ERROR = <span class="number">2003</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bucket related responses</span></span><br><span class="line">BUCKET_ALREADY_EXIST = <span class="number">3001</span></span><br><span class="line">BUCKET_ADD_SUCCESS = <span class="number">3002</span></span><br><span class="line">BUCKET_NOT_EXIST = <span class="number">3003</span></span><br><span class="line">BUCKET_DELETE_SUCCESS = <span class="number">3004</span></span><br><span class="line">BUCKET_UPDATE_SUCCESS = <span class="number">3005</span></span><br><span class="line">BUCKET_GET_SUCCESS = <span class="number">3006</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Photo related responses</span></span><br><span class="line">PHOTO_ALREADY_EXIST = <span class="number">4001</span></span><br><span class="line">PHOTO_ADD_IN_PROCESS = <span class="number">4002</span></span><br><span class="line">PHOTO_UPLOAD_SUCCESS = <span class="number">4003</span></span><br><span class="line">PHOTO_UPLOAD_ERROR = <span class="number">4004</span></span><br><span class="line">PHOTO_NOT_EXIST = <span class="number">4005</span></span><br><span class="line">PHOTO_DELETE_SUCCESS = <span class="number">4006</span></span><br><span class="line">PHOTO_UPDATE_SUCCESS = <span class="number">4007</span></span><br><span class="line">PHOTO_GET_SUCCESS = <span class="number">4008</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Internal server responses</span></span><br><span class="line">INTERNAL_SERVER_ERROR = <span class="number">5001</span></span><br><span class="line">PAGINATION_SUCCESS = <span class="number">8001</span></span><br><span class="line">INVALID_PARAMS = <span class="number">9001</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Message <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Init the message map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">Message = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">Message[INVALID_PARAMS] = <span class="string">"Invalid parameters."</span></span><br><span class="line">Message[USER_ALREADY_EXIST] = <span class="string">"User already exists."</span></span><br><span class="line">Message[USER_ADD_SUCCESS] = <span class="string">"Add user success."</span></span><br><span class="line">Message[USER_AUTH_SUCCESS] = <span class="string">"User authentication success."</span></span><br><span class="line">Message[USER_AUTH_ERROR] = <span class="string">"User authentication fail."</span></span><br><span class="line">Message[USER_AUTH_TIMEOUT] = <span class="string">"User authentication timeout."</span></span><br><span class="line">Message[USER_SIGNOUT_SUCCESS] = <span class="string">"User sign out success."</span></span><br><span class="line">Message[JWT_GENERATION_ERROR] = <span class="string">"JWT generation fail."</span></span><br><span class="line">Message[JWT_MISSING_ERROR] = <span class="string">"JWT is missing."</span></span><br><span class="line">Message[INTERNAL_SERVER_ERROR] = <span class="string">"Internal server error."</span></span><br><span class="line">Message[BUCKET_ALREADY_EXIST] = <span class="string">"Bucket already exists."</span></span><br><span class="line">Message[BUCKET_ADD_SUCCESS] = <span class="string">"Add bucket success."</span></span><br><span class="line">Message[BUCKET_NOT_EXIST]= <span class="string">"Bucket does not exist."</span></span><br><span class="line">Message[BUCKET_DELETE_SUCCESS] = <span class="string">"Bucket delete success."</span></span><br><span class="line">Message[BUCKET_UPDATE_SUCCESS] = <span class="string">"Bucket update success."</span></span><br><span class="line">Message[BUCKET_GET_SUCCESS] = <span class="string">"Bucket get success."</span></span><br><span class="line">Message[PHOTO_ALREADY_EXIST] = <span class="string">"Photo already exists."</span></span><br><span class="line">Message[PHOTO_ADD_IN_PROCESS] = <span class="string">"Adding photo is in process."</span></span><br><span class="line">Message[PHOTO_UPLOAD_SUCCESS] = <span class="string">"Photo upload success."</span></span><br><span class="line">Message[PHOTO_UPLOAD_ERROR] = <span class="string">"Photo upload error."</span></span><br><span class="line">Message[PHOTO_NOT_EXIST] = <span class="string">"Photo does not exist."</span></span><br><span class="line">Message[PHOTO_DELETE_SUCCESS] = <span class="string">"Photo delete success."</span></span><br><span class="line">Message[PHOTO_GET_SUCCESS]= <span class="string">"Photo get success."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Translate a response code to a detailed message.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMessage</span><span class="params">(code <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">msg, ok := Message[code]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，我们不仅定义了返回码，还为每个返回码定义了对应的详细信息。当然，不定义详细信息也不是不可以，但是那样的话对客户端的可读性就很差，每次想查某个返回码对应的是什么信息时都得翻查文档。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>定义完配置文件&amp;常量后，我们来实现一下<code>JWT</code>。<code>JWT = JSON Web Token</code>，是用来做鉴权的一种手段。毕竟我们辛辛苦苦写好，部署好的API不是随便一个人都可以任意调用的，只有通过鉴权的调用才是真正的合法调用。关于<code>JWT</code>的详细解释，可以查看我之前的一篇文章<a href="https://marcoma.xyz/2019/01/27/jwt/" target="_blank" rel="noopener">《[Golang]JWT及其Golang实现》</a>。</p><p>因为<code>JWT</code>还不算我们业务逻辑里的模块，将其看作<code>utils</code>就行，所以要在项目路径下新建<code>utils</code>目录，并新建<code>jwt.go</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gin-photo-storage</span><br><span class="line">|—— conf</span><br><span class="line"> |—— server.conf</span><br><span class="line"> |—— cfg.go</span><br><span class="line">|—— constant</span><br><span class="line">|—— constant.go</span><br><span class="line">|—— resp_code.go</span><br><span class="line">|—— utils</span><br><span class="line">|—— jwt.go</span><br></pre></td></tr></table></figure><p>至于<code>JWT</code>的具体实现，因为它涉及一些数字签名的算法，造轮子手写大概率不是一个好的选择，所以我们直接用一个第三方的<code>JWT</code>库——<code>github.com/dgrijalva/jwt-go</code>来实现。</p><ul><li>Golang &lt;= 1.10且项目位于<code>$GOPATH/src</code>下的可以直接用go get来安装：<code>go get -u github.com/dgrijalva/jwt-go</code></li><li>Golang &gt;= 1.11且使用go mod来管理package的可以直接修改<code>go.mod</code>然后<code>go mod init &lt;module-name&gt;</code></li></ul><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为jwt.go的内容</span></span><br><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"gin-photo-storage/conf"</span></span><br><span class="line"><span class="string">"gin-photo-storage/constant"</span></span><br><span class="line"><span class="string">"github.com/dgrijalva/jwt-go"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// self-defined user claim</span></span><br><span class="line"><span class="keyword">type</span> UserClaim <span class="keyword">struct</span> &#123;</span><br><span class="line">UserName <span class="keyword">string</span> <span class="string">`json:"user_name"`</span></span><br><span class="line">jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate a JWT based on the user name.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateJWT</span><span class="params">(userName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// define a user claim</span></span><br><span class="line">claim := UserClaim&#123;</span><br><span class="line">userName,</span><br><span class="line">jwt.StandardClaims&#123;</span><br><span class="line">Issuer:    constant.PHOTO_STORAGE_ADMIN,</span><br><span class="line">ExpiresAt: time.Now().Add(constant.JWT_EXP_MINUTE * time.Minute).Unix(),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate the claim and the digital signature</span></span><br><span class="line">token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)</span><br><span class="line">jwtString, err := token.SignedString([]<span class="keyword">byte</span>(conf.ServerCfg.Get(constant.JWT_SECRET)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">"JWT generation error"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jwtString, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse a JWT into a user claim.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseJWT</span><span class="params">(jwtString <span class="keyword">string</span>)</span> <span class="params">(*UserClaim, error)</span></span> &#123;</span><br><span class="line">token, err := jwt.ParseWithClaims(jwtString, &amp;UserClaim&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(conf.ServerCfg.Get(constant.JWT_SECRET)), <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> token != <span class="literal">nil</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> claim, ok := token.Claims.(*UserClaim); ok &amp;&amp; token.Valid &#123;</span><br><span class="line"><span class="keyword">return</span> claim, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>JWT</code>的核心点有3个：</p><ul><li>自定义一个claim的结构，在这里就是<code>UserClaim</code>，其中简单地包含一个用户名。</li><li>实现生成<code>JWT</code>的逻辑，也就是传入自定义claim的字段，为其生成一个<code>JWT</code>字符串。</li><li>实现解析<code>JWT</code>的逻辑，也就是传入一个<code>JWT</code>字符串，反生成出一个自定义的claim。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发散思考：</p><ul><li><p>配置文件<code>server.conf</code>放在<code>conf</code>文件夹里，往git仓库上提交代码时，应不应该把配置文件也提交上去？如果不应该提交，要怎么设置？</p><ul><li>关键词：git命令、git ignore</li></ul></li><li><p>跟hard code在代码里相比，配置文件已经灵活了无数倍，但还有没有更好的方案来存储&amp;读取配置？假如想动态更新配置值，不用重启程序就能读取到最新的修改值，要怎么做？</p><ul><li>关键词：配置中心、热更新</li></ul></li><li><p><code>JWT</code>有什么功能上的缺点？有没有别的鉴权机制可以克服<code>JWT</code>的缺点？多种鉴权方式互相对比各有什么优劣？</p><ul><li>关键词：<code>Cookie-Session</code>、主动过期、单点登录</li></ul></li><li><p>用<code>JWT</code>的安全性如何？常见的web攻击手段能不能攻破<code>JWT</code>？</p><ul><li>关键词：<code>CSRF</code>、<code>XSS</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/02/23，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;p&gt;本文为
      
    
    </summary>
    
      <category term="gin" scheme="http://yoursite.com/categories/gin/"/>
    
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="连载" scheme="http://yoursite.com/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>[Golang]字符串拼接方式的性能分析</title>
    <link href="http://yoursite.com/2019/02/16/golang-str-join/"/>
    <id>http://yoursite.com/2019/02/16/golang-str-join/</id>
    <published>2019-02-17T01:00:00.000Z</published>
    <updated>2019-02-17T01:11:42.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/02/16，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>写本文的动机来源于Golang中文社区里一篇有头没尾的帖子<a href="https://studygolang.com/articles/18084#commentForm" target="_blank" rel="noopener">《Go语言字符串高效拼接》</a>，里面只提了Golang里面字符串拼接的几种方式，但是在最后却不讲每种方式的性能，也没有给出任何的best practice。本着无聊 + 好奇心，就决定自行写benchmark来测试，再对结果和源码进行分析，试图给出我认为的best practice吧。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>根据帖子里的内容，在<code>Golang</code>里有5种字符串拼接的方式：</p><ul><li><p>直接+号拼接</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接+号拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithAdd</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">s := <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">s += str</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fmt.Sprint()拼接</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fmt拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithFmt</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">s := fmt.Sprint(strs)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>strings.Join()拼接</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strings.Join拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithJoin</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">s := strings.Join(strs, <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Buffer拼接</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bytes.Buffer拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithBuffer</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">buf := bytes.Buffer&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">buf.WriteString(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Builder拼接</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strings.Builder拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithBuilder</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">builder := strings.Builder&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">builder.WriteString(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>为了测试各自的性能，就用<code>Golang</code>自带test模块的benchmark来进行测试。</p><p>在测试中，分3组数据，5组测试，即一共3 * 5 = 15次独立测试。其中3组数据是指：</p><ul><li>size = 10K的字符串数组，每个元素均为<code>&quot;hello&quot;</code></li><li>size = 50K的字符串数组，每个元素均为<code>&quot;hello&quot;</code></li><li>size = 100K的字符串数组，每个元素均为<code>&quot;hello&quot;</code></li></ul><p>5组测试是指：</p><ul><li>直接+号拼接，要跑10K、50K、100K的数据</li><li>fmt.Sprint()拼接，要跑10K、50K、100K的数据</li><li>strings.Join()拼接，要跑10K、50K、100K的数据</li><li>Buffer拼接，要跑10K、50K、100K的数据</li><li>Builder拼接，要跑10K、50K、100K的数据</li></ul><p>Benchmark代码如下：</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">Strs10K  []<span class="keyword">string</span><span class="comment">// 长度为10K的字符串数组</span></span><br><span class="line">Strs50K  []<span class="keyword">string</span><span class="comment">// 长度为50K的字符串数组</span></span><br><span class="line">Strs100K []<span class="keyword">string</span><span class="comment">// 长度为100K的字符串数组</span></span><br><span class="line">word = <span class="string">"hello"</span><span class="comment">// 待拼接的字符串</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ADD = <span class="literal">iota</span></span><br><span class="line">BUFFER</span><br><span class="line">BUILDER</span><br><span class="line">JOIN</span><br><span class="line">FMT</span><br><span class="line"></span><br><span class="line">_10K = <span class="number">10000</span></span><br><span class="line">_50K = <span class="number">50000</span></span><br><span class="line">_100K = <span class="number">100000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// preset和teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">Strs10K = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, _10K)</span><br><span class="line">Strs50K = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, _50K)</span><br><span class="line">Strs100K = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, _100K)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; _100K;i++ &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; _10K) &#123;</span><br><span class="line">Strs10K = <span class="built_in">append</span>(Strs10K, word)</span><br><span class="line">Strs50K = <span class="built_in">append</span>(Strs50K, word)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; _50K) &#123;</span><br><span class="line">Strs50K = <span class="built_in">append</span>(Strs50K, word)</span><br><span class="line">&#125;</span><br><span class="line">Strs100K = <span class="built_in">append</span>(Strs100K, word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exitCode := m.Run()</span><br><span class="line">os.Exit(exitCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试直接+号拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, ADD))</span><br><span class="line">b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, ADD))</span><br><span class="line">b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, ADD))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试bytes.Buffer拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithBuffer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, BUFFER))</span><br><span class="line">b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, BUFFER))</span><br><span class="line">b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, BUFFER))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试strings.Builder拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithBuilder</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, BUILDER))</span><br><span class="line">b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, BUILDER))</span><br><span class="line">b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, BUILDER))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试strings.Join拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithJoin</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, JOIN))</span><br><span class="line">b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, JOIN))</span><br><span class="line">b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, JOIN))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试fmt拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithFmt</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, FMT))</span><br><span class="line">b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, FMT))</span><br><span class="line">b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, FMT))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据拼接类型（testType），返回对应的测试方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTestConcat</span><span class="params">(strs []<span class="keyword">string</span>, testType <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">concatFunc := <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span> <span class="string">""</span>&#125;</span><br><span class="line"><span class="keyword">switch</span> testType &#123;</span><br><span class="line"><span class="keyword">case</span> ADD:</span><br><span class="line">concatFunc = ConcatWithAdd</span><br><span class="line"><span class="keyword">case</span> BUFFER:</span><br><span class="line">concatFunc = ConcatWithBuffer</span><br><span class="line"><span class="keyword">case</span> BUILDER:</span><br><span class="line">concatFunc = ConcatWithBuilder</span><br><span class="line"><span class="keyword">case</span> JOIN:</span><br><span class="line">concatFunc = ConcatWithJoin</span><br><span class="line"><span class="keyword">case</span> FMT:</span><br><span class="line">concatFunc = ConcatWithFmt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; b.N;i++ &#123;</span><br><span class="line">concatFunc(strs)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试（<code>go test -bench=. -benchmem</code>），结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">  4 BenchmarkConcatWithAdd/Concat-10000-4                 20      57050217 ns/op    270493320 B/op      9999 allocs/op</span><br><span class="line">  5 BenchmarkConcatWithAdd/Concat-50000-4                  2     937660008 ns/op    6435464656 B/op    49999 allocs/op</span><br><span class="line">  6 BenchmarkConcatWithAdd/Concat-100000-4                 1    3748714961 ns/op    25388918224 B/op       99999 allocs/op</span><br><span class="line">  7 BenchmarkConcatWithBuffer/Concat-10000-4           10000        138797 ns/op      209376 B/op         12 allocs/op</span><br><span class="line">  8 BenchmarkConcatWithBuffer/Concat-50000-4            3000        481466 ns/op      840160 B/op         14 allocs/op</span><br><span class="line">  9 BenchmarkConcatWithBuffer/Concat-100000-4           2000        966963 ns/op     1659360 B/op         15 allocs/op</span><br><span class="line"> 10 BenchmarkConcatWithBuilder/Concat-10000-4          10000        103924 ns/op      227320 B/op         21 allocs/op</span><br><span class="line"> 11 BenchmarkConcatWithBuilder/Concat-50000-4           3000        495917 ns/op     1431545 B/op         28 allocs/op</span><br><span class="line"> 12 BenchmarkConcatWithBuilder/Concat-100000-4          2000        891950 ns/op     2930682 B/op         31 allocs/op</span><br><span class="line"> 13 BenchmarkConcatWithJoin/Concat-10000-4             10000        106288 ns/op      114688 B/op          2 allocs/op</span><br><span class="line"> 14 BenchmarkConcatWithJoin/Concat-50000-4              3000        505209 ns/op      507904 B/op          2 allocs/op</span><br><span class="line"> 15 BenchmarkConcatWithJoin/Concat-100000-4             2000        990317 ns/op     1015808 B/op          2 allocs/op</span><br><span class="line"> 16 BenchmarkConcatWithFmt/Concat-10000-4               1000       1293589 ns/op      227716 B/op      10002 allocs/op</span><br><span class="line"> 17 BenchmarkConcatWithFmt/Concat-50000-4                200       6260637 ns/op     1131960 B/op      50003 allocs/op</span><br><span class="line"> 18 BenchmarkConcatWithFmt/Concat-100000-4               100      12005780 ns/op     2499702 B/op     100006 allocs/op</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure><p>可以看出</p><ul><li>运行速度上，Builder、Buffer、Join的速度属于同一数量级，绝对值也差不了太多；fmt要比它们一个数量级；直接+号拼接是最慢的。</li><li>内存分配上，Join表现最优秀，Buffer次之，Builder第三；而fmt和直接+号拼接最差，要执行很多次内存分配操作。</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li><p>速度&amp;内存分配都很优秀的<code>strings.Join()</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// 专门为短数组拼接做的优化</span></span><br><span class="line"><span class="comment">// 详情查阅golang.org/issue/6714</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(a) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] + sep + a[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>] + sep + a[<span class="number">1</span>] + sep + a[<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算总共要插入多长的分隔符，n = 分隔符总长</span></span><br><span class="line">n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历待拼接的数组，逐个叠加字符串的长度</span></span><br><span class="line"><span class="comment">// 最后n = 分隔符总长 + 所有字符串的总长 = 拼接结果的总长</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">n += <span class="built_in">len</span>(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性分配n byte的内存空间，并且把第一个字符串拷贝到slice的头部</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">bp := <span class="built_in">copy</span>(b, a[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从下标为1开始，调用原生的copy函数</span></span><br><span class="line"><span class="comment">// 逐个把分隔符&amp;字符串拷贝到slice里对应的位置</span></span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">bp += <span class="built_in">copy</span>(b[bp:], sep)</span><br><span class="line">bp += <span class="built_in">copy</span>(b[bp:], s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后将byte slice强转为string，返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看出<code>strings.Join()</code>为什么表现如此优秀，<strong>主要原因是只有1次的显式内存分配（<code>b := make([]byte, n)</code>）和1次隐式内存分配（<code>return string(b)</code>）</strong>，不需要在拼接过程中反复多次分配内存，挪动内存里的数据，减少了很多内存管理的消耗。</p></li><li><p>略差一筹的<code>bytes.Buffer.WriteString()</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试扩容n个单位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">tryGrowByReslice</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果底层slice的剩余空间 &gt;= n个单位，就不需要重新分配内存</span></span><br><span class="line"><span class="comment">// 而是reslice，把底层slice的cap限定在l + n</span></span><br><span class="line"><span class="keyword">if</span> l := <span class="built_in">len</span>(b.buf); n &lt;= <span class="built_in">cap</span>(b.buf)-l &#123;</span><br><span class="line">b.buf = b.buf[:l+n]</span><br><span class="line"><span class="keyword">return</span> l, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果底层slice的剩余空间不足n个单位，放弃reslice</span></span><br><span class="line"><span class="comment">// 说明需要重新分配内存，而不是reslice那么简单了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容n个单位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">grow</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">m := b.Len()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界情况，空slice，先把一些属性reset掉</span></span><br><span class="line"><span class="keyword">if</span> m == <span class="number">0</span> &amp;&amp; b.off != <span class="number">0</span> &#123;</span><br><span class="line">b.Reset()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先试试不真正分配空间，通过reslice来“扩容”</span></span><br><span class="line"><span class="keyword">if</span> i, ok := b.tryGrowByReslice(n); ok &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bootstrap是一个长度为64的slice，在buffer对象初始化时，</span></span><br><span class="line"><span class="comment">// bootstrap就已经分配好了，如果n小于bootstrap长度，</span></span><br><span class="line"><span class="comment">// 可以利用bootstrap slice来reslice，不需要重新分配内存空间</span></span><br><span class="line"><span class="keyword">if</span> b.buf == <span class="literal">nil</span> &amp;&amp; n &lt;= <span class="built_in">len</span>(b.bootstrap) &#123;</span><br><span class="line">b.buf = b.bootstrap[:n]</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述几种情况都无法满足</span></span><br><span class="line">c := <span class="built_in">cap</span>(b.buf)</span><br><span class="line"><span class="keyword">if</span> n &lt;= c/<span class="number">2</span>-m &#123;</span><br><span class="line"><span class="comment">// 理解为m + n &lt;= c/2比较好</span></span><br><span class="line"><span class="comment">// 如果扩容后的长度（m + n）比c/2要小，说明当前还有一大堆可用的空间</span></span><br><span class="line"><span class="comment">// 直接reslice，以b.off打头</span></span><br><span class="line"><span class="built_in">copy</span>(b.buf, b.buf[b.off:])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> c &gt; maxInt-c-n &#123;</span><br><span class="line"><span class="comment">// c + c + n &gt; maxInt，申请扩容n个单位太多了，不可接受</span></span><br><span class="line"><span class="built_in">panic</span>(ErrTooLarge)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 当前剩余的空间不太够了，重新分配内存，长度为c + c + n</span></span><br><span class="line">buf := makeSlice(<span class="number">2</span>*c + n)</span><br><span class="line"><span class="built_in">copy</span>(buf, b.buf[b.off:])</span><br><span class="line">b.buf = buf</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Restore b.off and len(b.buf).</span></span><br><span class="line">b.off = <span class="number">0</span></span><br><span class="line">b.buf = b.buf[:m+n]</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">b.lastRead = opInvalid</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先尝试reslice得到len(s)个单位的空间</span></span><br><span class="line">m, ok := b.tryGrowByReslice(<span class="built_in">len</span>(s))</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 无法通过reslice得到空间，直接粗暴地申请grow</span></span><br><span class="line">m = b.grow(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">copy</span>(b.buf[m:], s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  为什么<code>bytes.Buffer.WriteString()</code>性能比Join差呢，其实也是内存分配策略惹的祸。在Join里只有两次内存空间申请的操作，而<code>Buffer</code>里可能会有很多次。具体来说就是<code>buf := makeSlice(2*c + n)</code>这一句，每次重申请只申请<code>2 * c + n</code>的空间，用完了就要再申请<code>2 * c + n</code>。当拼接的数据项很多，每次申请的空间也就<code>2 * c + n</code>，很快就用完了，又要再重新申请，所以造成了性能不是很高。</p></li><li><p>略差一筹的<code>strings.Builder()</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">b.copyCheck()</span><br><span class="line">b.buf = <span class="built_in">append</span>(b.buf, s...)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码很简洁，就是最直白的slice append，一时append一时爽，一直append一直爽。所以当底层slice的可用空间不足，就会在append里一直申请新的内存空间。跟<code>bytes.Buffer</code>不同的是，这里并没有自己管理“扩容”的逻辑，而是交由原生的append函数去管理。</p></li><li><p>最差劲的<code>fmt.Sprint()</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> buffer []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pp <span class="keyword">struct</span> &#123;</span><br><span class="line">buf buffer</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">p := newPrinter()</span><br><span class="line">p.doPrint(a)</span><br><span class="line">s := <span class="keyword">string</span>(p.buf)</span><br><span class="line">p.free()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>printer</code>里的核心数据结构就是<code>buf</code>，而<code>buf</code>其实就是一个<code>[]byte</code>，所以给<code>buf</code>不停地拼接字符串，空间不够了又继续开辟新的内存空间，所以性能低下。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>实际上，只有当拼接的字符串非常非常多的时候，才需要纠结性能。像本文里动辄拼接10K、50K、100K个字符串的情况在实际业务中应该是很少很少的。</strong></p><p>如果实在要纠结性能，参考以下几点</p><ul><li>Join的速度最好，但是不至于完爆Builder和Buffer。三者的速度属于同一数量级。fmt和直接+号拼接速度最慢。</li><li>Join的内存分配策略最好，内存分配次数最少；Builder和Buffer的内存分配策略还算可以，类似于线性增长；fmt和直接+号拼接的内存分配策略最差。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/02/16，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>再次实践MySQL InnoDB索引</title>
    <link href="http://yoursite.com/2019/02/12/mysql-innodb-index-in-practice/"/>
    <id>http://yoursite.com/2019/02/12/mysql-innodb-index-in-practice/</id>
    <published>2019-02-13T00:00:00.000Z</published>
    <updated>2019-02-13T00:25:47.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/02/12，基于<code>MySQL 5.7.18</code>。<br>至于其他版本的<code>MySQL</code>，如有出入请自行查阅其他资料。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在上一篇博客<a href="https://marcoma.xyz/2019/02/05/mysql-innodb-index/" target="_blank" rel="noopener">《MySQL InnoDB索引的那些事》</a>里，已经用一些例子来简单讲解InnoDB里的B+树索引是什么了。但是可能在内容上比较理论和生硬，讲的都是数据结构和分析类的东西。所以今天这篇博客主要想讲讲“in-practice”方面的东西，再来看看InnoDB的索引，特指B+树索引。</p><h2 id="怎么知道有无触发索引"><a href="#怎么知道有无触发索引" class="headerlink" title="怎么知道有无触发索引"></a>怎么知道有无触发索引</h2><p>要分析一条select语句有没有触发索引，最简单的做法就是用<code>EXPLAIN</code>来分析一下该select语句。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure><p>可是<code>EXPLAIN</code>得到的结果不是一句人能看懂的话，或者log类型的数据，而是一堆字段，接下来就逐个字段看看它们的含义。</p><ul><li><code>id</code>：在你所执行的sql语句中，某个select子句的执行顺序。<code>id</code>为1的是第一个被执行的子查询，以此类推。</li><li><code>select_type</code>：该条select子句的类型，在<code>MySQL 5.7</code>中有11种可能取值。</li></ul><table><thead><tr><th>select_type</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>简单查询，不包含union或者子查询</td></tr><tr><td>PRIMARY</td><td>在多层select中的最外层查询语句</td></tr><tr><td>UNION</td><td>在union中第二个或者最后一个查询语句</td></tr><tr><td>DEPENDENT UNION</td><td>在union中第二个或者最后一个查询语句，但依赖于外层查询</td></tr><tr><td>SUBQUERY</td><td>子查询中的第一条select语句</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>子查询中的第一条select语句，但依赖于外层查询</td></tr><tr><td>DERIVED</td><td>派生表的查询，在from里的子查询</td></tr><tr><td>MATERIALIZED</td><td>???</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>查询结果不可被缓存的子查询</td></tr><tr><td>UNCACHEABLE UNION</td><td>在union中第二个或最后一个查询语句，该查询语句属于一个UNCACHEABLE的SUBQUERY</td></tr></tbody></table><ul><li><code>table</code>：被查询的表的表名</li><li><code>partitions</code>：对于分区表而言，该条select语句命中的记录所在的分区</li><li><code>type</code>：按照官方手册的说法，就是表与表之间join的类型</li></ul><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>system</td><td>表中只有一行数据</td></tr><tr><td>const</td><td>表中最多只有一行匹配数据（例如select … from … where pk = ?）</td></tr><tr><td>eq_ref</td><td></td></tr><tr><td>ref</td><td>常出现于辅助索引的等值查询</td></tr><tr><td>fulltext</td><td>出现于全文检索索引</td></tr><tr><td>ref_or_null SUBQUERY</td><td></td></tr><tr><td>index_merge</td><td></td></tr><tr><td>unique_subquery</td></tr><tr><td>index_subquery</td><td></td></tr><tr><td>range</td><td>常出现于范围索引</td></tr><tr><td>index</td><td>与all几乎一样，常见于扫描secondary index上的覆盖索引数据</td></tr><tr><td>all</td><td>全表扫描</td></tr></tbody></table><ul><li><code>possible keys</code>：该select语句中所有可能触发的索引</li><li><code>key</code>：实际触发的索引（有可能多于1个）</li><li><code>key_len</code>：实际触发的索引列的长度</li><li><code>ref</code>：等值查询时为<code>const</code>，如果用了表达式则可能为<code>func</code></li><li><code>rows</code>：预估需要扫描行数</li><li><code>filtered</code>：预估百分之多少的行会被查询条件过滤</li><li><code>Extra</code>：备注信息，从中观察可优化的点</li></ul><h2 id="同时只能触发一个索引？"><a href="#同时只能触发一个索引？" class="headerlink" title="同时只能触发一个索引？"></a>同时只能触发一个索引？</h2><p>在之前的那篇文章，还有一些其他网上的文章里会提到：如果一张表上有多个索引，在查询时只会触发其中一个。</p><p><strong>其实单看这句话是不准确的。</strong>比较严谨准确的描述应该是：<strong>在查询时，遇到某一列包含在多个索引内时，同时只能触发其中一个索引。</strong></p><p>举个例子，假如在<code>a</code>列上建了：</p><ul><li>单列索引<code>idx_a (a)</code></li><li>联合索引<code>idx_abc (a, b, c)</code></li><li>联合索引<code>idx_ak (a, k)</code></li></ul><p>在执行<code>select ... from ... where a = ?;</code>时，<strong>只能同时触发以上3个索引的其中一个。</strong></p><p>所以，如果查询语句的where条件中不止一列，是不是就可以触发多个索引呢？下面实际来试一试《MySQL技术内幕》里的例子。</p><p>先建一张测试表<code>t</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">a <span class="built_in">int</span>,</span><br><span class="line">b <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">key</span> (a),</span><br><span class="line"><span class="keyword">key</span> (b)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">1</span>, <span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">1</span>, <span class="number">2</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">2</span>, <span class="number">4</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> <span class="number">1</span>, <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a = <span class="number">1</span> <span class="keyword">and</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>得到的结果如下图所示：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/multi_index.png" alt=""></p><p>确实在一条select语句中触发了两个独立的单列索引，然后再将它们的中间结果取交集（Using intersect(b, a)），得到最终结果。</p><p>但是，不是所有情况下都能触发多个独立索引，然后进行集合运算。当使用存储过程大量插入数据后：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`proc_insert_t`</span>()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">WHILE i &lt;= 10000 DO</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(a, b) <span class="keyword">VALUES</span>(i, i * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> proc_insert_t();</span><br><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a = <span class="number">100</span> <span class="keyword">and</span> b = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>就会得到以下结果：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/multi_index_fail.png" alt=""></p><p>这说明，<strong>MySQL内置的sql优化器会对select语句进行优化</strong>，当它觉得走单个索引性能比较高时会走单个索引，当它觉得两个索引取交集的性能好时，它就会触发两个索引。</p><p>如果想要人为地在某条查询语句里使用索引，可以试试</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">USE</span> <span class="keyword">INDEX</span>(...) <span class="keyword">where</span> ...; // 建议优化器使用某索引</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">FORCE</span> INEDX(...) <span class="keyword">where</span> ...; // 强行绕开优化器，强制使用某索引</span><br></pre></td></tr></table></figure><h2 id="什么情况下索引会失效？"><a href="#什么情况下索引会失效？" class="headerlink" title="什么情况下索引会失效？"></a>什么情况下索引会失效？</h2><p>索引是不是百利而无一害的？不是。</p><p>索引是不是建好了就一定会被触发的？不是。</p><p>以下基于示例表<code>t</code>作解释：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t</span><br><span class="line">(</span><br><span class="line">a <span class="built_in">int</span>,</span><br><span class="line">b <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">key</span> (a)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>绝大多数情况下，我们说数据库索引都是指的那一棵棵的B+树，在某些情况下索引失效 = 无法遍历B+树，常见的有：</p><ol><li><p>带or的条件查询</p><p> <code>select ... from ... where a OR b;</code>，会直接走全表扫描。</p></li><li><p>不等值查询</p><p> 当where里的条件是不等值如<code>!=</code>或者<code>&lt;&gt;</code>时，没有办法把这个当做遍历B+树时比大小的依据，所以无法触发索引。</p></li><li><p>联合索引不满足最左前缀原则</p><p> 已知表上建好了联合索引<code>idx_abc (a, b, c)</code>，但是查询的where条件里不满足最左前缀原则，例如<code>select ... from ... where b = ? and c = ?</code>，这样是没有办法触发上面的联合索引的。</p><p> <strong>试想一下<code>idx_abc (a, b, c)</code>对应的B+树结构，每个节点里存的东西都是按照三元组<code>(a, b, c)</code>来排序的，先有a的顺序，在a的有序性基础上才有b的顺序，在b的有序性基础上才有c的顺序。</strong>所以如果在where条件里没有“最左边”的那一列，那根本就无法正常遍历B+树，因为B+树里的每个节点都是按照先a再b再c的顺序排序的，那也就谈不上“触发索引”了。</p></li><li><p>like条件的字符串以通配符“%”开头</p><p> 同上，试想一下<code>idx_name (name)</code>对应的B+树，每个节点里都是按字符串字典序排好的数据，用通配符%开头，遍历的时候怎么比大小？？？怎么可能正常地遍历B+树？？？？？？自然就索引失效了。</p><p> 但是如果查询条件以通配符%结尾，却是可以走索引的，因为<code>&quot;abc%&quot;</code>在遍历B+树的时候可以简单当成<code>&quot;abc&quot;</code>来比大小。</p></li><li><p>where条件中用了计算表达式或者函数</p><p> 同上，也是B+树遍历的问题。用表达式的结果或者函数的结果做filter的话，除非能另外建一棵新的B+树，树节点的数据按表达式的输出来排序，那样才能正常遍历。<strong>不能正常遍历B+树 = 索引失效。</strong></p></li><li><p>MySQL优化器决定不走索引</p><p> 有一些情况下，如上一篇文章提到的<code>sex</code>列索引，MySQL优化器未必会选择触发“性价比低”的索引。如果经过优化器判断，走secondary index再回clustered index查表将产生大量的磁盘I/O，甚至比直接全表扫描的磁盘I/O更多的话，很可能就不会走索引。</p></li></ol><h2 id="什么时候需要加索引"><a href="#什么时候需要加索引" class="headerlink" title="什么时候需要加索引"></a>什么时候需要加索引</h2><p>给某一列或者某几列加索引的优点很明显：加速目标数据查询，尽量避免全表扫描，减少磁盘I/O。而不加索引在别的方面也有好处：在某张表上的索引越多，意味着维护的B+树越多，当对该表<strong>频繁</strong>地进行insert/update/delete时，意味着要频繁修改诸多B+树的数据&amp;结构，性能很可能有大幅的下降。</p><p>所以，加不加索引，什么场景需要加索引，哪些列应该加索引，也是一个很麻烦的问题。</p><p>下面简单地讲几个加索引能带来较大收益的场景。</p><ol><li><p>某一列/几列经常作为条件在where中作等值过滤，且选择性很高</p><p> 例如电商业务里的<code>order</code>表，很可能经常需要通过<code>user_id</code>来查询该user的订单。</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">order</span> (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">user_id <span class="built_in">int</span>,</span><br><span class="line">......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> user_id = ?;</span><br></pre></td></tr></table></figure><p> 当这张表的容量上升至千万级别，不为<code>user_id</code>加索引的话，每次执行上述查询语句会全表扫描千万行。如果为<code>user_id</code>加索引，将根据user_id建一棵B+树，层高大概为3~4层，也就是最多3~4次磁盘I/O就能定位到要找的<code>user_id</code>对应的页。</p><p> 为<code>user_id</code>加索引，另外一个很重要的原因是在<code>order</code>表里<code>user_id</code>的选择性还是很不错的。所谓选择性，上一篇文章说过<code>选择性 = unique值的数量 / 行数</code>，虽然在<code>order</code>表里<code>user_id</code>的选择性不可能为1，但是也比<code>sex</code>那类二值属性的选择性要好得多，值得加索引。</p></li><li><p>某一列/几列经常需要排序</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">......</span><br><span class="line">a <span class="built_in">int</span>,</span><br><span class="line">b <span class="built_in">int</span></span><br><span class="line">......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> t <span class="keyword">where</span> a = ? <span class="keyword">order</span> <span class="keyword">by</span> b;</span><br></pre></td></tr></table></figure><p> 为什么在这种情况下加索引<code>idx_ab (a, b)</code>也是不错的选择呢？其实很简单，再次回想一下<code>idx_ab (a, b)</code>对应的B+树的结构。在B+树里，无论是非叶子还是叶子节点，里面存的数据都是按<code>(a, b)</code>二元组的顺序存的。当通过<code>where a = ?</code>的条件遍历B+树定位到叶子节点里的<code>a = ?</code>的记录后，其实<code>b</code>属性在<code>a = ?</code>的记录上也已经有序了。</p><p> 有了这个索引的帮助，就不需要一股脑地把数据取出来后再另外做<code>order by</code>的排序工作，提高了很多效率。</p></li><li><p>某一列/几列经常在select中被查询</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">......</span><br><span class="line">a <span class="built_in">int</span>,</span><br><span class="line">b <span class="built_in">int</span>,</span><br><span class="line">c <span class="built_in">int</span></span><br><span class="line">......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a, b, c <span class="keyword">from</span> t <span class="keyword">where</span> a = ?;</span><br></pre></td></tr></table></figure><p> 如上面的表，如果经常要查询某几个固定的字段，如<code>(a, b, c)</code>，而非全部字段<code>*</code>，加一个联合索引<code>idx_abc (a, b, c)</code>效果应该不错。再次考虑其对应的B+树的结构，对于secondary index（辅助索引）来说，最底层叶子节点里就已经存了<code>(a, b, c)</code>三元组的数据了（当然还有primary key）。<strong>那走一遍secondary index（辅助索引）就能得到全部想要的字段值，不需要通过primary key又回clustered index（聚集索引）扫一遍，减少了不少磁盘I/O，提高了查询效率。</strong></p></li></ol><h2 id="InnoDB内置的索引优化技术"><a href="#InnoDB内置的索引优化技术" class="headerlink" title="InnoDB内置的索引优化技术"></a>InnoDB内置的索引优化技术</h2><p>索引优化技术部分基本是对《MySQL技术内幕：InnoDB存储引擎》内的5.6.6和5.6.7节作概括总结，更详细的描述可以直接看书。</p><ol><li><p>MRR（Multi-Range Read）</p><ul><li>MRR适用于range、ref、eq_ref类型的查询</li><li>其第一个作用是，查完secondary index（辅助索引）得到一堆大概率不连续的primary key/row ID后，将其放到缓存里，然后对其进行排序。最后根据primary key/row ID遍历clustered index（聚集索引）的B+树时，因为primary key/row ID的有序性，所以遍历过程都是顺序磁盘I/O，而非随机磁盘I/O，提高了一定的读性能</li><li><p>其第二个作用是，将某类型的range查询拆分为k-v对的等值查询。例如</p>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t </span><br><span class="line"><span class="keyword">where</span> a &gt;= <span class="number">1000</span> <span class="keyword">and</span> a &lt; <span class="number">2000</span></span><br><span class="line"><span class="keyword">and</span> b = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure><p>  会将以上range查询拆成多个<code>(a=1000, b=10000)</code>……<code>(a=1999, b=10000)</code>的k-v对等值查询，避免range查询中先取出大量的无用数据再作filter的性能损耗。</p></li></ul></li><li><p>ICP（Index Condition Pushdown）</p><ul><li>ICP = 过滤条件下推，把where中的过滤条件下推到了存储引擎层，减少无用数据的取出。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/02/12，基于&lt;code&gt;MySQL 5.7.18&lt;/code&gt;。&lt;br&gt;至于其他版本的&lt;code&gt;MySQL&lt;/code&gt;，如有出入请自行查
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL InnoDB索引的那些事</title>
    <link href="http://yoursite.com/2019/02/05/mysql-innodb-index/"/>
    <id>http://yoursite.com/2019/02/05/mysql-innodb-index/</id>
    <published>2019-02-06T01:30:00.000Z</published>
    <updated>2019-02-06T02:38:45.154Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文80%由本人（Haoxiang Ma）原创，20%参考其他博客，如需转载请注明出处。</p><p>本文写于2019/02/05，基于<code>MySQL 5.7.18</code>。<br>至于其他版本的<code>MySQL</code>，如有出入请自行查阅其他资料。</p></blockquote><h2 id="索引（Index）是什么"><a href="#索引（Index）是什么" class="headerlink" title="索引（Index）是什么"></a>索引（Index）是什么</h2><p><strong>索引 = 目录</strong>，这就是我认为最直观的解释。</p><p>不妨类比一下，一本有着上千页的书 = 一张存了上亿行的数据库表。</p><p>如果想在这本书里快速翻找到某一章、某一节、甚至是某一段内容，最快的方法莫过于直接查书的目录，翻到目录里跟内容对应的那一页，再从该页的开头第一个字开始看，直到找到目标内容。</p><p>从数据库领域也莫过于此，如果我们能给一张表维护一个“目录”，在查我们想要的数据时，那就不需要从表的第一行开始检查，一直检查到该表的最后一行，极大提高了查表的效率。</p><p>讲完了大白话，我尝试用一句较为精炼严谨的话描述索引是什么：</p><p><strong>索引 = 一种记录了数据表里数据所在位置的结构。</strong></p><p>明显，它具有两种特性：</p><ul><li>索引是一种数据结构，你可以试着用数组、链表、队列、栈、二叉树、图……去实现，why not？</li><li>索引里存的是一张表里的数据所在的位置，借助索引，应该可以快速轻松地查到xx字段 = yy的数据在哪一行。</li></ul><h2 id="MySQL-InnoDB索引类型"><a href="#MySQL-InnoDB索引类型" class="headerlink" title="MySQL InnoDB索引类型"></a>MySQL InnoDB索引类型</h2><p>因为最近一直在看<code>MySQL</code>（其实是<code>InnoDB</code>）的内容，所以就专门针对<code>InnoDB</code>里的索引做了一点研究。接下来的内容如无特殊说明，均是基于<code>MySQL 5.7.18</code>及该版本默认自带的<code>InnoDB plugin</code>。</p><p>上面说了，索引是一种存东西的数据结构，理论上可以用我们学过的任意数据结构来实现。但是不同的数据结构在实现某个需求时肯定会有不同的效率（时间复杂度），所以从数据结构的角度来看，<code>InnoDB</code>内置了3种数据结构来实现索引：</p><ul><li><p>Hash</p><p>  本质上就是一张<code>HashMap</code>，可以想象一下key就是字段值，value就是该行的行号/primary key/存放位置offset等等</p><p>  例如有一张<code>user</code>表：</p><p>  <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/innodb_index_table1.png" alt=""></p><p>  如果为<code>user_name</code>列建一个Hash索引的话，大概会像：</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hash_index = &#123;</span><br><span class="line"><span class="string">"ii"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"jj"</span>: <span class="number">2</span>,</span><br><span class="line"><span class="string">"kk"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong><em>不过在<code>InnoDB</code>中，Hash索引是无法由用户自行创建的，一般讲Hash索引是指存储引擎内部在运行过程中慢慢自动为热门数据构建的索引。</em></strong></p></li><li><p>全文索引</p><p>  本质上就是一个倒排表（<code>inverted index</code>），专门为文本（长文本）类数据而设的。<strong><em>从<code>MySQL 5.6</code>开始才支持<code>InnoDB</code>的全文索引功能。</em></strong></p></li><li><p>B+树</p><p>  As its name indicates，这就是用标准的B+树实现的数据结构。默认情况下，一个<code>disk page</code>单位大小为<code>16KB</code>，为了匹配这个特性，在<code>InnoDB</code>的B+树索引里的一个节点也对应一个<code>disk page</code>，也最多存<code>16KB</code>的数据。</p><p>  在B+树里，非叶子节点不存真正的数据，只存索引值，只有最底层的叶子节点才会存真正的数据。同时，在数据库领域为了尽可能地减少磁盘I/O，所以B+树的fan-out（阶/扇出）都会设置得比较大，意味着一个树节点可以有非常多的孩子节点，那样树的高度就不会过高。<strong>宁愿“宽胖”也不要“高瘦”，高瘦意味着从root到leaf要访问很多个中间树节点，意味着很多次磁盘I/O。</strong></p><p>  除此之外，其他的B+树基础特性都得到了保留。B+树数据结构基础可以参考以下Calcular的博客：<a href="https://blog.csdn.net/Calcular/article/details/79328397" target="_blank" rel="noopener">《B+树完全解析》</a>。</p><p>  再拿<code>user</code>表来做例子：</p><p>  <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/innodb_index_table2.png" alt=""></p><p>  假如基于<code>id</code>列构建B+树索引，建出来的B+树大概像：</p><p>  <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/innodb_bplustree.png" alt=""></p></li></ul><p>以上从<strong>数据结构</strong>的角度介绍了3种索引类型，接下来从<strong>逻辑角度</strong>介绍<code>InnoDB</code>里的2种索引类型。</p><ul><li><p>聚集索引（<code>Clustered Index</code>）</p><p>  <strong>聚集索引 = 全表数据 + 基于主键大小排序构建出的B+树</strong></p><p>  所谓的“聚集”，就是全部行数据和索引数据的“聚集”，都放在了同一棵B+树里，非叶子节点存的是主键值的索引，叶子节点存的是真实的一行一行的表数据。</p><p>  <strong>因为一张表只能有一个主键，所以一张表只能有一个聚集索引。</strong></p><p>  上面的<code>user</code>表和对应的B+树就是一个聚集索引，因为那棵B+树是基于主键的大小排序构建出来的，非叶子节点存的都是主键值的索引，叶子节点存了全部行数据。</p></li><li><p>辅佐索引（<code>Secondary Index</code>）</p><p>  <strong>辅佐索引 = 主键数据 + 基于某N列组合排序构建出的B+树</strong> （1 &lt;= N &lt;= 表总列数）</p><p>  对于一张表来说，除了唯一一个聚集索引外，其他所有索引都称为辅佐索引。</p><p>  辅佐索引的B+树里，非叶子节点存的是某N列的值的索引，<strong>叶子节点存的不再是行数据，而是该行对应的主键值！</strong></p><p>  拿<code>student</code>表做例子：</p><p>  <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/innodb_index_table3.png" alt=""></p><p>  假设在hobby这一列上建一个索引，毫无疑问这就是一个辅佐索引：</p><p>  <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/secondary_index.png" alt=""></p><p>  注意观察，最底层的叶子节点不再存完整的行数据，而是存了对应行的主键，相当于一个指向行数据的指针。</p></li></ul><h2 id="单列索引及工作流程"><a href="#单列索引及工作流程" class="headerlink" title="单列索引及工作流程"></a>单列索引及工作流程</h2><p>接下来看看最简单的索引：<strong>单列索引</strong>，展开来讲就是“在单列上构建的辅佐索引”。其结构可以参考上面的<code>student</code>表和其对应的B+树。</p><p>那么单列索引为什么可以提高查表效率呢？以<code>student</code>表上的<code>hobby</code>索引为例，以下就是它的工作流程：</p><ol><li>执行<code>select * from student where hobby = &#39;swimming&#39;;</code></li><li>执行引擎检查发现hobby列上已建索引，决定使用该索引</li><li>遍历<code>hobby</code>索引的B+树，比较<code>swimming</code>和各中间节点上的索引值的大小，遍历过程发生多次磁盘I/O，最终定位到最右下角的节点</li><li>发现该节点对应的<code>disk page</code>还未加载到内存，加载该页</li><li>页加载后，从页中找到<code>hobby = swimming</code>的记录，读出该记录的主键为<code>3</code></li><li>遍历聚集索引（<code>Clustered Index</code>），比较<code>3</code>和各中间节点上的主键索引值的大小，最终定位到某个叶子节点</li><li>发现该节点对应的<code>disk page</code>还未加载到内存，加载该页</li><li>页加载后，从页中找到<code>id = 3</code>的记录，读出该记录的所有字段值</li><li>把结果返回给客户端</li></ol><p>从以上的步骤可以看到，利用单列辅佐索引来查数据，实际上分了两段逻辑：</p><ol><li>遍历辅佐索引的B+树，找到想要的行的primary key</li><li>根据primary key，去遍历聚集索引的B+树，最终得到完整的行数据</li></ol><h2 id="联合索引及工作流程"><a href="#联合索引及工作流程" class="headerlink" title="联合索引及工作流程"></a>联合索引及工作流程</h2><p>那如果不是<strong>单列索引</strong>，而是<strong>联合（多列）索引</strong>呢？</p><p>例如<code>student</code>表除了<code>hobby</code>字段还有<code>age</code>字段，想联合<code>(hobby, age)</code>来建索引可不可以？</p><p>答案当然是没有问题，而且先上结论：<strong>在一定情况下联合索引比单列索引性价比更高。</strong></p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/innodb_index_table4.png" alt=""></p><p>其对应的B+树跟之前没有太大差别，仅仅是索引比大小时用的是二元组<code>(hobby, age)</code>来比，而不仅仅是<code>hobby</code>单属性来比。</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/secondary_index2.png" alt=""></p><p>如上图，如果再插入一条<code>(hobby=pingpong, age=20)</code>的数据，这条数据就不会落到左下角的叶子节点，而是右下角的叶子节点。因为比大小比的是整个<code>(hobby, age)</code>二元组的大小，<code>(hobby=pingpong, age=20) &gt; (hobby=pingpong, age=16)</code>。</p><p><strong>至于联合索引触发的工作流程，跟单列索引的逻辑几乎一样，也是分两段走，不必多说。</strong></p><p>那为什么说在一定情况下联合索引比单列索引性价比更高？参考<a href="https://segmentfault.com/q/1010000000342176" target="_blank" rel="noopener">《mysql里创建联合索引的意义?》</a>一文，我详细拓展了以下原因：</p><ol><li><p>1个联合索引 = N个索引。如果建一个在<code>(a, b, c)</code>三列上的联合索引，相当于建了<code>(a)</code>，<code>(a, b)</code>，<code>(a, b, c)</code>三个索引。为什么呢？结合上述B+树的结构来思考，如果以三元组<code>(a, b, c)</code>建了B+树，B+树里的节点都按“先比a的大小，再比b的大小，最后比c的大小”的顺序排列。当执行<code>select * from ... where a = ?</code>和<code>select * from ... where a = ? and b = ?</code>时，一样能利用按<code>(a, b, c)</code>排好序的B+树。</p><p> <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/multiple_index.png" alt=""></p><p> 如上图，已按<code>(a, b, c)</code>三元组的大小构建B+树。当执行<code>select * from ... where a = 2</code>，自然也能利用该B+树的排序性质，走到左下角的叶子节点；当执行<code>select * from ... where a = 4 and b = 1</code>时，在root处比较得到：<code>(a=3, b=3, c=...) &lt; (a=4, b=1) &lt; (a=6, b=5, c=...)</code>，所以自然也会往右边走。</p><p> 综上所述，联合索引确实可以以<strong>一己之力</strong>起到N个索引的作用，还不用单独建多个独立的索引，节省磁盘空间&amp;介绍写表的开销。</p></li><li><p>有效减少回表查询的次数。还是参考以上按<code>(a, b, c)</code>三元组的大小构建的B+树。当执行的sql为<code>select a, b, c from ... where ...;</code>，<strong>联合索引的B+树的底层叶子节点其实已经包含了a, b, c的数据，不需要查出primary key再回聚集索引查询。</strong></p></li><li>筛选度高，减少表遍历的行数。执行<code>select * from ... where a = ? and b = ? and c = ?</code>时，假如独立满足a, b, c的各有10%的数据。在联合索引的筛选下，能够筛选出<code>N * 10% * 10% * 10%</code>的数据，再拿它们的primary key到聚集索引查询。如果不走联合索引，只走a的单列索引，那么只能筛选出<code>N * 10%</code>的数据，将会拿大量的primary key回聚集索引查询，磁盘I/O次数会高非常多。</li></ol><h2 id="上索引会毁性能？"><a href="#上索引会毁性能？" class="headerlink" title="上索引会毁性能？"></a>上索引会毁性能？</h2><p>前面讲了一大堆，貌似索引就是个纯天然24k好东西，但是世界上永远没有绝对的好与坏，在computer science里更是如此，所有东西都有它的trade-off，要看具体的问题和场景来选择方案。</p><p>来看一个在面试中经常被问到的例子：在用户表的<code>sex</code>列应不应该加索引？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS people;</span><br><span class="line">CREATE TABLE `people` (</span><br><span class="line">  `id` int unsigned PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `sex` tinyint(1) unsigned DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>建表后，插入100w行数据，其中50w行<code>sex=0</code>，另外50w行<code>sex=1</code>。</p><p>开启MySQL的<code>profiling</code>，<code>set profiling = 1;</code>用来查看sql运行时间。</p><p>未对<code>sex</code>列加索引前，连续执行三次<code>select * from people where sex = 0;</code>，用<code>show profiles</code>查看执行时间，得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Duration Query</span><br><span class="line">1.32345100 SELECT * FROM people WHERE sex = 0</span><br><span class="line">1.32988600 SELECT * FROM people WHERE sex = 0</span><br><span class="line">1.33359200 SELECT * FROM people WHERE sex = 0</span><br></pre></td></tr></table></figure><p>单次查询的时间大概是1.3秒出头。</p><p>然后对<code>sex</code>列加索引，<code>ALTER TABLE people ADD INDEX idx_sex (sex);</code>。再连续执行三次<code>select * from people where sex = 0;</code>，用<code>show profiles</code>查看执行时间，得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Duration Query</span><br><span class="line">3.74329700 SELECT * FROM people WHERE sex = 0</span><br><span class="line">2.80777500SELECT * FROM people WHERE sex = 0</span><br><span class="line">2.70100800SELECT * FROM people WHERE sex = 0</span><br></pre></td></tr></table></figure><p>单次查询的时间大概是3秒左右，<strong>比未加索引时足足慢了一倍以上。</strong></p><p>下面来分析一下为什么会出现这种情况，在这个场景下为什么会有如此负面的影响？</p><p>100w数据里性别分布均匀，男女各50w。根据<code>sex</code>列建成B+树后，假设：</p><ul><li>B+树的fan-out足够大且单条记录所占空间极小</li><li>辅佐索引上，一个叶子节点上能装1000条记录（<code>(sex, primary key)</code>为一条记录）</li><li>得到该B+树的层高为2</li></ul><p><strong>极端情况下无任何内存缓存，全靠磁盘I/O</strong>，为了在辅佐索引读出50w条男性记录的primary key，要访问<code>50w / 1000 = 500 pages = 500次磁盘I/O</code>。然后拿50w个primary key去查聚集索引，聚集索引B+树的层高也为2，也就是说在极端情况下查50w次primary key要触发100w次磁盘I/O。全过程的磁盘I/O为<code>100w + 500</code>次。</p><p>在不加索引的情况+无缓存极端情况下，进行全表扫描。全表100w条数据，要访问<code>100w / 1000 = 1000 pages = 1000次磁盘I/O</code>，全过程的磁盘I/O就是<code>1000</code>次。</p><p>经过分析，可以看到在均匀分布的<code>sex</code>列上走索引，反而得不偿失，磁盘I/O数会剧增。<strong>当然，以上分析撇除了内存缓存因素，所以差距被夸大了。但是实际应用中，差距即使没有百万和一千那么大，还是比较明显的。</strong></p><p>这个案例告诉我们：索引不要加在选择性很差的列上，也就是那些distinct值极少的列。（选择性 = #distinct / #row）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库索引是一个很大的研究方向，即使把圈子限定在<code>MySQL InnoDB</code>里，索引也能讲上十几篇文章。本文只是为了让大家简单入门<code>MySQL InnoDB</code>的索引体系，并且尽力提供一些容易让人理解的图表和例子，好让初学者不要像我当初一样满脑子浆糊，在网上搜来搜去都是那些互相复制粘贴的文章。</p><p>我觉得有兴趣、且懂c++的读者可以尝试阅读<code>InnoDB</code>的源码，从<code>工程优雅性</code>的角度而言未必是一个牛逼的项目，但是可以深入理解一些数据结构和算法的实现，之后在使用<code>MySQL</code>的时候会发现如鱼得水，融会贯通。</p><p>感谢以下的参考资料和博客：</p><ul><li><a href="https://blog.csdn.net/zxcc1314/article/details/83627025" target="_blank" rel="noopener">[InnoDB]性别字段为什么不适合加索引 by gnocuohz</a></li><li><a href="http://hedengcheng.com/?p=577" target="_blank" rel="noopener">SQL中的where条件，在数据库中提取与应用浅析 by 何登成</a></li><li><a href="https://segmentfault.com/q/1010000000342176" target="_blank" rel="noopener">mysql里创建‘联合索引’的意义？ on segmentfault</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文80%由本人（Haoxiang Ma）原创，20%参考其他博客，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/02/05，基于&lt;code&gt;MySQL 5.7.18&lt;/code&gt;。&lt;br&gt;至于其他版本的&lt;code&gt;MySQL&lt;/code&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>[Golang]JWT及其Golang实现</title>
    <link href="http://yoursite.com/2019/01/27/jwt/"/>
    <id>http://yoursite.com/2019/01/27/jwt/</id>
    <published>2019-01-28T05:00:00.000Z</published>
    <updated>2019-01-28T05:04:06.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/01/27，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p></blockquote><h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p><code>JWT</code>，全称是<code>JSON-WEB-TOKEN</code>，可以理解为：在web系统中用于鉴权，基于JSON格式的一种token。</p><ol><li><p>白话<code>JWT</code></p><ul><li><p>鉴权</p><p>  所谓“鉴权”，就是服务器验证用户是不是真的有操作的权利。在web系统里，有无数的地方需要进行“鉴权”，例如在某宝上买了一堆东西，提交结算时；例如在ICBC网银上转账，输入完金额按下确认按钮时；例如在某个论坛水贴，写下一大段文字，按下发表按钮时。类似的操作都需要对操作者进行验证，看看是不是真的用户在操作，而不是其他阿猫阿狗冒认的。</p><p>  不说那么宏观的，就说个人开发了几个<code>api</code>供别人调用，那也必须对调用者进行鉴权，不能被人分析前端源码后疯狂乱调用你的<code>api</code>。</p><p>  所以，鉴权很重要。</p></li><li><p>JSON格式</p><p>  在鉴权的时候提到JSON，其实就是用于鉴权的消息（数据）全都encode成JSON格式，方便传输和解析。</p></li><li><p>token</p><p>  <strong>token = 凭证 = 一个字符串。</strong>调用一些需要鉴权的api时，用户端（web页面、ios、android……）要把token传给server端，server端检查token有效后才能放行（进行下一步操作）。</p></li></ul></li><li><p><code>JWT</code>定义</p><p> <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/jwt.png" alt=""></p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">JWT = Base64URL(Header.Payload.Signature)</span><br></pre></td></tr></table></figure><p> 可以看出，<code>JWT</code>就是一个很长很长的<strong>字符串</strong>，由3部分：<code>Header</code>、<code>Payload</code>、<code>Signature</code>组成，各部分之间用<code>.</code>号分隔。</p><ul><li><p><code>Header</code></p><p>  Header里用JSON格式记录了整个token的必要的元数据，例如：</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"alg"</span>: <span class="string">"HS256"</span>,<span class="comment">// 使用了哪种签名算法</span></span><br><span class="line"><span class="string">"typ"</span>: <span class="string">"JWT"</span><span class="comment">// 该token的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Payload</code></p><p>  Payload里则存了鉴权所需的实际的数据，例如：</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"iss"</span>: <span class="string">"nobody"</span>,<span class="comment">// 签发方</span></span><br><span class="line"><span class="string">"exp"</span>: <span class="string">"2019/08/08"</span>,<span class="comment">// 过期时间</span></span><br><span class="line"><span class="string">"sub"</span>: <span class="string">"auth"</span>,<span class="comment">// 主题</span></span><br><span class="line"><span class="string">"aud"</span>: <span class="string">"kids"</span>,<span class="comment">// 受众</span></span><br><span class="line"><span class="string">"nbf"</span>: <span class="string">"2019/01/01 06:00:00"</span>,<span class="comment">// 生效时间</span></span><br><span class="line"><span class="string">"iat"</span>: <span class="string">"2019/01/01 00:00:00"</span>,<span class="comment">// 签发时间</span></span><br><span class="line"><span class="string">"jti"</span>: <span class="string">"13579"</span><span class="comment">// 编号</span></span><br><span class="line">......<span class="comment">// 更多自定义字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  除了以上7个官方字段，还可以自定义更多字段。<strong>通常为了鉴权，可以加一个<code>user_id</code>或类似的字段，指明这是哪个user在请求操作。</strong></p></li><li><p><code>Signature</code></p><p>  顾名思义，Signature就是一个数字签名，使用Header里指明的签名算法，对Header和Payload签名，<strong>以防止第三方对其进行篡改。</strong></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">secret_key = <span class="string">"......"</span></span><br><span class="line">str = base64URL(header) + <span class="string">"."</span> + base64URL(payload)</span><br><span class="line">signature = xx_algorithm(str, secret_key)</span><br></pre></td></tr></table></figure><p>  算出Signature后，即可将三者拼凑在一起，用<code>.</code>号分隔，作为一个<code>JWT</code>的整体返回。</p></li></ul></li><li><p>需要注意的点</p><p> 在<code>JWT</code>生成时，很多地方用到了<code>Base64URL</code>，这里要特别提2个细节：</p><ul><li><code>Base64URL</code>就是普通<code>Base64</code>算法的改良版，为了适应url里的特殊字符，把<code>=</code>省略，把<code>+</code>替换为<code>-</code>，把<code>/</code>替换为<code>_</code>，其他一致。</li><li><code>Base64URL</code>本质上<strong>并不是加密算法，只是一种编码方式，是可逆的，很容易能把base64字符串还原成原字符串。</strong></li></ul></li></ol><h2 id="JWT的优点与缺点"><a href="#JWT的优点与缺点" class="headerlink" title="JWT的优点与缺点"></a>JWT的优点与缺点</h2><p>web系统里实现鉴权的传统手法是<code>session-cookie</code>机制。如下图所示：</p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/session.png" alt=""></p><p>根据上图，传统<code>session-cookie</code>机制也可以很好地完成鉴权工作，<strong>但是最大的问题在于扩展和维护。</strong>想象一下，当业务量剧增，后端不可能只部署一台server，必然要把api服务部署在N台物理server上。那么N台server必然就要共享session数据，那就要部署一个第三方存储组件（例如<code>Redis</code>）来存session数据。可是有可能单个<code>Redis</code>实例也存不下，那就要弄成<code>Redis</code>集群，或者别的存储集群，那就又涉及HA和一致性问题。。。</p><p>所以，<code>session-cookie</code>机制不是不行，而是在拓展和维护上比较麻烦。</p><p><strong>那用<code>JWT</code>的话，会更容易拓展和维护吗？</strong></p><p>貌似还真的可以，server端不需要保存<code>session</code>数据，一切数据相当于“寄存”到了client端。server只起到2个作用：</p><ul><li>用户最初登录时，校验用户名与密码，颁发<code>JWT</code></li><li>用户之后每次请求时带上<code>JWT</code>，server进行简单校验</li></ul><p>但是，世界上没有100%完美的机制，一切都要有trade-off，<code>JWT</code>也有它的缺点。由于它把一切数据“寄存”到了client端，所以server端无法控制token过期，失效等操作。一旦把<code>JWT</code>颁发出去，只能等到<code>JWT</code>里定义的<code>exp</code>到期，才能执行失效操作，而传统的<code>session-cookie</code>机制则可以主动在server端把session删了或者置为过期。</p><p>虽然原生的<code>JWT</code>不能主动控制token过期，我们还是可以在工程上额外实现过期机制的，例如在server端维护一个黑名单，黑名单记录了需要“被”失效的<code>client_id</code>或者<code>user_name</code>，当server收到用户请求，从其<code>JWT</code>拿到<code>user_name</code>后应和黑名单里的<code>user_name</code>比较，如果在黑名单中，就拒绝请求，达到“过期”、“失效”的效果。</p><p>有人会问，这样做来实现<code>JWT</code>主动过期，不是又走回<code>session-cookie</code>机制的老路吗？server端还是要保存数据，还不如直接用<code>session-cookie</code>机制呢。<strong>当然不是。</strong>在<code>session-cookie</code>机制中，server端要为<strong>每一个</strong>发起过连接的用户（在一定时间内）保存session数据，但是<code>JWT</code>黑名单只需要为<strong>一小部分</strong>用户保存简单的用户名，总不能说你的系统里绝大部分用户都在黑名单里吧？？？</p><p>所以，采用<code>session-cookie</code>还是<code>JWT</code>并没有绝对的答案，全都取决于业务场景、用户数量、可维护性。</p><h2 id="Golang实现"><a href="#Golang实现" class="headerlink" title="Golang实现"></a>Golang实现</h2><p>要实现<code>JWT</code>，比较麻烦的是签名算法，还好目前<code>Golang</code>已经有好一些现成的<code>JWT</code>库可供调用，下面来看看用<code>github.com/dgrijalva/jwt-go</code>实现的<code>JWT</code>机制，该库的源码请参考 <a href="https://github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">github.com/dgrijalva/jwt-go</a>。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JWT Payload结构</span></span><br><span class="line"><span class="keyword">type</span> Claims <span class="keyword">struct</span> &#123;</span><br><span class="line">Username <span class="keyword">string</span> <span class="string">`json:"username"`</span></span><br><span class="line">Password <span class="keyword">string</span> <span class="string">`json:"password"`</span></span><br><span class="line">jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(username <span class="keyword">string</span>, password <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span>&#123;</span><br><span class="line">expireAt := time.Now().Add(<span class="number">30</span> * time.Minute)</span><br><span class="line">issuedBy := <span class="string">"nobody"</span></span><br><span class="line">secret := <span class="string">"secret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Payload</span></span><br><span class="line">claim := Claims&#123;</span><br><span class="line">username,</span><br><span class="line">password,</span><br><span class="line">jwt.StandardClaims&#123;</span><br><span class="line">ExpiresAt: expireAt.Unix(),</span><br><span class="line">Issuer: issuedBy,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义签名算法, 签名, 生成JWT</span></span><br><span class="line">token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)</span><br><span class="line">ss, err := token.SignedString([]<span class="keyword">byte</span>(secret))</span><br><span class="line"><span class="keyword">return</span> ss, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(ss <span class="keyword">string</span>)</span> <span class="params">(*Claims, error)</span></span> &#123;</span><br><span class="line">secret := <span class="string">"secret"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析Payload</span></span><br><span class="line">token, err := jwt.ParseWithClaims(ss, &amp;Claims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(secret), <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证Payload</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; token != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> claim, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid &#123;</span><br><span class="line"><span class="keyword">return</span> claim, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ol><li>原生<code>JWT</code>只是用<code>Base64URL</code>编码了一下，自行实现时可以用非对称的加密算法加密。</li><li>和<code>session-cookie</code>机制一样，<code>JWT</code>的有效时间不应该设置太长。</li><li>为了防止<code>CSRF</code>攻击，如果把<code>JWT</code>存在cookie中，进行<code>POST</code>/<code>PUT</code>/<code>DELETE</code>请求时，还应该带上<code>CSRF-TOKEN</code>进行多重验证。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/01/27，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>[Golang]探索包初始化(init)</title>
    <link href="http://yoursite.com/2019/01/21/go-package-init/"/>
    <id>http://yoursite.com/2019/01/21/go-package-init/</id>
    <published>2019-01-21T22:15:00.000Z</published>
    <updated>2019-01-22T04:45:50.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p><p>本文写于2019/01/21，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p></blockquote><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>在<code>Java</code>中，我们有包（package）、类、类变量、全局变量等概念，对JVM有了解的同学会对各种变量的内存分配位置和生命周期等特性了如指掌。例如，当类被JVM加载时，类的各种信息&amp;类变量都会进入JVM内存区域，类变量（static）就会被分配在方法区，并且只要该类没有被gc，类变量也会一直存在。</p><p>然而，在<code>Golang</code>里面，我们有包（package），但却没有了很多<code>Java</code>里的“类特性”，不存在什么类加载，而且还多了一些语言特性。所以在本文中我想探讨一下<code>Golang</code>自己的特性——包初始化。</p><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>在<code>Java</code>中，当谈及“全局变量”、初始化、main方法，永远都离不开一个载体——类（class），一切一切都是写在类的内部，从类加载而生，由类gc而死，对象从new（或者反射）而生，由gc而死。</p><p>可是<code>Golang</code>里对“类”概念的依赖被极大地削弱：这里也有“全局变量”，可以脱离类存在，可以直接定义在包这个level上；这里也有“初始化”，不过是包level上的初始化（<code>func init()</code>）；这里也有“main方法”，并不需要定义在“类”的内部。</p><p><strong>那么问题就来了，全局变量的初始化，包的初始化，main方法的调用，哪个先被执行？？？</strong></p><p><strong>在各种不同的情况下，它们的执行顺序会不会发生变化？？？</strong></p><ol><li><p>包变量初始化、init()、main()执行顺序</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> V = prepareV()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling main.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareV</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling prepareV()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling main()"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上述代码里，在同一个<code>main</code>package中有全局变量（包变量）<code>V</code>，包的初始化方法<code>init()</code>，以及<code>main()</code>方法。</p><p> 执行结果是</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">calling prepareV()<span class="comment">// 包变量初始化</span></span><br><span class="line">calling main.init()<span class="comment">// 调用init，包初始化</span></span><br><span class="line">calling main()<span class="comment">// 执行main方法</span></span><br></pre></td></tr></table></figure><p> 显而易见，<strong>包变量 -&gt; 包init -&gt; main方法</strong></p></li><li><p>同一个package内，多个init()的执行顺序</p><p> 很多时候，在一个package中，不可能只有一个代码文件。例如名为<code>utils</code>的package里肯定有着N多个不同的代码文件，实现了不同的模块。如果N个模块都有自己的<code>init()</code>方法，虽然从package的层次来看，它们都属于同一个package，但毕竟代码执行起来肯定是有前后顺序的，那么这N个<code>init()</code>的执行顺序会是怎样的呢？</p><ul><li><p><code>a.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = prepareA()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling a.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling a.prepareA()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>d.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = prepareD()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling d.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareD</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling d.prepareD()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>x.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = prepareX()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling x.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareX</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling x.prepareX()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>main.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling main()"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码里有1个<code>main</code>package，该package下有4个go代码文件：<code>a.go</code>，<code>d.go</code>，<code>x.go</code>，<code>main.go</code>，且每个代码文件里都有一个<code>init()</code>方法。</p><p>  程序的输出如下：</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">calling a.prepareA()<span class="comment">// a.go里的A变量初始化</span></span><br><span class="line">calling d.prepareD()<span class="comment">// d.go里的D变量初始化</span></span><br><span class="line">calling x.prepareX()<span class="comment">// x.go里的X变量初始化</span></span><br><span class="line">calling a.init()<span class="comment">// a.go里的init()调用</span></span><br><span class="line">calling d.init()<span class="comment">// d.go里的init()调用</span></span><br><span class="line">calling x.init()<span class="comment">// x.go里的init()调用</span></span><br><span class="line">calling main()<span class="comment">// main方法执行</span></span><br></pre></td></tr></table></figure><p>  由此可见，在遵循<strong>包变量 -&gt; 包init -&gt; main方法</strong>顺序的基础上，会严格<strong>按照代码文件名的字典序，从小到大执行。</strong></p></li></ul></li><li><p>多个不同package的初始化顺序</p><p> 上面讨论了<strong>同一个package</strong>内多个不同代码文件中的init()顺序，接下来看看多个<strong>不同package</strong>的初始化顺序。</p><p> 先说明一个基本结论：优先初始化依赖项（import项）最少的package。</p><ol><li><p>简单依赖</p><p> 整个程序有3个package：<code>package a</code>, <code>package b</code>, <code>package main</code>。其中<code>main</code>中import了<code>a</code>中的变量，<code>a</code>中import了<code>b</code>中的变量，形成了一条依赖链。</p><p> <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/import1.png" alt=""></p><ul><li><p><code>b.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = prepareB()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling b.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareB</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling b.prepareB()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>a.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"analyze_init/case_three/b"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = prepareA()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling a.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"calling a.prepareA(), reading b.B = %d\n"</span>, b.B)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>main.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"analyze_init/case_three/a"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"calling main(), reading a.A = %d\n"</span>, a.A)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码输出结果为：</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">calling b.prepareB()</span><br><span class="line">calling b.init()</span><br><span class="line">calling a.prepareA(), reading b.B = <span class="number">20</span></span><br><span class="line">calling a.init()</span><br><span class="line">calling main(), reading a.A = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>  显然就是根据import的路径链，从上到下进行初始化的。也就是说当有多个不同package时，会先初始化依赖项最少的，在这里就是package <code>b</code>，因为<code>b</code>没有import任何其他的自定义package。</p></li></ul></li><li><p>多个无依赖项的package</p><p> <strong>那如果整个程序里有多个package都无依赖项呢？</strong>如下图所示，package <code>b</code>和package <code>c</code>都无依赖项，会先初始化哪个？</p><p> <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/import2.png" alt=""></p><ul><li><p><code>b.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = prepareB()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling b.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareB</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling b.prepareB()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>a.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"analyze_init/case_four/c"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = prepareA()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling a.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"calling a.prepareA(), reading c.C = %d\n"</span>, c.C)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>c.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> C = prepareC()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling c.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareC</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling c.prepareC()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>main.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"analyze_init/case_four/a"</span></span><br><span class="line"><span class="string">"analyze_init/case_four/b"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"calling main(), reading a.A = %d, reading b.B = %d\n"</span>, a.A, b.B)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上述代码的输出结果为：</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">calling c.prepareC()<span class="comment">// 初始化c</span></span><br><span class="line">calling c.init()</span><br><span class="line">calling a.prepareA(), reading c.C = <span class="number">30</span><span class="comment">// 初始化a</span></span><br><span class="line">calling a.init()</span><br><span class="line">calling b.prepareB()<span class="comment">// 初始化b</span></span><br><span class="line">calling b.init()</span><br><span class="line">calling main(), reading a.A = <span class="number">10</span>, reading b.B = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>  从这个输出结果，可以看出两个问题：</p><ul><li>为什么先初始化package <code>c</code>，而不是package <code>b</code>？<code>b</code>和<code>c</code>均无依赖项，且从名字大小而言，<code>b</code>字母的字典序还比<code>c</code>小，为什么不是先初始化package <code>b</code>？</li><li><p>初始化完package <code>c</code>后，为什么不是初始化package <code>b</code>？</p><p>对于第一个问题，答案就是：在package初始化时，如果有多个package都无依赖项，会优先选择依赖路径最长的那个package开始。如上图<code>main-&gt;a-&gt;c</code>的路径是长于<code>main-&gt;b</code>的，所以会优先初始化package <code>c</code>，而非package <code>b</code>。</p><p>对于第二个问题，为什么package <code>c</code>之后不是package <code>b</code>，而是package <code>a</code>。因为它是参照<strong><em>DFS</em></strong>的逻辑进行初始化的，<code>c</code>搞定之后就会去初始化<code>c</code>的邻接节点，直到没有依赖项为0的节点为止。所以package <code>c</code>结束后，边<code>a-&gt;c</code>消失，此时发现package <code>a</code>也无依赖项，就继续初始化package <code>a</code>，然后边<code>main-&gt;a</code>消失，可是<code>main</code>还依赖于package <code>b</code>，所以要先初始化package <code>b</code>。</p></li></ul></li></ul></li><li><p>多package依赖路径长度相等时</p><p> 在上面的例子里两条依赖路径长度不等，所以会先初始化路径长的package。</p><p> <strong>那如果两个不同的package，从main出发到达的依赖路径长度完全相等呢？</strong></p><p> <img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/import3.png" alt=""></p><ul><li><p><code>a.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = prepareA()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling a.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling a.PrepareA()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>b.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> b</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = prepareB()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling b.init()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareB</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"calling b.PrepareB()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>main.go</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"analyze_init/case_five/a"</span></span><br><span class="line"><span class="string">"analyze_init/case_five/b"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"calling main(), reading a.A = %d, reading b.B = %d\n"</span>, a.A, b.B)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  代码的执行结果为：</p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">calling a.PrepareA()<span class="comment">// 初始化a</span></span><br><span class="line">calling a.init()</span><br><span class="line">calling b.PrepareB()<span class="comment">// 初始化b</span></span><br><span class="line">calling b.init()</span><br><span class="line">calling main(), reading a.A = <span class="number">10</span>, reading b.B = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>  显然，当依赖路径的长度相等时，会按照包名的字典序，从小到大进行初始化。</p></li></ul></li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在<code>Golang</code>里，“全局变量”的初始化和初始化方法<code>init()</code>的调用都跟package初始化密切相关。通过以上的多个例子，可以看出package初始化的几条规则：</p><ol><li>package初始化是以package为单位进行的</li><li>单个package的初始化，会按照<strong>全局变量 -&gt; init() -&gt; 其他</strong>的顺序执行</li><li>单个package中有多个<code>init()</code>的话，会按照<code>init()</code>所在的代码文件名，从小到大顺序初始化</li><li>多个package时，要先找到无对外依赖项的package，而不是单纯地按照文件名排序进行初始化</li><li>多个package时，还要参考从main到该package的依赖路径长度，路径长的优先初始化，后续按照DFS的逻辑进行</li><li>多个package时，若两条路径长度相等，就简单地考虑包名的字典序就好了</li></ol><p>总而言之，关键词就这几个：</p><ul><li>名称字典序</li><li>依赖项</li><li>依赖路径</li><li>DFS</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。&lt;/p&gt;
&lt;p&gt;本文写于2019/01/21，基于&lt;code&gt;Go 1.11&lt;/code&gt;。&lt;br&gt;至于其他版本的Go SDK，如有出入请自行查阅其他资料。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://yoursite.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>[MIT 6.824]Lab1笔记</title>
    <link href="http://yoursite.com/2019/01/03/mit6824-lab1/"/>
    <id>http://yoursite.com/2019/01/03/mit6824-lab1/</id>
    <published>2019-01-03T16:50:50.000Z</published>
    <updated>2019-01-03T02:58:27.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文100%内容为本人（Haoxiang Ma）原创，转载请标明出处。</p></blockquote><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>前几天开始自学<code>MIT</code>的分布式神课，大名鼎鼎的<code>MIT 6.824</code>。由于网上只搜得到2015 Spring的课程视频（youtube），感觉时间有点久远，就不看视频直接看materials了。</p><p>（如果找得到2017或者2018的就好了，<strong>然而人家MIT也没有任何义务把自己的核心课免费公开= =</strong>，能把materials全部免费公开就真的已经很慷慨了）</p><p>在Day 1，主要的内容还是热热身，先入分布式计算的门槛。所以要求读<code>map-reduce</code>的论文（<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">MapReduce: Simplified Data Processing on Large Clusters</a>），然后基于已有的代码和在paper中读到的理论来解决以下5个子问题</p><ol><li>实现<code>doMap()</code>和<code>doReduce()</code></li><li>实现<code>wordcount</code></li><li>实现多worker并发的map reduce</li><li>mr过程中rpc失败处理</li><li>利用mr实现倒排索引</li></ol><h3 id="Sub-problems"><a href="#Sub-problems" class="headerlink" title="Sub-problems"></a>Sub-problems</h3><ol><li><p>实现<code>doMap()</code>和<code>doReduce()</code></p><p> <code>doMap()</code>和<code>doReduce()</code>其实就是map job和reduce job的高层封装。</p><p> 先来看看<code>doMap()</code>。</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // mr job名称</span></span></span><br><span class="line"><span class="function"><span class="params">mapTask <span class="keyword">int</span>, // <span class="keyword">map</span>任务id</span></span></span><br><span class="line"><span class="function"><span class="params">inFile <span class="keyword">string</span>,// 该<span class="keyword">map</span>任务对应的输入文件名</span></span></span><br><span class="line"><span class="function"><span class="params">nReduce <span class="keyword">int</span>,// reducer数量</span></span></span><br><span class="line"><span class="function"><span class="params">mapF <span class="keyword">func</span>(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,// <span class="title">map</span>函数</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">// 把该map任务对应的文件内容全部读出来</span></span><br><span class="line">contents, err := ioutil.ReadFile(inFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建一个map, 记录file name和要写入该file的所有k-v对</span></span><br><span class="line">intermediateMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.List)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用map函数, 得到文件内容中的所有k-v对</span></span><br><span class="line">kvs := mapF(inFile, <span class="keyword">string</span>(contents))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每个k-v对算出它对应的reducer id, 用map记录一下</span></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">reducer := ihash(kv.Key) % nReduce</span><br><span class="line">intermediateFileName := reduceName(jobName, mapTask, reducer)</span><br><span class="line"><span class="keyword">if</span> currentList, ok := intermediateMap[intermediateFileName]; ok &#123;</span><br><span class="line">currentList.PushBack(kv)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">currentList = list.New()</span><br><span class="line">currentList.PushBack(kv)</span><br><span class="line">intermediateMap[intermediateFileName] = currentList</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写中间文件，把文件对应的所有k-v对都写到该文件中</span></span><br><span class="line"><span class="keyword">for</span> fileName, kvList := <span class="keyword">range</span> intermediateMap &#123;</span><br><span class="line">file, err := os.OpenFile(fileName, os.O_CREATE | os.O_WRONLY, <span class="number">0777</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">encoder := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> element := kvList.Front(); element != <span class="literal">nil</span>; element = element.Next() &#123;</span><br><span class="line">encoder.Encode(element.Value)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 用Java裸写过Hadoop mr程序的要实现<code>doMap()</code>应该很轻松，但是在实现的时候估计都会有点别扭。因为在写Hadoop mr的时候，只需要自己实现map函数，而且map函数接收的参数默认就是一行内容（或者某种InputFormat的一个单位）。</p><p> 而在这里我们要实现更高层的抽象，要把map函数的外层逻辑都实现好，调用map函数只是整个逻辑中的一小步。</p><p> 下面再来看看<code>doReduce()</code>。</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // 任务名称</span></span></span><br><span class="line"><span class="function"><span class="params">reduceTask <span class="keyword">int</span>, // reduce任务id</span></span></span><br><span class="line"><span class="function"><span class="params">outFile <span class="keyword">string</span>, // 输出到哪个文件</span></span></span><br><span class="line"><span class="function"><span class="params">nMap <span class="keyword">int</span>, // <span class="keyword">map</span>任务数</span></span></span><br><span class="line"><span class="function"><span class="params">reduceF <span class="keyword">func</span>(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,// <span class="title">reduce</span>函数</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">reduceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先从各个mapper输出的中间文件中读出属于本reducer的k-v对</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; nMap;i++ &#123;</span><br><span class="line">fileName := reduceName(jobName, i, reduceTask)</span><br><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 逐行读取, 一行一个k-v对</span></span><br><span class="line">line, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">kv := KeyValue&#123;&#125;</span><br><span class="line">json.Unmarshal([]<span class="keyword">byte</span>(line), &amp;kv)</span><br><span class="line">key := kv.Key</span><br><span class="line">value := kv.Value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过key来聚集, group by key</span></span><br><span class="line"><span class="keyword">if</span> values, ok := reduceMap[key]; ok &#123;</span><br><span class="line">reduceMap[key] = <span class="built_in">append</span>(values, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reduceMap[key] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">reduceMap[key] = <span class="built_in">append</span>(reduceMap[key], value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key来升序排序</span></span><br><span class="line">keys := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(reduceMap))</span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> reduceMap &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(keys, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> keys[i] &lt; keys[j]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于每个key, 调用reduce函数得到reduce后的结果, 写入结果文件</span></span><br><span class="line">out, err := os.OpenFile(outFile, os.O_CREATE | os.O_RDWR, <span class="number">0777</span>)</span><br><span class="line"><span class="keyword">defer</span> out.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">encoder := json.NewEncoder(out)</span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">reduceResult := reduceF(key, reduceMap[key])</span><br><span class="line">encoder.Encode(KeyValue&#123;Key: key, Value:reduceResult&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 看上述代码，<code>doReduce()</code>里的逻辑也非常清晰。主要的点在于mr模型中的key的有序性，<strong><em>本来在map和reduce之间会存在shuffle过程，在shuffle中会先对key进行排序，再broadcast到reducer端。</em></strong>但是在lab 1中没有严格定义一个<code>shuffle</code>过程，所以要在reducer端对key进行排序，再reduce，最后才根据key的升序来处理+输出。</p></li><li><p>实现<code>wordcount</code></p><p> 实现了<code>doMap()</code>和<code>doReduce()</code>后，说明框架性的map和reduce的入口已经写好了，那么就来实现第一个最简单的mr应用：<code>wordcount</code>。</p><p> 根据lab 1的map函数定义，map函数的入参是一个文件的<strong><em>#全部内容#</em></strong>，而不是Hadoop mr中map函数的<strong><em>#一行内容#</em></strong>，所以调用一次map函数，就得把某文件中的全部<code>k-v</code>对都生成并返回。</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">kvs := <span class="built_in">make</span>([]mapreduce.KeyValue, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用FieldsFunc来进行分词, 剔除非letter的内容</span></span><br><span class="line">terms := strings.FieldsFunc(contents, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要实现wordcount, 每个词要map成一个&lt;word, 1&gt;的二元组</span></span><br><span class="line"><span class="keyword">for</span> _, term := <span class="keyword">range</span> terms &#123;</span><br><span class="line">kvs = <span class="built_in">append</span>(kvs, mapreduce.KeyValue&#123;Key: term, Value: <span class="string">"1"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> kvs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在<code>mapF()</code>里，一开始我是傻乎乎地用<code>strings.Split()</code>来分词的，后来发现Split分词的逻辑太死板，只能根据某个特定的字符串来分割，不太符合需求。一番查阅才发现了<code>strings.FieldsFunc()</code>也可以实现分词，只需要传入一个匿名判断方法，告诉它要过滤哪些类型的字符就行了。</p><p> 至于reduce，逻辑更简单，入参是一个key和该key对应的所有value组成的slice。为了实现wordcount，只需要简单地输出某key有多少个对应的values就行，也就是<code>len(values)</code>。</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(<span class="built_in">len</span>(values))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现多worker并发的map reduce</p><p> lab 1里mr的运行模式有两种</p><ul><li>Sequential（串行，多个map任务串行执行，然后多个reduce任务串行执行）</li><li><p>Distributed（并发，多个map任务并发，然后多个reduce任务并发）</p><p>为了实现并发执行，我们需要完成<code>schedule.go</code>里的<code>schedule()</code>方法。在这个框架里，所谓的并发执行（Distributed），就是假设你有一个集群，里面有多台worker，作为调度者不需要亲自去逐个串行执行map或者reduce任务，只需要并发地把任务“扔”给空闲的worker，让worker去干活，它完成后会通知调度者。</p><p>这么并发执行的好处就是<strong><em>类异步机制</em></strong>，调度者不用串行等待，只管分配。当调度者收到了N个worker的完成回复，代表本次任务全部完成，即可结束。</p><p>接下来看看描述此逻辑的伪代码。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assign tasks to workers</span></span><br><span class="line">foreach task &#123;</span><br><span class="line">t = <span class="built_in">new</span> thread</span><br><span class="line">worker = t.get_available_worker()</span><br><span class="line">t.call_rpc_to_assign_task(worker, task)</span><br><span class="line">t.notify_master_success_or_fail()</span><br><span class="line">&#125;</span><br><span class="line">master.wait_for_all_task_completion()</span><br></pre></td></tr></table></figure><p>*在<code>golang</code>中，<code>thread</code>的作用可以用<code>goroutine</code>替代。</p></li></ul></li><li><p>并发mr过程中rpc失败处理</p><p> 在并发mr过程中，由于采用了<code>master - worker</code>这样的架构，所以master必然是通过<code>rpc</code>来给worker分配任务。但是由于</p><ul><li>网络异常导致失败</li><li>worker宕机</li><li>worker资源不足导致超时</li><li><p>worker代码逻辑出错</p><p>等种种原因，在分配任务时往往不是一次<code>rpc</code>就能顺利完成的，所以就需要对<code>rpc</code>的结果进行失败处理。在我的实现中策略是<strong><em>无限重复，当<code>rpc</code>失败后，再尝试从已注册的worker队列中取出另一个worker，进行重试，直到成功。</em></strong></p><p>当然还可以设计更复杂的策略，例如专门安排一个计算节点来出错处理，当某个<code>rpc</code>失败次数超过<code>M</code>次后，由特定计算节点接手，执行任务；或者master记录哪些节点成功次数多，当某个<code>rpc</code>失败次数超过<code>M</code>次后就把任务分发到高频节点上执行。</p><p>直接看我实现的代码。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line">ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">n_other = nReduce</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line">ntasks = nReduce</span><br><span class="line">n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用WaitGroup让主线程在最后阻塞, wait_for_all_tasks_completion</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(ntasks)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把每一个task, 都分发给一个空闲的worker</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i &lt; ntasks;i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用goroutine并发</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置task参数</span></span><br><span class="line">args := DoTaskArgs&#123;JobName: jobName, Phase: phase, TaskNumber: taskId, NumOtherPhase: n_other&#125;</span><br><span class="line"><span class="keyword">if</span> phase == mapPhase &#123;</span><br><span class="line">args.File = mapFiles[taskId]</span><br><span class="line">&#125;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环, 直到本task被worker回复完成</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 尝试从已注册的worker队列中取worker</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> workerAddr := &lt;- registerChan:</span><br><span class="line"><span class="keyword">if</span> call(workerAddr, <span class="string">"Worker.DoTask"</span>, args, <span class="literal">nil</span>) == <span class="literal">true</span> &#123;</span><br><span class="line">wg.Done()</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">registerChan &lt;- workerAddr<span class="comment">// 把worker归还队列</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- done:</span><br><span class="line"><span class="keyword">return</span><span class="comment">// 直到本task被回复完成才离开循环</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"waiting for the task-%d being done\n"</span>, taskId)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()<span class="comment">// 此处发生阻塞, 只有N个goroutine全部完成才解除阻塞</span></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，无限<code>for loop</code> + <code>select case</code>语句在读写<code>channel</code>的场景中<strong><em>十分常见！</em></strong>在第一个<code>select case</code>中，如果能够从worker队列里成功取出worker就发<code>rpc</code>，如果取不出，就无限循环尝试去取。</p><p>至于第二个<code>select case</code>，它的作用就是判断<code>rpc</code>是否成功，从而判断是否跳出无限循环。如果<code>rpc</code>成功，<code>done</code>里就会有一条新消息，<code>select case</code>语句自然就能执行到<code>return</code>跳出循环；如果<code>rpc</code>不成功，只会打印一句log，然后继续无限循环。</p><p>在解决出错处理的问题时，<strong><em>发现有一个很奇怪的地方，如果<code>rpc</code>返回false，就把worker归还到队列里去，某个任务会卡死在这个地方。</em></strong>后来检查调用<code>schedule()</code>的地方，也就是<code>Distributed()</code>里，发现worker队列是一个<strong><em>#阻塞（非缓冲）channel#，<code>ch := make(chan string)</code></em></strong>。⚠️当某个goroutine尝试把worker归还，却没有别的goroutine从channel取该worker的时候，尝试归还的goroutine会卡死。这样的设计感觉也是不合理的，存放worker的队列<strong><em>不应该</em></strong>是非缓冲的，那样最后一个归还worker的goroutine永远都会被卡死。</p><p>所以，我决定修改<code>Distributed()</code>里的channel的定义，把非缓冲channel改成缓冲channel，以解决此问题。</p></li></ul></li><li><p>利用mr实现倒排索引</p><p> 最后一个小题，用mr实现倒排索引（Inverted Index），主要就是自行实现<code>mapF()</code>和<code>reduceF()</code>里的逻辑，生成一个倒排索引的output文件。</p><p> （至于Hadoop mr实现的倒排索引，可以参考我之前的文章<a href="http://marcoma.xyz/2018/02/25/ii-wc/" target="_blank" rel="noopener">《谈谈倒排索引，升级版“WordCount”》</a>）</p><p> 具体的逻辑就是：从文件中读出全部内容，进行分词得到N个独立的<code>word</code>；然后把每个独立的<code>word</code>map成<code>&lt;word, file_name&gt;</code>的k-v对；在reducer中把同一个<code>word</code>的多个<code>file_name</code>集到一起，输出，搞定~</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice去重</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicate</span><span class="params">(terms []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(terms))</span><br><span class="line"><span class="keyword">for</span> _, term := <span class="keyword">range</span> terms &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := dict[term]; !ok &#123;</span><br><span class="line">dict[term] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, term)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">terms := strings.FieldsFunc(value, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// *关键, 对单词进行去重</span></span><br><span class="line">terms = removeDuplicate(terms)</span><br><span class="line"></span><br><span class="line">result := <span class="built_in">make</span>([]mapreduce.KeyValue, <span class="number">0</span>, <span class="built_in">len</span>(terms))</span><br><span class="line"><span class="keyword">for</span> _, term := <span class="keyword">range</span> terms &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, mapreduce.KeyValue&#123;Key: term, Value: document&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// *关键, 对单词进行去重</span></span><br><span class="line">values = removeDuplicate(values)</span><br><span class="line">numDoc := <span class="built_in">len</span>(values)</span><br><span class="line">docs := <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">docs += fmt.Sprintf(<span class="string">"%s,"</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d %s"</span>, numDoc, docs[:<span class="built_in">len</span>(docs) - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此处值得一提的就是要对单词进行去重操作，同一篇文章里的多个相同的单词，只应该生成一个<code>&lt;word, file_name&gt;</code>的k-v对，不然就会造成冗余计数。</p><p> 而<code>golang</code>里貌似又没有提供对slice去重的标准库方法，所以只能自己实现一个去重函数，利用<code>map</code>的key的不可重复性进行去重，<strong><em>使用<code>map[string]struct{}</code>是因为空struct不占任何字节，节省内存空间。</em></strong></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可能因为之前有深入研究过map reduce的模型，所以Lab 1感觉没有太大的难点，看来阅读原版的map reduce论文还是很有必要的。为数不多的问题主要出现在<code>golang</code>的一些特性上，例如</p><ul><li>slice去重</li><li>指针和值的区别</li><li>非缓冲（阻塞）channel的使用</li></ul><p>另外就是先要大致看懂已提供的代码里的框架逻辑，再作修改，那样debug起来也比较快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文100%内容为本人（Haoxiang Ma）原创，转载请标明出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overvi
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="bigdata" scheme="http://yoursite.com/tags/bigdata/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="mapreduce" scheme="http://yoursite.com/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>为2019年立下的flag</title>
    <link href="http://yoursite.com/2018/12/31/2019-flags/"/>
    <id>http://yoursite.com/2018/12/31/2019-flags/</id>
    <published>2019-01-01T04:45:30.000Z</published>
    <updated>2018-12-31T12:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><p>遥想2017/12/31晚上，当时还是我室友喊我去了<strong><em>Kerry Park</em></strong>跨年看烟花什么的。在萧瑟的寒风中，两三度的温度下，🎆🎆🎆绽放的一瞬间，默默地许了一个愿，希望自己的flag(s)都能不辱使命地完成。</p><p>现在2018马上就过去了，想想2017年给自己立下的flag(s)，好像也大概完成了个80%，感觉自己的自驱力确实还凑合，或者说兴趣 or 成就感驱动确实是有用的。</p><p>当然主要是在🎆🎆🎆中许愿起的作用吧！！！</p><h3 id="2019——也是一条有梦想的咸鱼🐟"><a href="#2019——也是一条有梦想的咸鱼🐟" class="headerlink" title="2019——也是一条有梦想的咸鱼🐟"></a>2019——也是一条有梦想的咸鱼🐟</h3><p>至于即将到来的2019年，既然从2018开始用心维护我这个没有人看的博客，那就恬不知耻地直接把flag(s)以blog post的形式公诸于世好了。为了</p><ol><li>给自己更强烈的心理助推，都公开了必须要尽全力做到吧，不然要被笑死了🤣</li><li>万一日后某天有幸成为了一名<code>伪大佬</code>，看看当年立下的flag(s)应该会很有意思🤣</li><li>或者日后某天彻底gg成为了一名油腻+愤世嫉俗+碌碌无为的loser，也能感慨一下自己当年也是个有梦想的咸鱼🤣</li></ol><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/jjfr.jpg" alt=""></p><p>立下flags</p><ul><li>技术篇<ul><li>积极follow几大computer system领域的顶会，争取认真研读+总结<code>&gt;=4篇</code>核心paper</li><li>读完<code>《ceph设计原理与实现》</code></li><li>读完<code>《Linux Kernel Development》</code></li><li>重读一遍<code>《MySQL InnoDB存储引擎》</code></li><li>产出原创技术博客<code>&gt;=18</code>篇</li><li>简单粗暴，<code>&gt;=70%</code>的天数有代码提交记录</li><li>全年自学时间<code>&gt;=365h</code></li></ul></li><li>爱好篇<ul><li>买一台单反 or 微单</li><li>产出<code>&gt;=50张</code>自己满意的静态照片</li><li>产出<code>&gt;=3个</code>自己满意的vlog</li><li>去<code>&gt;=2个</code>从来没有去过的城市旅游</li><li>学会<code>final cut pro</code>或者<code>pr</code>的简单操作，学会自己剪简单的视频</li></ul></li></ul><p>等到2019/12/31再来挖坟🤣，看看能给自己打多少分，希望起码及格（60%）吧🤣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2018&quot;&gt;&lt;a href=&quot;#2018&quot; class=&quot;headerlink&quot; title=&quot;2018&quot;&gt;&lt;/a&gt;2018&lt;/h3&gt;&lt;p&gt;遥想2017/12/31晚上，当时还是我室友喊我去了&lt;strong&gt;&lt;em&gt;Kerry Park&lt;/em&gt;&lt;/strong&gt;
      
    
    </summary>
    
      <category term="目标" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87/"/>
    
    
      <category term="目标" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>[Raft]Log Replication笔记</title>
    <link href="http://yoursite.com/2018/12/17/raft-log-replication/"/>
    <id>http://yoursite.com/2018/12/17/raft-log-replication/</id>
    <published>2018-12-17T23:22:00.000Z</published>
    <updated>2018-12-18T03:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><code>Raft</code>中的核心步骤是</p><ol><li>选主</li><li>日志复制</li></ol><p>在上一篇<a href="http://marcoma.xyz/2018/12/09/raft-leader-election/" target="_blank" rel="noopener">《Raft选主笔记》</a>中，相信已经清晰说明了<code>Raft</code>中选主的多个限制。通过一系列严格的筛选后，被选出来的<code>Raft Leader</code>就能接收来自客户端的请求，进行各种数据处理。</p><p>在本篇笔记中，主要打算记录<strong>日志复制（Log Replication）</strong>中的一些知识点。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>既然说到了“日志复制”，那么先来看看复制过程中用到的各种数据结构。</p><p>在基础的<code>Raft</code>中，只有两种RPC请求：</p><ul><li><code>RequestVote RPC</code> —— 由Candidate主动发出，请求大家进行投票</li><li><code>AppendEntries RPC</code> —— 由Leader主动发出，请求Followers进行日志复制</li></ul><p>根据<code>Raft</code>论文里的原图，我们可以总结出以下的数据结构。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RequestVote RPC</span></span><br><span class="line"><span class="keyword">type</span> RequestVote <span class="keyword">struct</span> &#123;</span><br><span class="line">TermId <span class="keyword">int64</span><span class="comment">// candidate的term id</span></span><br><span class="line">LeaderId <span class="keyword">int64</span><span class="comment">// candidate的leader id</span></span><br><span class="line">LastLogIndex <span class="keyword">int64</span><span class="comment">// candidate存的最后一条log entry的下标</span></span><br><span class="line">LastLogTerm <span class="keyword">int64</span><span class="comment">// candidate存的最后一条log entry的term id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppendEntries RPC</span></span><br><span class="line"><span class="keyword">type</span> AppendEntries <span class="keyword">struct</span> &#123;</span><br><span class="line">TermId <span class="keyword">int64</span><span class="comment">// leader的term id</span></span><br><span class="line">LeaderId <span class="keyword">int64</span><span class="comment">// leader id</span></span><br><span class="line">PrevLogIndex <span class="keyword">int64</span><span class="comment">// 当前发送entries的前一条entry的下标</span></span><br><span class="line">PrevLogTerm <span class="keyword">int64</span><span class="comment">// 当前发送entries的前一条entry的term</span></span><br><span class="line">LastCommittedIndex <span class="keyword">int64</span><span class="comment">// leader上最后一条commit的entry的下标</span></span><br><span class="line">Entries []LogEntry<span class="comment">// 当前要发送的1或N条log entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了两种RPC请求外，每台server（无论是Leader还是Follower还是Candidate）上都肯定要存一些<strong>系统变量</strong>，用来记录自己或者系统的状态。</p><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ServerState <span class="keyword">struct</span> &#123;</span><br><span class="line">CurrentTerm <span class="keyword">int64</span><span class="comment">// 本机上的当前term id</span></span><br><span class="line">VoteFor <span class="keyword">int64</span><span class="comment">// 本轮投票投给了谁（该机器的id）</span></span><br><span class="line">LogEntries []LogEntry<span class="comment">// 本机上存的log entries</span></span><br><span class="line"></span><br><span class="line">LastCommittedIndex <span class="keyword">int64</span><span class="comment">// 本机最后一条commit的log entry的下标</span></span><br><span class="line">LastAppliedIndex <span class="keyword">int64</span><span class="comment">// 本机最后一条被状态机执行的log entry的下标</span></span><br><span class="line"></span><br><span class="line">NextIndex []<span class="keyword">int64</span><span class="comment">// *leader特有，为每一台follower维护一个下次要发送的log entry的下标</span></span><br><span class="line">MatchIndex []<span class="keyword">int64</span><span class="comment">// *leader特有，为每一台follower维护一个已经成功匹配上的log entry的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Log-Replication过程"><a href="#Log-Replication过程" class="headerlink" title="Log Replication过程"></a>Log Replication过程</h2><ol><li><p>当集群接收到来自客户端的存储请求</p><ul><li>客户端发给Follower，Follower转发给Leader？或者告诉客户端请它发给Leader？</li><li>客户端直接发给Leader，Leader接收请求</li></ul></li><li><p>Leader自己先把请求里的数据落盘，存在本地，更新自身的meta data</p></li><li><p>Leader发起<code>AppendEntries RPC</code>，请求集群中的其他Follower进行日志复制</p></li><li><p>每台Follower都接收到<code>AppendEntries RPC</code>，检查RPC请求里的各项参数，以确定是否接受该请求</p><ul><li><p>比较<code>AppendEntriesRPC.TermId</code>与<code>Follower.CurrentTerm</code></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有当RPC请求里的Term*不小于*当前Follower的Term，才能接受</span></span><br><span class="line"><span class="keyword">if</span> AppendEntriesRPC.TermId &lt; Follower.CurrentTerm &#123;</span><br><span class="line">IgnoreRPC()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> AppendEntriesRPC.TermId &gt; Follower.CurrentTerm &#123;</span><br><span class="line">UpdateCurrentTerm()</span><br><span class="line">&#125;</span><br><span class="line">AcceptRPC()</span><br></pre></td></tr></table></figure></li><li><p>比较完Term后，若成功接受，则要处理<code>PrevLogIndex</code>和<code>PrevLogTerm</code>了。为什么要处理这两个参数呢？<strong>因为要通过它们来保证：在本次<code>AppendEntries</code>之前的所有log entry都是主从之间正确同步的。</strong></p>  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">index := AppendEntriesRPC.PrevLogIndex</span><br><span class="line">term := AppendEntriesRPC.PrevLogTerm</span><br><span class="line"><span class="keyword">if</span> Follower.LogEntries[index].Term != term &#123;</span><br><span class="line">StopAndNotifyLeader()<span class="comment">// 告知Leader双方达成一致的位置</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">AcceptLogEntries()<span class="comment">// 已经达成一致，接受所有log entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看出，当Leader的历史log entry和Follower的历史log entry出现不一致时，是不能进行日志复制的，<strong>完成一次日志复制的前提是：在本次日志复制之前的所有log entry都必须是一致的。</strong></p><p>  所以当发生了不一致时，应该停止日志复制，并把本机上最后一个<code>term == AppendEntriesRPC.PrevLogTerm</code>的log entry index告知Leader，好让Leader下次重新发起<code>AppendEntriesRPC</code>时能够定位到大家都共同一致的位置。</p></li></ul></li><li><p>Leader重新定位PrevLogIndex和PrevLogTerm后 / 或者无需调整本身就是一致的情况下，Follower就接受该<code>AppendEntriesRPC</code>，把<code>AppendEntriesRPC.Entries</code>落盘到本机上，回复Leader已成功落盘</p></li><li><p>Leader为每个Follower维护一些落盘成功与否的变量，当Leader通过Follower的回复监测到某条log entry已被过半的Follower落盘，即可更新Leader自身的<code>LastCommittedIndex</code>，待下次<code>AppendEntriesRPC</code>发送时告诉各个Follower要commit哪一条log entry</p> <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如可以用一个map类容器实现这个逻辑</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">SERVER_COUNT = <span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> committedMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">followerId := AppendEntrisResponse.FollowerId</span><br><span class="line">savedLogIndices := AppendEntrisResponse.savedIndices</span><br><span class="line"><span class="keyword">for</span> _, savedIndex := <span class="keyword">range</span> savedLogIndices &#123;</span><br><span class="line">committedMap[savedIndex] += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> committedMap[savedIndex] &gt;= SERVER_COUNT / <span class="number">2</span> &#123;</span><br><span class="line">Leader.LastCommittedIndex = savedIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新NextIndex和MatchIndex数组</span></span><br><span class="line">Leader.NextIndex[followerId] = savedIndex + <span class="number">1</span></span><br><span class="line">Leader.MatchIndex[followerId] = savedIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>待下次<code>AppendEntriesRPC</code>时，Leader把最新的<code>LastCommittedIndex</code>告知Follower，Follower就可以在本地的状态机上执行<code>LastCommittedIndex</code>之前的log entry，然后回复Leader哪些log entry已被成功执行，Leader对应更新MatchIndex数组</p></li></ol><h2 id="NextIndex-amp-MatchIndex"><a href="#NextIndex-amp-MatchIndex" class="headerlink" title="NextIndex &amp; MatchIndex"></a>NextIndex &amp; MatchIndex</h2><p>在<code>ServerState</code>中大部分变量都很好理解，只有2个变量——<code>NextIndex</code>和<code>MatchIndex</code>是比较奇怪的，因为它们都是数组类型的变量，<strong>而且是Leader特有的变量</strong>。</p><ul><li><code>NextIndex</code>：为每个Follower记录了将要发给该Follower的下一条log entry的index（初始值为<code>Leader.LastLogIndex + 1</code>）</li><li><code>MatchIndex</code>：为每个Follower记录了该Follower上已经成功匹配的log entry的index（初始值为<code>0</code>）</li></ul><p>乍一看上去，正常情况下<code>MatchIndex[i]</code>貌似一直等于<code>NextIndex[i] - 1</code>。但总是会有特殊情况的，假如某台Follower的机子在某一时刻宕机了几十秒，在这几十秒里也经历了Leader的更迭，那么<code>MatchIndex[i]</code>就很有可能不等于<code>NextIndex[i] - 1</code>。在这种情况下，Leader要先根据<code>MatchIndex[i]</code>确定最后一个正确同步的位置，然后重新设置<code>NextIndex[i] = MatchIndex[i] + 1</code>，重新进行历史log entry的同步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Raft&lt;/code&gt;中的核心步骤是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选主&lt;/li&gt;

      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[Raft]Leader Election(选主)笔记</title>
    <link href="http://yoursite.com/2018/12/09/raft-leader-election/"/>
    <id>http://yoursite.com/2018/12/09/raft-leader-election/</id>
    <published>2018-12-09T16:12:35.000Z</published>
    <updated>2018-12-17T07:21:59.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Raft采用Leader - Follower的架构，主要的工作都由Leader来主动调度和完成，所以选出一个合法的Leader是首要任务。</p></li><li><p>为了保证不丢数据（<strong>特指已经commit且成功通知client的数据</strong>），Raft对Leader有严格的要求，不是集群里随便一台服务器都能够当上Leader，这种“严格的要求”大多体现在选主过程中。</p></li><li><p>选主过程最重要的限制是：</p><p><strong><em>Leader必须存有所有已经commit过的log entry，这样才能保证整个分布式系统的一致性。</em></strong></p><p><strong>在外部用户看来，已经commit成功的就必然是100%正常存储好了的。</strong>如果选出一个Leader，结果它上面缺了几条已经commit过的数据，那这个分布式系统就没有任何意义了。几分钟前跟用户说“我已经commit了，你放心吧”，过一会用户想查一查数据却发现“尼玛，怎么丢数据了，说好的已经commit了呢？！”</p></li><li><p>为了满足这个条件（Leader上必须存有所有已经commit过的数据），Raft中提出了两个限制条件，<strong>如果严格遵守以下两个条件，是能保证选出合法Leader的</strong>。</p><ul><li>在选主过程中，每台服务器只会投票给拥有比自己更新的log entry的服务器。</li><li>Leader在commit log entry的时候，只允许<strong>直接</strong>commit当前term（任期）的log entry，决不允许<strong>直接</strong>commit“历史”log entry。（历史log entry只能<strong>间接被动</strong>commit）</li></ul><p>（1）先来看看第一个条件：每台server只会投票给拥有比自己更新的log entry的server。这句话里最关键的是如何定义<strong>“更新的log entry”</strong>。按照Raft论文里给出的定义：</p><blockquote><p>Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs. If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.</p></blockquote><ul><li>两台服务器上的<strong>最后一条</strong>log entry，如果它们的term不同，则term更大者是“更新”的。</li><li>两台服务器上的<strong>最后一条</strong>log entry，如果它们的term相同，则index更大者是“更新”的。</li></ul><p>（这里我觉得论文里漏了一个小细节，如果两条log entry的term和index都相同，<strong>应该会默认把发起投票的服务器当成更新的</strong>，term和index都一样的情况下不存在所谓的“更新”，一切为了选主的顺利进行，能快速有效选出leader才是最重要的。） </p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/raft_latest_1.png" alt=""> </p><p>如上图所示，根据Raft的判断标准，<strong>下者的记录比上者更新，因为下者最后一条log entry的term为5，5比4大</strong>。 </p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/raft_latest_2.png" alt=""> </p><p>如上图所示，根据Raft的判断标准，<strong>上者的记录比上者更新，因为上者最后一条log entry的index为4，下者最后一条log entry的index为3，4比3大</strong>。 </p><p>（2）再研究第二个条件：Leader只允许<strong>直接</strong>commit当前term（任期）的log entry，决不允许<strong>直接</strong>commit“历史”log entry。这条前提一看上去有点云里雾里的，感觉并没有什么必要性。<strong>实则不然，这条前提非常重要，是用来避免异常情况下频繁换Leader可能造成的commited log entry被覆盖的问题。</strong> </p><p>Raft原版论文里也给出了一个经典场景： </p><p><img src="https://blog-image-1253224514.cos.ap-guangzhou.myqcloud.com/raft_election.png" alt=""></p><ul><li>在(a)阶段，已经处于<code>term:2</code>了，<code>S1</code>是本轮（<code>term:2</code>）的leader。在<code>S1</code>上任后没多久，收到了客户端的请求，写入一条<code>{term:2, index:2}</code>的log，并将此log成功复制到<code>S2</code>这个小兄弟上。<strong>结果天不如人愿，还没来得及把log复制到其他小兄弟上，<code>S1</code>自己就宕机了。</strong></li><li>到了(b)阶段，<code>S1</code>宕机后，整个集群处于无领导状态。经过了一小会，<code>S5</code>很幸运率先结束timeout，自增term号（从<code>term:2</code>自增到<code>term:3</code>），发起了选主。由于此时<code>S3</code>和<code>S4</code>上的记录都和<code>S5</code>一样新，所以都愿意投票给<code>S5</code>，<code>S5</code>成功当选，成为leader。<code>S5</code>成为leader后马上又收到了客户端的请求，于是在本机上写入一条<code>{term:3, index:2}</code>的log。<strong>然而<code>S5</code>的命运比<code>S1</code>更惨，只来得及存在本地，来不及把log entry复制给任何一个小兄弟，直接就挂了。</strong></li><li>此时来到了(c)状态，<code>S5</code>挂了之后，<code>S1</code>成功重启恢复运转。<code>S1</code>自告奋勇，自增全局term号（从<code>term:3</code>自增到<code>term:4</code>），请求大家选主。<code>S2 ~ S4</code>都会投给<code>S1</code>，<code>S1</code>顺利当选leader。<code>S1</code>成了leader后做了第一件事情，发现之前<code>{term:2, index:2}</code>的log还没有成功复制给大部分兄弟，于是开始复制工作，把log复制到了<code>S3</code>上。突然<code>S1</code>又收到了客户端的请求，写入一条<code>{term:4, index:3}</code>的log到本机。</li></ul><p>以上3步都非常理所当然，没有任何的争议点，最大的争议点就出现在了(d)和(e)上。<strong>(d)和(e)实际上是(c)发生之后的两种互斥的可能情况，(d)是忽视第二条前提会发生的情况，(e)是满足第二条前提会发生的情况。</strong></p><ul><li>先看(d)。<strong>假设我们忽略第二条前提，也就是说leader可以随意commit任何term的log entry。</strong>那么在(c)结束之后，作为<code>term:4</code>的leader的<code>S1</code><strong>可以commit掉<code>{term:2, index:2}</code>的log，并且把结果返回给客户端。</strong>结果刚完成以上步骤，<code>S1</code>又倒霉地宕机了，<code>{term:4, index:3}</code>的log没来得及复制给任何一个小兄弟。过了一会，<code>S5</code>恢复正常，自增全局term号（从<code>term:4</code>自增到<code>term:5</code>），要求选主。由于此时<code>S5</code>上的最后一条log是<code>{term:3, index:2}</code>，比<code>S2 ~ S4</code>的都更新，大家都会投票给<code>S5</code>，<code>S5</code>成功当上<code>term:5</code>的leader。当上leader后，<code>S5</code>的第一件事情就是把它还没来得及复制给多个小兄弟的log复制出去，所以就造成了(d)状态，所有服务器上的log记录都被<code>S5</code>自己的log记录覆盖了。<strong>之前已经成功commit的<code>{term:2, index:2}</code>的log直接被覆盖，消失无踪⚠️！</strong></li><li>再看(e)。<strong>假设我们一定要坚守第二条前提，也就是说leader只能直接commit当前term的log entry，不能直接commit历史log entry。</strong>那么在(c)结束后，<code>S1</code>也不能commit<code>{term:2, index:2}</code>的log，因为<code>S1</code>此时是<code>term:4</code>的leader，而不是<code>term:2</code>的leader。只有如(e)所示，之后<code>S1</code>有机会commit属于当前term的log entry（<code>{term:4, index:3}</code>）时，才有机会<strong>间接地</strong>把之前<code>term:2</code>的历史记录也commit掉。即使此时<code>S1</code>宕机，<code>S5</code>也绝对不可能选上下一轮的leader，因为<code>S5</code>上最新的log<code>{term:3, index:2}</code>已经不如<code>S1 ~ S3</code>的新了，他拿不到过半的选票，做不了leader，也就不会发生已经commit的记录被覆盖的错误了。</li></ul><p>经过这一轮例子分析，可以很清晰地看到第二条前提的重要性了。如果允许leader随便直接commit历史记录的话，极端情况下很可能会造成数据丢失的系统错误（客户端知道你commit成功了，他就应该能放心了，结果过了一会你跟客户说commit也不算数，我搞丢了。。。。。。）<strong>所以，对于历史记录的commit只能被动触发！！！在commit当前term的log entry时顺便把之前未处理的log entry给commit掉。</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Raft采用Leader - Follower的架构，主要的工作都由Leader来主动调度和完成，所以选出一个合法的Leader是首要任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了保证不丢数据（&lt;strong&gt;特指已经commit且成功通知client的数
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
