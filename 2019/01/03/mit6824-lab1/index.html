<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="本文100%内容为本人（Haoxiang Ma）原创，转载请标明出处。  Overview前几天开始自学MIT的分布式神课，大名鼎鼎的MIT 6.824。由于网上只搜得到2015 Spring的课程视频（youtube），感觉时间有点久远，就不看视频直接看materials了。 （如果找得到2017或者2018的就好了，然而人家MIT也没有任何义务把自己的核心课免费公开= =，能把materia">
<meta name="keywords" content="分布式,bigdata,hadoop,mapreduce">
<meta property="og:type" content="article">
<meta property="og:title" content="[MIT 6.824]Lab1笔记">
<meta property="og:url" content="http://yoursite.com/2019/01/03/mit6824-lab1/index.html">
<meta property="og:site_name" content="Haoxiang Ma&#39;s Tech Blog">
<meta property="og:description" content="本文100%内容为本人（Haoxiang Ma）原创，转载请标明出处。  Overview前几天开始自学MIT的分布式神课，大名鼎鼎的MIT 6.824。由于网上只搜得到2015 Spring的课程视频（youtube），感觉时间有点久远，就不看视频直接看materials了。 （如果找得到2017或者2018的就好了，然而人家MIT也没有任何义务把自己的核心课免费公开= =，能把materia">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-03T02:58:27.440Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[MIT 6.824]Lab1笔记">
<meta name="twitter:description" content="本文100%内容为本人（Haoxiang Ma）原创，转载请标明出处。  Overview前几天开始自学MIT的分布式神课，大名鼎鼎的MIT 6.824。由于网上只搜得到2015 Spring的课程视频（youtube），感觉时间有点久远，就不看视频直接看materials了。 （如果找得到2017或者2018的就好了，然而人家MIT也没有任何义务把自己的核心课免费公开= =，能把materia">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>[MIT 6.824]Lab1笔记</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/01/21/go-package-init/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/12/31/2019-flags/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/01/03/mit6824-lab1/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/01/03/mit6824-lab1/&text=[MIT 6.824]Lab1笔记"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/01/03/mit6824-lab1/&is_video=false&description=[MIT 6.824]Lab1笔记"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[MIT 6.824]Lab1笔记&body=Check out this article: http://yoursite.com/2019/01/03/mit6824-lab1/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/01/03/mit6824-lab1/&name=[MIT 6.824]Lab1笔记&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sub-problems"><span class="toc-number">2.</span> <span class="toc-text">Sub-problems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        [MIT 6.824]Lab1笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">Haoxiang Ma's Tech Blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-01-03T16:50:50.000Z" itemprop="datePublished">2019-01-03</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/bigdata/">bigdata</a>, <a class="tag-link" href="/tags/hadoop/">hadoop</a>, <a class="tag-link" href="/tags/mapreduce/">mapreduce</a>, <a class="tag-link" href="/tags/分布式/">分布式</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>本文100%内容为本人（Haoxiang Ma）原创，转载请标明出处。</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>前几天开始自学<code>MIT</code>的分布式神课，大名鼎鼎的<code>MIT 6.824</code>。由于网上只搜得到2015 Spring的课程视频（youtube），感觉时间有点久远，就不看视频直接看materials了。</p>
<p>（如果找得到2017或者2018的就好了，<strong>然而人家MIT也没有任何义务把自己的核心课免费公开= =</strong>，能把materials全部免费公开就真的已经很慷慨了）</p>
<p>在Day 1，主要的内容还是热热身，先入分布式计算的门槛。所以要求读<code>map-reduce</code>的论文（<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">MapReduce: Simplified Data Processing on Large Clusters</a>），然后基于已有的代码和在paper中读到的理论来解决以下5个子问题</p>
<ol>
<li>实现<code>doMap()</code>和<code>doReduce()</code></li>
<li>实现<code>wordcount</code></li>
<li>实现多worker并发的map reduce</li>
<li>mr过程中rpc失败处理</li>
<li>利用mr实现倒排索引</li>
</ol>
<h3 id="Sub-problems"><a href="#Sub-problems" class="headerlink" title="Sub-problems"></a>Sub-problems</h3><ol>
<li><p>实现<code>doMap()</code>和<code>doReduce()</code></p>
<p> <code>doMap()</code>和<code>doReduce()</code>其实就是map job和reduce job的高层封装。</p>
<p> 先来看看<code>doMap()</code>。</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>, // mr job名称</span></span></span><br><span class="line"><span class="function"><span class="params">	mapTask <span class="keyword">int</span>, // <span class="keyword">map</span>任务id</span></span></span><br><span class="line"><span class="function"><span class="params">	inFile <span class="keyword">string</span>,	// 该<span class="keyword">map</span>任务对应的输入文件名</span></span></span><br><span class="line"><span class="function"><span class="params">	nReduce <span class="keyword">int</span>,	// reducer数量</span></span></span><br><span class="line"><span class="function"><span class="params">	mapF <span class="keyword">func</span>(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,	// <span class="title">map</span>函数</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">	<span class="comment">// 把该map任务对应的文件内容全部读出来</span></span><br><span class="line">	contents, err := ioutil.ReadFile(inFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 建一个map, 记录file name和要写入该file的所有k-v对</span></span><br><span class="line">	intermediateMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*list.List)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用map函数, 得到文件内容中的所有k-v对</span></span><br><span class="line">	kvs := mapF(inFile, <span class="keyword">string</span>(contents))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个k-v对算出它对应的reducer id, 用map记录一下</span></span><br><span class="line">	<span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">		reducer := ihash(kv.Key) % nReduce</span><br><span class="line">		intermediateFileName := reduceName(jobName, mapTask, reducer)</span><br><span class="line">		<span class="keyword">if</span> currentList, ok := intermediateMap[intermediateFileName]; ok &#123;</span><br><span class="line">			currentList.PushBack(kv)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			currentList = list.New()</span><br><span class="line">			currentList.PushBack(kv)</span><br><span class="line">			intermediateMap[intermediateFileName] = currentList</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写中间文件，把文件对应的所有k-v对都写到该文件中</span></span><br><span class="line">	<span class="keyword">for</span> fileName, kvList := <span class="keyword">range</span> intermediateMap &#123;</span><br><span class="line">		file, err := os.OpenFile(fileName, os.O_CREATE | os.O_WRONLY, <span class="number">0777</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		encoder := json.NewEncoder(file)</span><br><span class="line">		<span class="keyword">for</span> element := kvList.Front(); element != <span class="literal">nil</span>; element = element.Next() &#123;</span><br><span class="line">			encoder.Encode(element.Value)</span><br><span class="line">		&#125;</span><br><span class="line">		file.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 用Java裸写过Hadoop mr程序的要实现<code>doMap()</code>应该很轻松，但是在实现的时候估计都会有点别扭。因为在写Hadoop mr的时候，只需要自己实现map函数，而且map函数接收的参数默认就是一行内容（或者某种InputFormat的一个单位）。</p>
<p> 而在这里我们要实现更高层的抽象，要把map函数的外层逻辑都实现好，调用map函数只是整个逻辑中的一小步。</p>
<p> 下面再来看看<code>doReduce()</code>。</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>, // 任务名称</span></span></span><br><span class="line"><span class="function"><span class="params">	reduceTask <span class="keyword">int</span>, // reduce任务id</span></span></span><br><span class="line"><span class="function"><span class="params">	outFile <span class="keyword">string</span>, // 输出到哪个文件</span></span></span><br><span class="line"><span class="function"><span class="params">	nMap <span class="keyword">int</span>, // <span class="keyword">map</span>任务数</span></span></span><br><span class="line"><span class="function"><span class="params">	reduceF <span class="keyword">func</span>(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,	// <span class="title">reduce</span>函数</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">	reduceMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先从各个mapper输出的中间文件中读出属于本reducer的k-v对</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; nMap;i++ &#123;</span><br><span class="line">		fileName := reduceName(jobName, i, reduceTask)</span><br><span class="line">		file, err := os.Open(fileName)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">		reader := bufio.NewReader(file)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// 逐行读取, 一行一个k-v对</span></span><br><span class="line">			line, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			kv := KeyValue&#123;&#125;</span><br><span class="line">			json.Unmarshal([]<span class="keyword">byte</span>(line), &amp;kv)</span><br><span class="line">			key := kv.Key</span><br><span class="line">			value := kv.Value</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 通过key来聚集, group by key</span></span><br><span class="line">			<span class="keyword">if</span> values, ok := reduceMap[key]; ok &#123;</span><br><span class="line">				reduceMap[key] = <span class="built_in">append</span>(values, value)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				reduceMap[key] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">				reduceMap[key] = <span class="built_in">append</span>(reduceMap[key], value)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		file.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据key来升序排序</span></span><br><span class="line">	keys := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(reduceMap))</span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> reduceMap &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(keys, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> keys[i] &lt; keys[j]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对于每个key, 调用reduce函数得到reduce后的结果, 写入结果文件</span></span><br><span class="line">	out, err := os.OpenFile(outFile, os.O_CREATE | os.O_RDWR, <span class="number">0777</span>)</span><br><span class="line">	<span class="keyword">defer</span> out.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	encoder := json.NewEncoder(out)</span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		reduceResult := reduceF(key, reduceMap[key])</span><br><span class="line">		encoder.Encode(KeyValue&#123;Key: key, Value:reduceResult&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 看上述代码，<code>doReduce()</code>里的逻辑也非常清晰。主要的点在于mr模型中的key的有序性，<strong><em>本来在map和reduce之间会存在shuffle过程，在shuffle中会先对key进行排序，再broadcast到reducer端。</em></strong>但是在lab 1中没有严格定义一个<code>shuffle</code>过程，所以要在reducer端对key进行排序，再reduce，最后才根据key的升序来处理+输出。</p>
</li>
<li><p>实现<code>wordcount</code></p>
<p> 实现了<code>doMap()</code>和<code>doReduce()</code>后，说明框架性的map和reduce的入口已经写好了，那么就来实现第一个最简单的mr应用：<code>wordcount</code>。</p>
<p> 根据lab 1的map函数定义，map函数的入参是一个文件的<strong><em>#全部内容#</em></strong>，而不是Hadoop mr中map函数的<strong><em>#一行内容#</em></strong>，所以调用一次map函数，就得把某文件中的全部<code>k-v</code>对都生成并返回。</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">	kvs := <span class="built_in">make</span>([]mapreduce.KeyValue, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用FieldsFunc来进行分词, 剔除非letter的内容</span></span><br><span class="line">	terms := strings.FieldsFunc(contents, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 要实现wordcount, 每个词要map成一个&lt;word, 1&gt;的二元组</span></span><br><span class="line">	<span class="keyword">for</span> _, term := <span class="keyword">range</span> terms &#123;</span><br><span class="line">		kvs = <span class="built_in">append</span>(kvs, mapreduce.KeyValue&#123;Key: term, Value: <span class="string">"1"</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kvs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在<code>mapF()</code>里，一开始我是傻乎乎地用<code>strings.Split()</code>来分词的，后来发现Split分词的逻辑太死板，只能根据某个特定的字符串来分割，不太符合需求。一番查阅才发现了<code>strings.FieldsFunc()</code>也可以实现分词，只需要传入一个匿名判断方法，告诉它要过滤哪些类型的字符就行了。</p>
<p> 至于reduce，逻辑更简单，入参是一个key和该key对应的所有value组成的slice。为了实现wordcount，只需要简单地输出某key有多少个对应的values就行，也就是<code>len(values)</code>。</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(<span class="built_in">len</span>(values))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现多worker并发的map reduce</p>
<p> lab 1里mr的运行模式有两种</p>
<ul>
<li>Sequential（串行，多个map任务串行执行，然后多个reduce任务串行执行）</li>
<li><p>Distributed（并发，多个map任务并发，然后多个reduce任务并发）</p>
<p>为了实现并发执行，我们需要完成<code>schedule.go</code>里的<code>schedule()</code>方法。在这个框架里，所谓的并发执行（Distributed），就是假设你有一个集群，里面有多台worker，作为调度者不需要亲自去逐个串行执行map或者reduce任务，只需要并发地把任务“扔”给空闲的worker，让worker去干活，它完成后会通知调度者。</p>
<p>这么并发执行的好处就是<strong><em>类异步机制</em></strong>，调度者不用串行等待，只管分配。当调度者收到了N个worker的完成回复，代表本次任务全部完成，即可结束。</p>
<p>接下来看看描述此逻辑的伪代码。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assign tasks to workers</span></span><br><span class="line">foreach task &#123;</span><br><span class="line">	t = <span class="built_in">new</span> thread</span><br><span class="line">	worker = t.get_available_worker()</span><br><span class="line">	t.call_rpc_to_assign_task(worker, task)</span><br><span class="line">	t.notify_master_success_or_fail()</span><br><span class="line">&#125;</span><br><span class="line">master.wait_for_all_task_completion()</span><br></pre></td></tr></table></figure>
<p>*在<code>golang</code>中，<code>thread</code>的作用可以用<code>goroutine</code>替代。</p>
</li>
</ul>
</li>
<li><p>并发mr过程中rpc失败处理</p>
<p> 在并发mr过程中，由于采用了<code>master - worker</code>这样的架构，所以master必然是通过<code>rpc</code>来给worker分配任务。但是由于</p>
<ul>
<li>网络异常导致失败</li>
<li>worker宕机</li>
<li>worker资源不足导致超时</li>
<li><p>worker代码逻辑出错</p>
<p>等种种原因，在分配任务时往往不是一次<code>rpc</code>就能顺利完成的，所以就需要对<code>rpc</code>的结果进行失败处理。在我的实现中策略是<strong><em>无限重复，当<code>rpc</code>失败后，再尝试从已注册的worker队列中取出另一个worker，进行重试，直到成功。</em></strong></p>
<p>当然还可以设计更复杂的策略，例如专门安排一个计算节点来出错处理，当某个<code>rpc</code>失败次数超过<code>M</code>次后，由特定计算节点接手，执行任务；或者master记录哪些节点成功次数多，当某个<code>rpc</code>失败次数超过<code>M</code>次后就把任务分发到高频节点上执行。</p>
<p>直接看我实现的代码。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用WaitGroup让主线程在最后阻塞, wait_for_all_tasks_completion</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(ntasks)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把每一个task, 都分发给一个空闲的worker</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; ntasks;i++ &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 使用goroutine并发</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 设置task参数</span></span><br><span class="line">			args := DoTaskArgs&#123;JobName: jobName, Phase: phase, TaskNumber: taskId, NumOtherPhase: n_other&#125;</span><br><span class="line">			<span class="keyword">if</span> phase == mapPhase &#123;</span><br><span class="line">				args.File = mapFiles[taskId]</span><br><span class="line">			&#125;</span><br><span class="line">			done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 无限循环, 直到本task被worker回复完成</span></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 尝试从已注册的worker队列中取worker</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> workerAddr := &lt;- registerChan:</span><br><span class="line">					<span class="keyword">if</span> call(workerAddr, <span class="string">"Worker.DoTask"</span>, args, <span class="literal">nil</span>) == <span class="literal">true</span> &#123;</span><br><span class="line">						wg.Done()</span><br><span class="line">						done &lt;- <span class="literal">true</span></span><br><span class="line">					&#125;</span><br><span class="line">					registerChan &lt;- workerAddr	<span class="comment">// 把worker归还队列</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- done:</span><br><span class="line">					<span class="keyword">return</span>	<span class="comment">// 直到本task被回复完成才离开循环</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					fmt.Printf(<span class="string">"waiting for the task-%d being done\n"</span>, taskId)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()	<span class="comment">// 此处发生阻塞, 只有N个goroutine全部完成才解除阻塞</span></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，无限<code>for loop</code> + <code>select case</code>语句在读写<code>channel</code>的场景中<strong><em>十分常见！</em></strong>在第一个<code>select case</code>中，如果能够从worker队列里成功取出worker就发<code>rpc</code>，如果取不出，就无限循环尝试去取。</p>
<p>至于第二个<code>select case</code>，它的作用就是判断<code>rpc</code>是否成功，从而判断是否跳出无限循环。如果<code>rpc</code>成功，<code>done</code>里就会有一条新消息，<code>select case</code>语句自然就能执行到<code>return</code>跳出循环；如果<code>rpc</code>不成功，只会打印一句log，然后继续无限循环。</p>
<p>在解决出错处理的问题时，<strong><em>发现有一个很奇怪的地方，如果<code>rpc</code>返回false，就把worker归还到队列里去，某个任务会卡死在这个地方。</em></strong>后来检查调用<code>schedule()</code>的地方，也就是<code>Distributed()</code>里，发现worker队列是一个<strong><em>#阻塞（非缓冲）channel#，<code>ch := make(chan string)</code></em></strong>。⚠️当某个goroutine尝试把worker归还，却没有别的goroutine从channel取该worker的时候，尝试归还的goroutine会卡死。这样的设计感觉也是不合理的，存放worker的队列<strong><em>不应该</em></strong>是非缓冲的，那样最后一个归还worker的goroutine永远都会被卡死。</p>
<p>所以，我决定修改<code>Distributed()</code>里的channel的定义，把非缓冲channel改成缓冲channel，以解决此问题。</p>
</li>
</ul>
</li>
<li><p>利用mr实现倒排索引</p>
<p> 最后一个小题，用mr实现倒排索引（Inverted Index），主要就是自行实现<code>mapF()</code>和<code>reduceF()</code>里的逻辑，生成一个倒排索引的output文件。</p>
<p> （至于Hadoop mr实现的倒排索引，可以参考我之前的文章<a href="http://marcoma.xyz/2018/02/25/ii-wc/" target="_blank" rel="noopener">《谈谈倒排索引，升级版“WordCount”》</a>）</p>
<p> 具体的逻辑就是：从文件中读出全部内容，进行分词得到N个独立的<code>word</code>；然后把每个独立的<code>word</code>map成<code>&lt;word, file_name&gt;</code>的k-v对；在reducer中把同一个<code>word</code>的多个<code>file_name</code>集到一起，输出，搞定~</p>
 <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// slice去重</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicate</span><span class="params">(terms []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	result := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(terms))</span><br><span class="line">	<span class="keyword">for</span> _, term := <span class="keyword">range</span> terms &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := dict[term]; !ok &#123;</span><br><span class="line">			dict[term] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			result = <span class="built_in">append</span>(result, term)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">	terms := strings.FieldsFunc(value, <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *关键, 对单词进行去重</span></span><br><span class="line">	terms = removeDuplicate(terms)</span><br><span class="line"></span><br><span class="line">	result := <span class="built_in">make</span>([]mapreduce.KeyValue, <span class="number">0</span>, <span class="built_in">len</span>(terms))</span><br><span class="line">	<span class="keyword">for</span> _, term := <span class="keyword">range</span> terms &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, mapreduce.KeyValue&#123;Key: term, Value: document&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// *关键, 对单词进行去重</span></span><br><span class="line">	values = removeDuplicate(values)</span><br><span class="line">	numDoc := <span class="built_in">len</span>(values)</span><br><span class="line">	docs := <span class="string">""</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		docs += fmt.Sprintf(<span class="string">"%s,"</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d %s"</span>, numDoc, docs[:<span class="built_in">len</span>(docs) - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此处值得一提的就是要对单词进行去重操作，同一篇文章里的多个相同的单词，只应该生成一个<code>&lt;word, file_name&gt;</code>的k-v对，不然就会造成冗余计数。</p>
<p> 而<code>golang</code>里貌似又没有提供对slice去重的标准库方法，所以只能自己实现一个去重函数，利用<code>map</code>的key的不可重复性进行去重，<strong><em>使用<code>map[string]struct{}</code>是因为空struct不占任何字节，节省内存空间。</em></strong></p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可能因为之前有深入研究过map reduce的模型，所以Lab 1感觉没有太大的难点，看来阅读原版的map reduce论文还是很有必要的。为数不多的问题主要出现在<code>golang</code>的一些特性上，例如</p>
<ul>
<li>slice去重</li>
<li>指针和值的区别</li>
<li>非缓冲（阻塞）channel的使用</li>
</ul>
<p>另外就是先要大致看懂已提供的代码里的框架逻辑，再作修改，那样debug起来也比较快。</p>

  </div>
</article>

    <div class="blog-post-comments">
        
        
        <div class="vcomment"></div>
        
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sub-problems"><span class="toc-number">2.</span> <span class="toc-text">Sub-problems</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/01/03/mit6824-lab1/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/01/03/mit6824-lab1/&text=[MIT 6.824]Lab1笔记"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/01/03/mit6824-lab1/&is_video=false&description=[MIT 6.824]Lab1笔记"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[MIT 6.824]Lab1笔记&body=Check out this article: http://yoursite.com/2019/01/03/mit6824-lab1/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/01/03/mit6824-lab1/&title=[MIT 6.824]Lab1笔记"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/01/03/mit6824-lab1/&name=[MIT 6.824]Lab1笔记&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Haoxiang Ma
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


<!-- Valine Comments -->

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<script type="text/javascript">
    var notify = 'false' == true ? true : false;
    var verify = 'false' == true ? true : false;
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail'.split(',').filter(function(item){
      return GUEST_INFO.indexOf(item) > -1
    });
    guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "1mYS96DR4e28MDXJxW1ByUA6-gzGzoHsz",
        appKey: "IMF92wd7jJxCXanv65MdkiBn",
        avatar:"",
        placeholder: "Say something...",
        guest_info:guest_info,
        pageSize:"10"
    })
</script>


</body>
</html>
