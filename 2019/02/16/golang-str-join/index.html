<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。 本文写于2019/02/16，基于Go 1.11。至于其他版本的Go SDK，如有出入请自行查阅其他资料。  Overview写本文的动机来源于Golang中文社区里一篇有头没尾的帖子《Go语言字符串高效拼接》，里面只提了Golang里面字符串拼接的几种方式，但是在最后却不讲每种方式的性能，也没有给出任何的best prac">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="[Golang]字符串拼接方式的性能分析">
<meta property="og:url" content="http://yoursite.com/2019/02/16/golang-str-join/index.html">
<meta property="og:site_name" content="Haoxiang Ma&#39;s Tech Blog">
<meta property="og:description" content="本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。 本文写于2019/02/16，基于Go 1.11。至于其他版本的Go SDK，如有出入请自行查阅其他资料。  Overview写本文的动机来源于Golang中文社区里一篇有头没尾的帖子《Go语言字符串高效拼接》，里面只提了Golang里面字符串拼接的几种方式，但是在最后却不讲每种方式的性能，也没有给出任何的best prac">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-02-17T01:11:42.296Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Golang]字符串拼接方式的性能分析">
<meta name="twitter:description" content="本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。 本文写于2019/02/16，基于Go 1.11。至于其他版本的Go SDK，如有出入请自行查阅其他资料。  Overview写本文的动机来源于Golang中文社区里一篇有头没尾的帖子《Go语言字符串高效拼接》，里面只提了Golang里面字符串拼接的几种方式，但是在最后却不讲每种方式的性能，也没有给出任何的best prac">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>[Golang]字符串拼接方式的性能分析</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/23/gin-tutorial-1/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/02/12/mysql-innodb-index-in-practice/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/02/16/golang-str-join/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/02/16/golang-str-join/&text=[Golang]字符串拼接方式的性能分析"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/02/16/golang-str-join/&is_video=false&description=[Golang]字符串拼接方式的性能分析"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[Golang]字符串拼接方式的性能分析&body=Check out this article: http://yoursite.com/2019/02/16/golang-str-join/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/02/16/golang-str-join/&name=[Golang]字符串拼接方式的性能分析&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能测试"><span class="toc-number">2.</span> <span class="toc-text">性能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">3.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        [Golang]字符串拼接方式的性能分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">Haoxiang Ma's Tech Blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-02-17T01:00:00.000Z" itemprop="datePublished">2019-02-16</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Go/">Go</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>本文100%由本人（Haoxiang Ma）原创，如需转载请注明出处。</p>
<p>本文写于2019/02/16，基于<code>Go 1.11</code>。<br>至于其他版本的Go SDK，如有出入请自行查阅其他资料。</p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>写本文的动机来源于Golang中文社区里一篇有头没尾的帖子<a href="https://studygolang.com/articles/18084#commentForm" target="_blank" rel="noopener">《Go语言字符串高效拼接》</a>，里面只提了Golang里面字符串拼接的几种方式，但是在最后却不讲每种方式的性能，也没有给出任何的best practice。本着无聊 + 好奇心，就决定自行写benchmark来测试，再对结果和源码进行分析，试图给出我认为的best practice吧。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>根据帖子里的内容，在<code>Golang</code>里有5种字符串拼接的方式：</p>
<ul>
<li><p>直接+号拼接</p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接+号拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithAdd</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">		s += str</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fmt.Sprint()拼接</p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fmt拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithFmt</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := fmt.Sprint(strs)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strings.Join()拼接</p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strings.Join拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithJoin</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := strings.Join(strs, <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Buffer拼接</p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bytes.Buffer拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithBuffer</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	buf := bytes.Buffer&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">		buf.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Builder拼接</p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// strings.Builder拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcatWithBuilder</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	builder := strings.Builder&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</span><br><span class="line">		builder.WriteString(str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> builder.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>为了测试各自的性能，就用<code>Golang</code>自带test模块的benchmark来进行测试。</p>
<p>在测试中，分3组数据，5组测试，即一共3 * 5 = 15次独立测试。其中3组数据是指：</p>
<ul>
<li>size = 10K的字符串数组，每个元素均为<code>&quot;hello&quot;</code></li>
<li>size = 50K的字符串数组，每个元素均为<code>&quot;hello&quot;</code></li>
<li>size = 100K的字符串数组，每个元素均为<code>&quot;hello&quot;</code></li>
</ul>
<p>5组测试是指：</p>
<ul>
<li>直接+号拼接，要跑10K、50K、100K的数据</li>
<li>fmt.Sprint()拼接，要跑10K、50K、100K的数据</li>
<li>strings.Join()拼接，要跑10K、50K、100K的数据</li>
<li>Buffer拼接，要跑10K、50K、100K的数据</li>
<li>Builder拼接，要跑10K、50K、100K的数据</li>
</ul>
<p>Benchmark代码如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Strs10K  []<span class="keyword">string</span>	<span class="comment">// 长度为10K的字符串数组</span></span><br><span class="line">	Strs50K  []<span class="keyword">string</span>	<span class="comment">// 长度为50K的字符串数组</span></span><br><span class="line">	Strs100K []<span class="keyword">string</span>	<span class="comment">// 长度为100K的字符串数组</span></span><br><span class="line">	word = <span class="string">"hello"</span>		<span class="comment">// 待拼接的字符串</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ADD = <span class="literal">iota</span></span><br><span class="line">	BUFFER</span><br><span class="line">	BUILDER</span><br><span class="line">	JOIN</span><br><span class="line">	FMT</span><br><span class="line"></span><br><span class="line">	_10K = <span class="number">10000</span></span><br><span class="line">	_50K = <span class="number">50000</span></span><br><span class="line">	_100K = <span class="number">100000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// preset和teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">	Strs10K = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, _10K)</span><br><span class="line">	Strs50K = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, _50K)</span><br><span class="line">	Strs100K = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, _100K)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; _100K;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; _10K) &#123;</span><br><span class="line">			Strs10K = <span class="built_in">append</span>(Strs10K, word)</span><br><span class="line">			Strs50K = <span class="built_in">append</span>(Strs50K, word)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; _50K) &#123;</span><br><span class="line">			Strs50K = <span class="built_in">append</span>(Strs50K, word)</span><br><span class="line">		&#125;</span><br><span class="line">		Strs100K = <span class="built_in">append</span>(Strs100K, word)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	exitCode := m.Run()</span><br><span class="line">	os.Exit(exitCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试直接+号拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, ADD))</span><br><span class="line">	b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, ADD))</span><br><span class="line">	b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, ADD))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试bytes.Buffer拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithBuffer</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, BUFFER))</span><br><span class="line">	b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, BUFFER))</span><br><span class="line">	b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, BUFFER))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试strings.Builder拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithBuilder</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, BUILDER))</span><br><span class="line">	b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, BUILDER))</span><br><span class="line">	b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, BUILDER))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试strings.Join拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithJoin</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, JOIN))</span><br><span class="line">	b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, JOIN))</span><br><span class="line">	b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, JOIN))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试fmt拼接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatWithFmt</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.Run(<span class="string">"Concat-10000"</span>, GetTestConcat(Strs10K, FMT))</span><br><span class="line">	b.Run(<span class="string">"Concat-50000"</span>, GetTestConcat(Strs50K, FMT))</span><br><span class="line">	b.Run(<span class="string">"Concat-100000"</span>, GetTestConcat(Strs100K, FMT))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据拼接类型（testType），返回对应的测试方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTestConcat</span><span class="params">(strs []<span class="keyword">string</span>, testType <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	concatFunc := <span class="function"><span class="keyword">func</span><span class="params">([]<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;<span class="keyword">return</span> <span class="string">""</span>&#125;</span><br><span class="line">	<span class="keyword">switch</span> testType &#123;</span><br><span class="line">	<span class="keyword">case</span> ADD:</span><br><span class="line">		concatFunc = ConcatWithAdd</span><br><span class="line">	<span class="keyword">case</span> BUFFER:</span><br><span class="line">		concatFunc = ConcatWithBuffer</span><br><span class="line">	<span class="keyword">case</span> BUILDER:</span><br><span class="line">		concatFunc = ConcatWithBuilder</span><br><span class="line">	<span class="keyword">case</span> JOIN:</span><br><span class="line">		concatFunc = ConcatWithJoin</span><br><span class="line">	<span class="keyword">case</span> FMT:</span><br><span class="line">		concatFunc = ConcatWithFmt</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; b.N;i++ &#123;</span><br><span class="line">			concatFunc(strs)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试（<code>go test -bench=. -benchmem</code>），结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">  4 BenchmarkConcatWithAdd/Concat-10000-4                 20      57050217 ns/op    270493320 B/op      9999 allocs/op</span><br><span class="line">  5 BenchmarkConcatWithAdd/Concat-50000-4                  2     937660008 ns/op    6435464656 B/op    49999 allocs/op</span><br><span class="line">  6 BenchmarkConcatWithAdd/Concat-100000-4                 1    3748714961 ns/op    25388918224 B/op       99999 allocs/op</span><br><span class="line">  7 BenchmarkConcatWithBuffer/Concat-10000-4           10000        138797 ns/op      209376 B/op         12 allocs/op</span><br><span class="line">  8 BenchmarkConcatWithBuffer/Concat-50000-4            3000        481466 ns/op      840160 B/op         14 allocs/op</span><br><span class="line">  9 BenchmarkConcatWithBuffer/Concat-100000-4           2000        966963 ns/op     1659360 B/op         15 allocs/op</span><br><span class="line"> 10 BenchmarkConcatWithBuilder/Concat-10000-4          10000        103924 ns/op      227320 B/op         21 allocs/op</span><br><span class="line"> 11 BenchmarkConcatWithBuilder/Concat-50000-4           3000        495917 ns/op     1431545 B/op         28 allocs/op</span><br><span class="line"> 12 BenchmarkConcatWithBuilder/Concat-100000-4          2000        891950 ns/op     2930682 B/op         31 allocs/op</span><br><span class="line"> 13 BenchmarkConcatWithJoin/Concat-10000-4             10000        106288 ns/op      114688 B/op          2 allocs/op</span><br><span class="line"> 14 BenchmarkConcatWithJoin/Concat-50000-4              3000        505209 ns/op      507904 B/op          2 allocs/op</span><br><span class="line"> 15 BenchmarkConcatWithJoin/Concat-100000-4             2000        990317 ns/op     1015808 B/op          2 allocs/op</span><br><span class="line"> 16 BenchmarkConcatWithFmt/Concat-10000-4               1000       1293589 ns/op      227716 B/op      10002 allocs/op</span><br><span class="line"> 17 BenchmarkConcatWithFmt/Concat-50000-4                200       6260637 ns/op     1131960 B/op      50003 allocs/op</span><br><span class="line"> 18 BenchmarkConcatWithFmt/Concat-100000-4               100      12005780 ns/op     2499702 B/op     100006 allocs/op</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>
<p>可以看出</p>
<ul>
<li>运行速度上，Builder、Buffer、Join的速度属于同一数量级，绝对值也差不了太多；fmt要比它们一个数量级；直接+号拼接是最慢的。</li>
<li>内存分配上，Join表现最优秀，Buffer次之，Builder第三；而fmt和直接+号拼接最差，要执行很多次内存分配操作。</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li><p>速度&amp;内存分配都很优秀的<code>strings.Join()</code></p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// 专门为短数组拼接做的优化</span></span><br><span class="line">	<span class="comment">// 详情查阅golang.org/issue/6714</span></span><br><span class="line">	<span class="keyword">switch</span> <span class="built_in">len</span>(a) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> a[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> a[<span class="number">0</span>] + sep + a[<span class="number">1</span>]</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">return</span> a[<span class="number">0</span>] + sep + a[<span class="number">1</span>] + sep + a[<span class="number">2</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算总共要插入多长的分隔符，n = 分隔符总长</span></span><br><span class="line">	n := <span class="built_in">len</span>(sep) * (<span class="built_in">len</span>(a) - <span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历待拼接的数组，逐个叠加字符串的长度</span></span><br><span class="line">	<span class="comment">// 最后n = 分隔符总长 + 所有字符串的总长 = 拼接结果的总长</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		n += <span class="built_in">len</span>(a[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一次性分配n byte的内存空间，并且把第一个字符串拷贝到slice的头部</span></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">	bp := <span class="built_in">copy</span>(b, a[<span class="number">0</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从下标为1开始，调用原生的copy函数</span></span><br><span class="line">	<span class="comment">// 逐个把分隔符&amp;字符串拷贝到slice里对应的位置</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> a[<span class="number">1</span>:] &#123;</span><br><span class="line">		bp += <span class="built_in">copy</span>(b[bp:], sep)</span><br><span class="line">		bp += <span class="built_in">copy</span>(b[bp:], s)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最后将byte slice强转为string，返回</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看出<code>strings.Join()</code>为什么表现如此优秀，<strong>主要原因是只有1次的显式内存分配（<code>b := make([]byte, n)</code>）和1次隐式内存分配（<code>return string(b)</code>）</strong>，不需要在拼接过程中反复多次分配内存，挪动内存里的数据，减少了很多内存管理的消耗。</p>
</li>
<li><p>略差一筹的<code>bytes.Buffer.WriteString()</code></p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试扩容n个单位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">tryGrowByReslice</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果底层slice的剩余空间 &gt;= n个单位，就不需要重新分配内存</span></span><br><span class="line">	<span class="comment">// 而是reslice，把底层slice的cap限定在l + n</span></span><br><span class="line">	<span class="keyword">if</span> l := <span class="built_in">len</span>(b.buf); n &lt;= <span class="built_in">cap</span>(b.buf)-l &#123;</span><br><span class="line">		b.buf = b.buf[:l+n]</span><br><span class="line">		<span class="keyword">return</span> l, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果底层slice的剩余空间不足n个单位，放弃reslice</span></span><br><span class="line">	<span class="comment">// 说明需要重新分配内存，而不是reslice那么简单了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容n个单位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">grow</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	m := b.Len()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 边界情况，空slice，先把一些属性reset掉</span></span><br><span class="line">	<span class="keyword">if</span> m == <span class="number">0</span> &amp;&amp; b.off != <span class="number">0</span> &#123;</span><br><span class="line">		b.Reset()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先试试不真正分配空间，通过reslice来“扩容”</span></span><br><span class="line">	<span class="keyword">if</span> i, ok := b.tryGrowByReslice(n); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// bootstrap是一个长度为64的slice，在buffer对象初始化时，</span></span><br><span class="line">	<span class="comment">// bootstrap就已经分配好了，如果n小于bootstrap长度，</span></span><br><span class="line">	<span class="comment">// 可以利用bootstrap slice来reslice，不需要重新分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span> b.buf == <span class="literal">nil</span> &amp;&amp; n &lt;= <span class="built_in">len</span>(b.bootstrap) &#123;</span><br><span class="line">		b.buf = b.bootstrap[:n]</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 上述几种情况都无法满足</span></span><br><span class="line">	c := <span class="built_in">cap</span>(b.buf)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= c/<span class="number">2</span>-m &#123;</span><br><span class="line">		<span class="comment">// 理解为m + n &lt;= c/2比较好</span></span><br><span class="line">		<span class="comment">// 如果扩容后的长度（m + n）比c/2要小，说明当前还有一大堆可用的空间</span></span><br><span class="line">		<span class="comment">// 直接reslice，以b.off打头</span></span><br><span class="line">		<span class="built_in">copy</span>(b.buf, b.buf[b.off:])</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> c &gt; maxInt-c-n &#123;</span><br><span class="line">		<span class="comment">// c + c + n &gt; maxInt，申请扩容n个单位太多了，不可接受</span></span><br><span class="line">		<span class="built_in">panic</span>(ErrTooLarge)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 当前剩余的空间不太够了，重新分配内存，长度为c + c + n</span></span><br><span class="line">		buf := makeSlice(<span class="number">2</span>*c + n)</span><br><span class="line">		<span class="built_in">copy</span>(buf, b.buf[b.off:])</span><br><span class="line">		b.buf = buf</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Restore b.off and len(b.buf).</span></span><br><span class="line">	b.off = <span class="number">0</span></span><br><span class="line">	b.buf = b.buf[:m+n]</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	b.lastRead = opInvalid</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先尝试reslice得到len(s)个单位的空间</span></span><br><span class="line">	m, ok := b.tryGrowByReslice(<span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// 无法通过reslice得到空间，直接粗暴地申请grow</span></span><br><span class="line">		m = b.grow(<span class="built_in">len</span>(s))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">copy</span>(b.buf[m:], s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  为什么<code>bytes.Buffer.WriteString()</code>性能比Join差呢，其实也是内存分配策略惹的祸。在Join里只有两次内存空间申请的操作，而<code>Buffer</code>里可能会有很多次。具体来说就是<code>buf := makeSlice(2*c + n)</code>这一句，每次重申请只申请<code>2 * c + n</code>的空间，用完了就要再申请<code>2 * c + n</code>。当拼接的数据项很多，每次申请的空间也就<code>2 * c + n</code>，很快就用完了，又要再重新申请，所以造成了性能不是很高。</p>
</li>
<li><p>略差一筹的<code>strings.Builder()</code></p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	b.copyCheck()</span><br><span class="line">	b.buf = <span class="built_in">append</span>(b.buf, s...)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  代码很简洁，就是最直白的slice append，一时append一时爽，一直append一直爽。所以当底层slice的可用空间不足，就会在append里一直申请新的内存空间。跟<code>bytes.Buffer</code>不同的是，这里并没有自己管理“扩容”的逻辑，而是交由原生的append函数去管理。</p>
</li>
<li><p>最差劲的<code>fmt.Sprint()</code></p>
  <figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> buffer []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pp <span class="keyword">struct</span> &#123;</span><br><span class="line">	buf buffer</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	p := newPrinter()</span><br><span class="line">	p.doPrint(a)</span><br><span class="line">	s := <span class="keyword">string</span>(p.buf)</span><br><span class="line">	p.free()</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>printer</code>里的核心数据结构就是<code>buf</code>，而<code>buf</code>其实就是一个<code>[]byte</code>，所以给<code>buf</code>不停地拼接字符串，空间不够了又继续开辟新的内存空间，所以性能低下。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>实际上，只有当拼接的字符串非常非常多的时候，才需要纠结性能。像本文里动辄拼接10K、50K、100K个字符串的情况在实际业务中应该是很少很少的。</strong></p>
<p>如果实在要纠结性能，参考以下几点</p>
<ul>
<li>Join的速度最好，但是不至于完爆Builder和Buffer。三者的速度属于同一数量级。fmt和直接+号拼接速度最慢。</li>
<li>Join的内存分配策略最好，内存分配次数最少；Builder和Buffer的内存分配策略还算可以，类似于线性增长；fmt和直接+号拼接的内存分配策略最差。</li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        
        
        <div class="vcomment"></div>
        
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能测试"><span class="toc-number">2.</span> <span class="toc-text">性能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">3.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/02/16/golang-str-join/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/02/16/golang-str-join/&text=[Golang]字符串拼接方式的性能分析"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/02/16/golang-str-join/&is_video=false&description=[Golang]字符串拼接方式的性能分析"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[Golang]字符串拼接方式的性能分析&body=Check out this article: http://yoursite.com/2019/02/16/golang-str-join/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/02/16/golang-str-join/&title=[Golang]字符串拼接方式的性能分析"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/02/16/golang-str-join/&name=[Golang]字符串拼接方式的性能分析&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Haoxiang Ma
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/about">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


<!-- Valine Comments -->

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<script type="text/javascript">
    var notify = 'false' == true ? true : false;
    var verify = 'false' == true ? true : false;
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail'.split(',').filter(function(item){
      return GUEST_INFO.indexOf(item) > -1
    });
    guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
    new Valine({
        el: '.vcomment',
        notify: notify,
        verify: verify,
        appId: "1mYS96DR4e28MDXJxW1ByUA6-gzGzoHsz",
        appKey: "IMF92wd7jJxCXanv65MdkiBn",
        avatar:"",
        placeholder: "Say something...",
        guest_info:guest_info,
        pageSize:"10"
    })
</script>


</body>
</html>
